<!-- Candidate detail view with automatic workflow 
    the passed data:
    - "analysis": data.pop("analysis"),
    - "generated_message": data.pop("last_message"),
    - "resume_text": data.pop("resume_text"),
    - "full_resume": data.pop("full_resume"),
    - "candidate": data,
-->
{% set view_mode = view_mode or 'interactive' %}
{% set allow_optimization_feedback = allow_optimization_feedback if allow_optimization_feedback is defined else (view_mode != 'readonly') %}
<div id="candidate-detail-root" class="space-y-6" data-view-mode="{{ view_mode }}">
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div class="flex items-center gap-2">
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <button 
                onclick="copyCandidateLink()"
                class="p-1.5 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded transition"
                title="å¤åˆ¶å€™é€‰äººè¯¦æƒ…é“¾æ¥">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                </svg>
            </button>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>
    
    <!-- Contact Information Section -->
    {% set metadata = candidate.metadata if candidate.metadata else {} %}
    {% set phone_number = metadata.phone_number if metadata and metadata.phone_number else None %}
    {% set wechat_number = metadata.wechat_number if metadata and metadata.wechat_number else None %}
    {% if phone_number or wechat_number %}
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
        <div class="flex flex-wrap gap-4">
            {% if phone_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="font-mono text-blue-700">{{ phone_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
            {% if wechat_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="font-mono text-blue-700">{{ wechat_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
        </div>
    </div>
    {% endif %}
    
    {% if candidate.name and ('å…ˆç”Ÿ' in candidate.name or 'å¥³å£«' in candidate.name) and candidate.chat_id and candidate.mode == 'recommend' %}
        <div class="flex items-center space-x-2 bg-yellow-100 border-l-4 border-yellow-400 text-yellow-800 px-4 py-2 rounded shadow-sm my-2">
            <span>âš ï¸</span>
            <span>
                æ£€æµ‹åˆ°å€™é€‰äººå§“ååŒ…å«<strong>ã€Œå…ˆç”Ÿã€</strong>æˆ–<strong>ã€Œå¥³å£«ã€</strong>ï¼Œå¯¼è‡´æ•°æ®å¯èƒ½é‡å¤ï¼Œè¯·è®¤çœŸæ£€æŸ¥ä»¥ä¸‹å†…å®¹æ˜¯å¦å’Œæ‹›è˜ç½‘ç«™ä¸€è‡´ã€‚å¦‚æœä¸ä¸€è‡´ï¼Œè¯·é‡æ–°è·å–ç®€å†ã€‚
            </span>
        </div>
    {% endif %}

    <!-- Hidden context for HTMX requests - using JSON to preserve types -->
    <div id="candidate-context" class="hidden" hx-vals='{{ candidate | tojson | safe }}'></div>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <!-- <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div> -->
        <!-- Tab Navigation -->
        <div class="flex border-b bg-gray-100 items-center">
            <button id="tab-online" onclick="switchResumeTab('online')" 
                    class="px-4 py-2 font-medium text-sm transition-colors bg-white border-b-2 border-blue-500 text-blue-600">
                åœ¨çº¿ç®€å†
            </button>
            <button id="tab-full" onclick="switchResumeTab('full')" 
                    class="px-4 py-2 font-medium text-sm transition-colors text-gray-600 hover:text-gray-800">
                å®Œæ•´ç®€å†
            </button>
            <div class="flex-1"></div>
            {% if view_mode != 'readonly' %}
            <button 
                id="fetch-online-resume-btn"
                onclick="fetchOnlineResume()"
                class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–åœ¨çº¿ç®€å†</span>
            </button>
            <button 
                id="fetch-full-resume-btn"
                onclick="fetchFullResume().catch(err => console.warn('Re-fetch failed:', err))"
                class="hidden px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–å®Œæ•´ç®€å†</span>
            </button>
            {% endif %}
        </div>
        <!-- Tab Content -->
        <div id="resume-content" class="p-2"> 
            <!-- Online Resume Tab -->
            <div id="tab-content-online" class="tab-content">
                <div id="resume-online-container">
                    <textarea id="resume-textarea-online" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if resume_text -%}{{ resume_text }}{%- else -%}â³ æ­£åœ¨åŠ è½½åœ¨çº¿ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
            <!-- Full Resume Tab -->
            <div id="tab-content-full" class="tab-content hidden">
                <div id="resume-full-container">
                    <textarea id="resume-textarea-full" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if full_resume -%}{{ full_resume }}{%- else -%}â³ æ­£åœ¨åŠ è½½å®Œæ•´ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
            <div id="analysis-resume-type-badge" class="ml-3">
                <!-- Will be populated by JavaScript based on analysis result -->
            </div>
            <div class="flex-1"></div>
            {% if allow_optimization_feedback %}
            <button onclick="openOptimizationFeedbackModal()"
                    class="px-3 py-1 text-xs bg-red-100 text-red-800 rounded hover:bg-amber-200 transition flex items-center gap-1 mr-2">
                <span>âœï¸</span>
                <span>è¯„åˆ†ä¸å‡†</span>
            </button>
            {% endif %}
            {% if view_mode != 'readonly' %}
            <button onclick="startAnalysis()"
                    class="px-3 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°åˆ†æ</span>
            </button>
            {% endif %}
        </div>
        <div id="analysis-content" class="p-2">
            {% if analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center p-4 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    {% if allow_optimization_feedback %}
    <!-- Optimization Feedback Modal (è¯„åˆ†ä¸å‡†) -->
    <div id="optimization-feedback-modal"
         class="fixed inset-0 z-50 hidden items-center justify-center bg-black bg-opacity-50 p-4"
         role="dialog"
         aria-modal="true">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-2xl">
            <div class="flex items-center justify-between px-5 py-4 border-b">
                <h3 class="text-lg font-semibold text-gray-800">è¯„åˆ†ä¸å‡†ï¼ˆç”¨äºä¼˜åŒ–å²—ä½è‚–åƒï¼‰</h3>
                <button onclick="closeOptimizationFeedbackModal()" class="text-gray-500 hover:text-gray-800">âœ•</button>
            </div>
            <div class="p-5 space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">å²—ä½ï¼ˆå›ºå®šï¼‰</label>
                    <div id="optimization-job-display"
                         class="w-full px-3 py-2 border rounded-lg bg-gray-50 text-gray-800">
                        â³ è§£æä¸­...
                    </div>
                    <p class="text-xs text-gray-500 mt-1">æ ¹æ®å€™é€‰äººçš„ job_applied è‡ªåŠ¨åŒ¹é…å²—ä½ï¼ˆä¸å…è®¸æ‰‹åŠ¨é€‰æ‹©ï¼‰ã€‚</p>
                </div>

                <div class="grid grid-cols-4 gap-3">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ overall</label>
                        <input id="opt-score-overall" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ skill</label>
                        <input id="opt-score-skill" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ background</label>
                        <input id="opt-score-background" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ startup_fit</label>
                        <input id="opt-score-startup-fit" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                </div>
                <div class="text-xs text-gray-500" id="opt-original-scores">
                    å½“å‰åˆ†æ•°ï¼š-
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">ä¼˜åŒ–å»ºè®®ä¸ç†ç”± *</label>
                    <textarea id="optimization-suggestion"
                              rows="4"
                              class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                              placeholder="ä¾‹å¦‚ï¼šè¿™ä¸ªå€™é€‰äººçš„ overall è¢«æ‰“ä½/æ‰“é«˜äº†ï¼ŒåŸå› æ˜¯...ï¼›å¸Œæœ›å²—ä½è¯„åˆ†æ ‡å‡†æ˜ç¡®...ï¼›å“ªäº›ä¿¡æ¯ä¸åº”è¯¥åœ¨çº¿ä¸Šè¿½é—®..."></textarea>
                    <p class="text-xs text-gray-500 mt-1">è¿™æ®µä¼šç”¨äºè®© AI é‡å†™å²—ä½è‚–åƒï¼ˆä¸ç›´æ¥å‘ç»™å€™é€‰äººï¼‰ã€‚</p>
                </div>
            </div>
            <div class="flex justify-end gap-2 px-5 py-4 border-t bg-gray-50">
                <button onclick="closeOptimizationFeedbackModal()"
                        class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">
                    å–æ¶ˆ
                </button>
                <button onclick="submitOptimizationFeedback()"
                        class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                    ä¿å­˜åˆ°ä¼˜åŒ–æ¸…å•
                </button>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- 3. Generated Message Section (shown only in interactive/write mode) -->
    {% if view_mode != 'readonly' %}
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
            <div class="flex-1"></div>
            <button onclick="generateMessage()"
                    class="px-3 py-1 text-xs bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°ç”Ÿæˆæ¶ˆæ¯</span>
            </button>
        </div>
        <div id="message-content" class="p-2">
            {% set chat_history_for_message = metadata.history if metadata and metadata.history else [] %}
            {% set ns = namespace(message='', action='', reason='', payload=None, placeholder='') %}
            {% for msg in chat_history_for_message | reverse %}
                {% if ns.payload is none and msg.role == 'assistant' %}
                    {% set candidate_payload = msg.payload if msg.payload is defined and msg.payload else (msg.content if msg.content is mapping else None) %}
                    {% set ns.payload = candidate_payload %}
                    {% if candidate_payload %}
                        {% set ns.action = candidate_payload.action if candidate_payload.action else (msg.action if msg.action is defined else '') %}
                        {% set ns.reason = candidate_payload.reason if candidate_payload.reason else (msg.reason if msg.reason is defined else '') %}
                        {% set ns.message = candidate_payload.message if candidate_payload.message else (msg.content or msg.message or '') %}
                    {% else %}
                        {% set ns.message = msg.content or msg.message or '' %}
                    {% endif %}
                {% endif %}
            {% endfor %}
            {% if generated_message not in ['', 'None', 'null', None] %}
                {% set ns.message = generated_message %}
            {% elif not ns.message %}
                {# Only show as textarea placeholder; never prefill as message to avoid accidental sending. #}
                {% set ns.placeholder = 'â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...' %}
            {% endif %}
            {% set message = ns.message %}
            {% set action = ns.action %}
            {% set reason = ns.reason %}
            {% set payload = ns.payload %}
            {% set placeholder_message = ns.placeholder %}
            {% include 'partials/message_result.html' with context %}
        </div>
        <div class="flex p-2 gap-2">
            <button onclick="greetAndSendMessage()"
                    class="px-4 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-800">
                ğŸ“¤ æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
            </button>
            <button hx-post="/candidates/pass"
                    hx-vals='{{ candidate | tojson | safe }}'
                    hx-target="body"
                    hx-swap="none"
                    class="px-4 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-800">
                âŒ PASS
            </button>
        </div>
    </div>
    {% endif %}

    <!-- 4. Chat History Section (shown only in readonly mode) -->
    {% if view_mode == 'readonly' %}
    {% set chat_history = metadata.history if metadata and metadata.history else [] %}
    {% if chat_history %}
    <div id="chat-history-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">ğŸ’¬ èŠå¤©å†å²</h3>
        </div>
        <div class="p-2 space-y-2 max-h-48 overflow-y-auto">
            {% for msg in chat_history %}
            {% set is_candidate = msg.role == 'user' %}
            {% set is_developer = msg.role == 'developer' %}
            {% if is_developer %}
                <!-- Developer message: centered gray box -->
                <div class="flex justify-center">
                    <div class="bg-gray-200 rounded-lg p-2 max-w-[80%]">
                        <p class="text-gray-600 whitespace-pre-wrap text-xs text-center">{{ msg.content or msg.message or '' }}</p>
                    </div>
                </div>
            {% else %}
                {% set bg_color = 'bg-blue-50' if is_candidate else 'bg-gray-50' %}
                {% set icon = 'ğŸ‘¼' if is_candidate else 'ğŸ‘¨â€ğŸ’»â€' %}
                {% set align_class = 'justify-start' if is_candidate else 'justify-end' %}
                {% set text_align = 'text-left' if is_candidate else 'text-right' %}
                {% set payload = msg.payload if msg.payload is defined and msg.payload else (msg.content if msg.content is mapping else None) %}
                {% set display_text = payload.message if payload and payload.message else (msg.content or msg.message or '') %}
                <div class="flex {{ align_class }}">
                    <div class="{{ bg_color }} rounded-lg p-3 max-w-[80%]">
                        <div class="flex items-start space-x-2 {{ 'flex-row-reverse' if not is_candidate else '' }}">
                            <span class="text-lg">{{ icon }}</span>
                            <div class="flex-1 {{ text_align }}">
                                <div class="flex {{ 'justify-between' if is_candidate else 'justify-end' }} items-start mb-1">
                                    {% if is_candidate %}
                                        <span class="font-medium text-gray-900 text-xs">
                                            {{ candidate.name or 'å€™é€‰äºº' }}
                                        </span>
                                        {% if msg.timestamp %}
                                        <span class="text-xs text-gray-500 ml-2">{{ msg.timestamp }}</span>
                                        {% endif %}
                                    {% else %}
                                        {% if msg.timestamp %}
                                        <span class="text-xs text-gray-500">{{ msg.timestamp }}</span>
                                        {% endif %}
                                        <span class="font-medium text-gray-900 text-xs ml-2">
                                            æ‹›è˜é¡¾é—®
                                        </span>
                                    {% endif %}
                                </div>
                                {% if payload and payload.action %}
                                <div class="mb-1">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-medium bg-indigo-100 text-indigo-700">
                                        {{ payload.action }}
                                    </span>
                                </div>
                                {% endif %}
                                <p class="text-gray-700 whitespace-pre-wrap text-sm">{{ display_text }}</p>
                                {% if payload and payload.reason %}
                                <p class="text-gray-500 whitespace-pre-wrap text-xs mt-2">{{ payload.reason }}</p>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
            {% endif %}
            {% endfor %}
        </div>
    </div>
    {% endif %}
    {% endif %}

    {% if candidate.updated_at %}
    {% set display_time = candidate.updated_at.replace('T', ' ')[:19] %}
    <p class="text-sm text-gray-500 mt-1">æ›´æ–°æ—¶é—´: {{ display_time }}</p>
    {% endif %}
</div>

<!-- Centralized Candidate Analysis & Workflow Logic -->
<script>
// Initialize root and view mode (runs on each HTMX swap)
// Use var to allow redeclaration when HTMX swaps content multiple times
var root = document.getElementById('candidate-detail-root');
var viewMode = root?.dataset?.viewMode || 'interactive';
// Persist on window for other scripts
window.__candidate_detail_root = window.__candidate_detail_root || root;
window.__candidate_detail_view_mode = window.__candidate_detail_view_mode || viewMode;

// ----------------------------------------------------------------------------
// Minimal fallbacks for standalone Vercel pages (no app.js loaded)
// ----------------------------------------------------------------------------
if (typeof window.handleApiResponse !== 'function') {
    window.handleApiResponse = async function (response) {
        let payload = null;
        try {
            payload = await response.json();
        } catch (e) {
            payload = null;
        }
        if (!response.ok) {
            const msg = payload?.error || payload?.message || response.statusText || `HTTP ${response.status}`;
            throw new Error(msg);
        }
        // Match existing callers that expect the inner "data" sometimes.
        return payload?.data ?? payload;
    };
}

if (typeof window.showToast !== 'function') {
    window.showToast = function (message, type = 'info') {
        try {
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                container.className = 'fixed top-4 right-4 z-50 flex flex-col gap-2';
                document.body.appendChild(container);
            }
            const el = document.createElement('div');
            const color =
                type === 'error' ? 'bg-red-600' :
                type === 'success' ? 'bg-green-600' :
                type === 'warning' ? 'bg-amber-600' :
                'bg-gray-800';
            el.className = `${color} text-white text-sm px-3 py-2 rounded shadow max-w-sm`;
            el.textContent = String(message || '');
            container.appendChild(el);
            setTimeout(() => el.remove(), 3500);
        } catch (e) {
            console.log('[toast]', type, message);
        }
    };
}

// Ensure `showToast(...)` works even if only `window.showToast` exists.
if (typeof showToast !== 'function') {
    var showToast = window.showToast;
}

async function process_candidate() {
    let newStage, currentScore, analysis;
    
    try {
        // Step 0: short-circuit if already PASS
        if (getCandidateData('stage') === 'PASS') {
            return;
        }

        // Step 1: Ensure resume is loaded
        const onlineResume = document.getElementById('resume-textarea-online');
        if (!onlineResume?.value || onlineResume.value.includes('â³') || onlineResume.value.length < 100) {
            await fetchOnlineResume();
        }

        // Step 2: Initialize chat if no conversation_id
        if (!getCandidateData('conversation_id')) {
            await initializeNewChat();
        }

        // Step 3: Start analysis if not rendered or pending
        const analysisDiv = document.getElementById('analysis-content');
        const hasAnalysis = !!document.querySelector('#analysis-content #analysis-result-container');
        if (!hasAnalysis || analysisDiv?.textContent?.includes('â³')) {
            await startAnalysis();
        }

        // Step 4: Determine stage (PASS/CHAT/SEEK by score thresholds)
        [newStage, currentScore, analysis] = determineStage();
        let isFullAnalysis = analysis?.resume_type === 'full';
        let needReply = await shouldReply();
        const mode = getCandidateData('mode');

        const finish = async (updates = {}) => {
            await updateCandidateData({ viewed: true, score: currentScore, stage: newStage, ...updates });
        };

        const handleChatAction = async (gen) => {
            const action = gen?.action || '';
            if (action === 'PASS') {
                newStage = 'PASS';
                await finish({ stage: 'PASS' });
                return true;
            }
            if (action === 'WAIT') {
                await finish({});
                return true;
            }
            if (action === 'CONTACT') {
                newStage = 'CONTACT';
                if (!getCandidateData('notified')) {
                    await sendDingNotification(analysis, getCandidateData('name'), getCandidateData('job_applied'));
                }
                await greetAndSendMessage();
                if (mode !== 'recommend') {
                    await requestContact();
                }
                await finish({ stage: 'CONTACT' });
                return true;
            }
            await greetAndSendMessage();
            return false;
        };

        // Hard stop: score-based PASS (must still emit completion event for batch runner)
        if (currentScore <= 4) {
            await passCandidate();
            newStage = 'PASS';
            await finish({ stage: 'PASS' });
            return;
        }

        // Step 4a: CHAT stage -> generate message if needed
        if (newStage === 'CHAT' && needReply) {
            const gen = await generateMessage(false);
            if (await handleChatAction(gen)) return;
            needReply = false;
        }

        // Step 4b/4c: SEEK stage -> (chat mode) fetch full resume and re-analyze; then followup generation if needed
        if (newStage === 'SEEK') {
            if (mode !== 'recommend') {
                let fullResume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                if (fullResume.includes('â³') || fullResume.length < 100) {
                    await fetchFullResume();
                    fullResume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                }
                if (!isFullAnalysis && fullResume.length > 100) {
                    await startAnalysis();
                    [newStage, currentScore, analysis] = determineStage();
                    isFullAnalysis = analysis?.resume_type === 'full';
                    if (newStage === 'SEEK') {
                        needReply = true;
                    }
                }
            }

            if (needReply && !getCandidateData('notified')) {
                await sendDingNotification(analysis, getCandidateData('name'), getCandidateData('job_applied'));
            }

            if (needReply) {
                const gen = await generateMessage(true);
                if (await handleChatAction(gen)) return;
                needReply = false;
            }
        }

        await finish({ stage: newStage, score: currentScore });
    } catch (error) {
        console.error('Error processing candidate:', error);
        showToast(`å¤„ç†å€™é€‰äººæ—¶å‡ºé”™: ${error.message || String(error)}`, 'error');
        document.dispatchEvent(new CustomEvent('candidate:processing-error', { detail: { error: error.message || String(error) } }));
    } finally {
        // Update viewed status even if processing failed (updateCandidateData filters null/undefined)
        await updateCandidateData({ viewed: true, score: currentScore, stage: newStage });
        if (!window.cycleReplyState?.running) {
            document.dispatchEvent(new CustomEvent('candidates:enable-cards'));
        }
        document.dispatchEvent(new CustomEvent('candidate:processing-complete'));
    }
}

/**
 * Send DingTalk notification when candidate score exceeds borderline threshold
 */
async function sendDingNotification(analysis, candidateName, jobApplied) {
    // Get candidate data for server-side notification
    const candidate = getCandidateData();
    const notified = candidate.notified;
    
    // Skip if already notified
    if (notified) {
        showToast('å€™é€‰äººå·²é€šçŸ¥è¿‡ï¼Œè·³è¿‡é€šçŸ¥', 'info');
        return;
    }
    
    // Send analysis data to server - server will format the message
    const response = await fetch('/candidates/notify', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            ...candidate,
            analysis: analysis 
        })
    });
    const result = await window.handleApiResponse(response);
    
    // Update candidate data with notified status if notification was successful
    if (result && result.success) {
        await updateCandidateData({ notified: true });
    }
}

async function fetchOnlineResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    const values = getCandidateData();
    await htmxAjaxPromise('POST', '/candidates/fetch-online-resume', {
        target: '#resume-online-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to online tab after fetch
    switchResumeTab('online');
}

async function fetchFullResume() {
    const values = getCandidateData();
    const mode = values.mode;
    if (mode === 'recommend') {
        return;
    }
    showToast('æŠ“å–å®Œæ•´ç®€å†...', 'info');

    await htmxAjaxPromise('POST', '/candidates/fetch-full-resume', {
        target: '#resume-full-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to full tab after fetch
    switchResumeTab('full');
}

function getMessageResultState(purpose = '') {
    const container = document.getElementById('message-result-container');
    const textarea = document.getElementById('message-text');
    const message = textarea?.value?.trim() || '';
    const action = container?.dataset?.action || '';
    const reason = container?.dataset?.reason || '';
    let payload = null;
    const payloadStr = container?.dataset?.payload;
    if (payloadStr) {
        try {
            payload = JSON.parse(payloadStr);
        } catch (e) {
            payload = null;
        }
    }
    return { action, reason, message, purpose, payload };
}

async function generateMessage(force = false) {
    const values = getCandidateData();
    const purpose = force ? 'FOLLOWUP_ACTION' : 'CHAT_ACTION';
    await htmxAjaxPromise('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        values: {...values, purpose: purpose}
    });
    const state = getMessageResultState(purpose);
    console.log('Generated message:', state);
    await updateCandidateData({generated_message: state.message});
    return state;
}

async function greetAndSendMessage() {
    const autoSend = document.getElementById('auto-send-checkbox')?.checked ?? true;
    const message_textarea = document.getElementById('message-text');
    const message = autoSend ? message_textarea.value.trim() : '';
    const action = document.getElementById('message-result-container')?.dataset?.action || '';
    let stage = getCandidateData('stage');
    const greeted = getCandidateData('greeted');
    const mode = getCandidateData('mode');
    const chat_id = getCandidateData('chat_id');
    const index = getCandidateData('index');
    if (stage === 'PASS') {
        stage = 'CHAT';
    }
    const values = {
        mode,
        chat_id,
        index,
        message,
        stage,
    };
    if (message === '') {
        // showToast('æ¶ˆæ¯é•¿åº¦ä¸èƒ½ä¸ºç©º', 'error');
        return;
    }
    // if mode is other thanrecommend and auto send is false, skip sending message
    if (mode !== 'recommend' && !autoSend) {
        return;
    }
    await htmxAjaxPromise('POST', '/candidates/send', {
        target: '#message-content',
        swap: 'none',
        values: values
    });
    
    // Show browser notification after successful message send
    const candidateName = getCandidateData('name') || 'å€™é€‰äºº';
    const notificationTitle = `å·²å‘ ${candidateName} å‘é€æ¶ˆæ¯`;
    await showBrowserNotification(notificationTitle, message);
    
    // Update to CHAT stage
    const currentStage = getCandidateData('stage');
    const nextStage = (action === 'CONTACT') ? 'CONTACT' : (currentStage || 'CHAT');
    await updateCandidateData({
        stage: nextStage,
        greeted: true
    });
}


/**
 * Start analysis (current flow)
 */
async function startAnalysis() {
    const resume_text = document.getElementById('resume-textarea-online')?.value?.trim() || '';
    const full_resume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
    const has_full_resume = !full_resume.includes('â³') && full_resume.length > 0;
    const has_online_resume = !resume_text.includes('â³') && resume_text.length > 0;
    
    if (has_full_resume) {
        showToast('æ­£åœ¨åˆ†æå®Œæ•´ç®€å†...', 'info');
    } else if(has_online_resume) {
        showToast('æ­£åœ¨åˆ†æåœ¨çº¿ç®€å†...', 'info');
    } else {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
    }
    
    const values = getCandidateData();
    values.resume_text = resume_text.includes('â³') ? '' : resume_text;
    values.full_resume = full_resume.includes('â³') ? '' : full_resume;
    
    const result = await htmxAjaxPromise('POST', '/candidates/analyze', {
        target: '#analysis-content',
        swap: 'innerHTML',
        values: values
    });
    console.log('Analysis completed:', result.overall);
    // Extract analysis from data attribute
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    await updateCandidateData({score: analysis?.overall});
    
    // Update resume type badge in tab row
    updateAnalysisResumeTypeBadge(analysis);
}

/**
 * Update the resume type badge in the analysis section tab row
 */
function updateAnalysisResumeTypeBadge(analysis) {
    const badgeContainer = document.getElementById('analysis-resume-type-badge');
    if (badgeContainer && analysis) {
        const resumeType = analysis.resume_type || 'online';
        const badgeClass = resumeType === 'full' 
            ? 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-indigo-100 text-indigo-700'
            : 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-700';
        const badgeText = resumeType === 'full' ? 'ğŸ“„ å®Œæ•´ç®€å†' : 'ğŸŒ åœ¨çº¿ç®€å†';
        badgeContainer.innerHTML = `<span class="${badgeClass}">${badgeText}</span>`;
    }
}

/**
 * Request contact information from candidate
 */
async function requestContact() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const candidate_id = values.candidate_id;
    const mode = values.mode;
    
    // Skip contact request for recommend mode (no chat_id available)
    if (mode === 'recommend' || !chat_id) {
        showToast('æ¨èæ¨¡å¼ä¸æ”¯æŒè¯·æ±‚è”ç³»æ–¹å¼', 'info');
        return;
    }
    // å¦‚æœå·²æœ‰è”ç³»æ–¹å¼ï¼Œåˆ™ä¸é‡å¤è¯·æ±‚
    if (values.metadata?.phone_number || values.metadata?.wechat_number) {
        return;
    }
    
    showToast('è¯·æ±‚è”ç³»æ–¹å¼...', 'info');
    
    // Call new endpoint with both chat_id and candidate_id
    const response = await fetch('/candidates/request-contact', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            chat_id: chat_id,
            candidate_id: candidate_id 
        })
    });
    const data = await window.handleApiResponse(response);
    console.log('Contact requested:', data);
    
    // Update candidate data with contact info in metadata
    // metadata merging is now handled in backend upsert_candidate()
    if (data && (data.phone_number || data.wechat_number)) {
        await updateCandidateData({
            stage: 'CONTACT',
            metadata: {
                phone_number: data.phone_number,
                wechat_number: data.wechat_number,
            }
        });
        
        // Update contact info display dynamically
        updateContactInfoDisplay(data.phone_number, data.wechat_number);
        
        showToast('è”ç³»æ–¹å¼å·²è·å–å¹¶ä¿å­˜', 'success');
    } else if (data && data.success !== false) {
        // Contact request succeeded but no numbers obtained yet
        await updateCandidateData({stage: 'CONTACT'});
    }
}

/**
 * Update contact information display in the DOM
 */
function updateContactInfoDisplay(phoneNumber, wechatNumber) {
    // Check if contact info section exists
    let contactSection = document.querySelector('.bg-blue-50.border.border-blue-200');
    
    if (!contactSection && (phoneNumber || wechatNumber)) {
        // Create contact info section if it doesn't exist
        const header = document.querySelector('#candidate-detail-root > div.flex.justify-between');
        if (header && header.nextElementSibling) {
            contactSection = document.createElement('div');
            contactSection.className = 'bg-blue-50 border border-blue-200 rounded-lg p-4';
            contactSection.innerHTML = `
                <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
                <div class="flex flex-wrap gap-4" id="contact-info-content"></div>
            `;
            header.parentNode.insertBefore(contactSection, header.nextElementSibling);
        }
    }
    
    if (contactSection) {
        const contentDiv = contactSection.querySelector('#contact-info-content') || contactSection.querySelector('.flex.flex-wrap');
        if (contentDiv) {
            let html = '';
            if (phoneNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="font-mono text-blue-700">${phoneNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            if (wechatNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="font-mono text-blue-700">${wechatNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            contentDiv.innerHTML = html;
        }
    }
}

/**
 * Initialize new chat - reads all data from DOM
 */
async function initializeNewChat() {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    let candidate = getCandidateData();
    //always use online resume at first time (full resume is not available at first time)
    const resume_text = document.getElementById('resume-textarea-online')?.value;
    if (!resume_text) {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
        return;
    }
    candidate.resume_text = resume_text;

    const formData = new FormData();
    for (const [key, value] of Object.entries(candidate)) {
        if (value !== null && value !== undefined) {
            formData.append(key, value);
        }
    }

    const response = await fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    });
    candidate = await window.handleApiResponse(response);
    console.log('Chat initialized:', candidate);
    await updateCandidateData(candidate);
    return candidate.candidate_id;
}


// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================
function determineStage() {
    let stage = 'PASS';
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const { chat_threshold, borderline_threshold } = getThresholdValues();
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    const {overall, skill, startup_fit, background} = analysis || {};
    if (overall <= 4) {
        stage = 'PASS';
        return [stage, overall, analysis];
    }
    if (overall >= borderline_threshold){
        stage = 'SEEK';
    } else if(overall >= chat_threshold || skill >= borderline_threshold || startup_fit >= borderline_threshold || background >= borderline_threshold){
        stage = 'CHAT';
    }
    return [stage, overall, analysis];
}


/**
 * Check if we should reply based on chat history
 * Returns true if last message is from user, false if from assistant
 */
async function shouldReply() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const mode = values.mode;
    const greeted = values.greeted;
    const autoSend = document.getElementById('auto-send-checkbox')?.checked ?? true;
    // If greeted and updated_at is less than 10 minutes ago, don't reply
    const updatedAt = new Date(values.updated_at);
    const now = new Date();
    const diffMs = now - updatedAt;
    const diffMinutes = diffMs / (1000 * 60);
    if (greeted && values.updated_at) {
        if (diffMinutes < 10) {
            return false;
        }
    }
    // For recommend mode, only rely on greeted flag
    if (mode === 'recommend') {
        return !greeted; // if not greeted, we need to reply
    }else if (mode === 'followup' && diffMinutes > 60*24*1) {
        return true; // if updated_at is more than 1 day ago, we need to reply
    }
    // for other modes, check if we should reply based on chat history
    const response = await fetch('/candidates/should-reply', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            chat_id: chat_id,
            mode: mode
        })
    });
    const data = await window.handleApiResponse(response);
    const should_reply = data.should_reply === true;
    return should_reply;
}


/**
 * Update candidate data in the form and broadcast update to card
 * This function combines both updateCandidateData and updateCandidateCard
 */
async function updateCandidateData(data) {
    const dataCopy = {...data};
    data.saved = true
    // update the resume, analysis and generated_message fields, since these fields are from server, no need to update the stored data
    if (data.resume_text) {
        document.getElementById('resume-textarea-online').value = data.resume_text;
        document.getElementById('resume-textarea-online').textContent = data.resume_text;
        delete data.resume_text;
    }
    if (data.full_resume) {
        document.getElementById('resume-textarea-full').value = data.full_resume;
        document.getElementById('resume-textarea-full').textContent = data.full_resume;
        delete data.full_resume;
    }
    if (data.analysis) {
        // use server-side rendering to render the analysis result
        await htmxAjaxPromise('POST', '/candidates/render-analysis-result', {
            swap: 'innerHTML',
            values: { analysis: JSON.stringify(data.analysis) },
            target: '#analysis-content',
        });
        delete data.analysis;
    }
    if (data.generated_message) {
        const messageTextArea = document.getElementById('message-text');
        if (messageTextArea) {
            messageTextArea.value = data.generated_message;
            messageTextArea.textContent = data.generated_message;
        }
        // delete data.generated_message; //ä¿ç•™generated_messageï¼Œç”¨äºæ›´æ–°UIï¼ŒåŒæ—¶ä¿ç•™last_messageä¸å˜
    }

	    // Get current data from hx-vals
	    const currentData = getCandidateData();
    // get the updated fields
    const updates = Object.fromEntries(
        Object.entries(dataCopy).filter(([k, v]) => v!== currentData[k] && v !== null && v !== undefined && v !== '')
    );
    // if no updates, return
    if (Object.keys(updates).length === 0) {
        return;
    }
    
    // Merge updates
    const mergedData = { ...currentData, ...data };
    
    // Update hx-vals attribute with merged data
    const container = document.getElementById('candidate-context');
    container.setAttribute('hx-vals', JSON.stringify(mergedData));
    
    // Get identifiers from the updated data for matching
    const identifiers = {
        chat_id: mergedData.chat_id,
        conversation_id: mergedData.conversation_id,
        candidate_id: mergedData.candidate_id,
        index: mergedData.index
    };
    
    // Broadcast the update event to candidate cards
    const event = new CustomEvent('candidate:update', {
        detail: {
            identifiers: identifiers,
            updates: mergedData,
        }
    });
    document.dispatchEvent(event);

    // update to cloud 
    if (Object.keys(updates).length > 0) {
        const response = await fetch('/candidates/save', {
            method: 'POST',
            body: JSON.stringify({...identifiers, ...updates}),
        });
        // await window.handleApiResponse(response);
    }
}

function getCandidateData(key) {
    const hxVals = document.getElementById('candidate-context').getAttribute('hx-vals');
    if (hxVals) {
        const data = JSON.parse(hxVals);
        // If key is provided, return that property; otherwise return the whole object
        return key !== undefined ? data[key] : data;
    }
    return key !== undefined ? null : {};
}

// ============================================================================
// Job Portrait Optimization Feedback (è¯„åˆ†ä¸å‡†)
// NOTE: Must be in global scope (button uses inline `onclick=...`).
// ============================================================================

if (typeof window.__optimization_jobs_cache === 'undefined') {
    window.__optimization_jobs_cache = null;
}
if (typeof window.__resolved_optimization_job_id === 'undefined') {
    window.__resolved_optimization_job_id = null;
}

async function openOptimizationFeedbackModal() {
    const modal = document.getElementById('optimization-feedback-modal');
    if (!modal) return;
    const display = document.getElementById('optimization-job-display');
    if (display) display.textContent = 'â³ è§£æä¸­...';
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    try {
        await ensureOptimizationJobsLoaded();
        await resolveOptimizationJobIdAndRender();
    } catch (e) {
        console.error('Failed to resolve optimization job id:', e);
        if (display) display.textContent = `âš ï¸ è§£æå²—ä½å¤±è´¥ï¼š${e?.message || e}`;
    }
    try {
        renderOptimizationOriginalScores();
        clearOptimizationTargetScores();
    } catch (e) {
        // Keep modal usable even if analysis is missing or malformed.
        console.warn('Failed to render original scores:', e);
    }
}

function closeOptimizationFeedbackModal() {
    const modal = document.getElementById('optimization-feedback-modal');
    if (!modal) return;
    modal.classList.add('hidden');
    modal.classList.remove('flex');
}

function getCurrentAnalysisForOptimization() {
    const container = document.getElementById('analysis-result-container');
    const raw = container?.dataset?.analysis;
    if (!raw) return null;
    try {
        return JSON.parse(raw);
    } catch (e) {
        return null;
    }
}

async function ensureOptimizationJobsLoaded() {
    if (window.__optimization_jobs_cache) return window.__optimization_jobs_cache;
    try {
        const resp = await fetch('/api/jobs/list');
        const data = await resp.json();
        if (!data?.success) throw new Error(data?.error || 'failed');
        window.__optimization_jobs_cache = data.data || [];
    } catch (e) {
        console.error('Failed to load jobs:', e);
        window.__optimization_jobs_cache = [];
    }
    return window.__optimization_jobs_cache;
}

function _normalizeText(s) {
    return (s || '').toString().replace(/\s+/g, '').trim().toLowerCase();
}

function _getOptScoreInputValue(id) {
    const v = document.getElementById(id)?.value;
    if (v === undefined || v === null || v === '') return null;
    const n = parseInt(v, 10);
    if (Number.isNaN(n)) return null;
    return Math.max(1, Math.min(10, n));
}

async function resolveOptimizationJobIdAndRender() {
    window.__resolved_optimization_job_id = null;
    const display = document.getElementById('optimization-job-display');
    const jobApplied = (getCandidateData('job_applied') || '').trim();

    if (!display) return null;
    if (!jobApplied) {
        display.textContent = 'âš ï¸ æ—  job_appliedï¼Œæ— æ³•åŒ¹é…å²—ä½';
        return null;
    }

    const normalizedJobApplied = _normalizeText(jobApplied);
    const jobs = (window.__optimization_jobs_cache || []);
    let matched = jobs.find(j => _normalizeText(j.position) === normalizedJobApplied);
    if (!matched) {
        // Best-effort fallback: allow contains match to handle small formatting differences.
        matched = jobs.find(j => {
            const pos = _normalizeText(j.position);
            return pos.includes(normalizedJobApplied) || normalizedJobApplied.includes(pos);
        });
    }
    if (!matched) {
        display.textContent = `âš ï¸ æœªæ‰¾åˆ°åŒ¹é…å²—ä½ï¼š${jobApplied}ï¼ˆè¯·å…ˆåœ¨â€œå²—ä½ç”»åƒâ€é¡µåˆ›å»ºåŒåå²—ä½ï¼‰`;
        return null;
    }

    const baseId = matched.base_job_id || (matched.job_id || '').replace(/_v\\d+$/, '');
    window.__resolved_optimization_job_id = baseId;
    display.textContent = `${matched.position || jobApplied} (${baseId})`;
    return baseId;
}

function renderOptimizationOriginalScores() {
    const analysis = getCurrentAnalysisForOptimization();
    const label = document.getElementById('opt-original-scores');
    if (!label) return;
    if (!analysis) {
        label.textContent = 'å½“å‰åˆ†æ•°ï¼šæš‚æ— ï¼ˆè¯·å…ˆå®Œæˆåˆ†æï¼‰';
        return;
    }
    const overall = analysis.overall ?? null;
    const skill = analysis.skill ?? null;
    const background = analysis.background ?? null;
    const startupFit = analysis.startup_fit ?? null;
    label.textContent = `å½“å‰åˆ†æ•°ï¼šoverall=${overall ?? '-'}ï¼Œskill=${skill ?? '-'}ï¼Œbackground=${background ?? '-'}ï¼Œstartup_fit=${startupFit ?? '-'}`;
}

function clearOptimizationTargetScores() {
    const ids = ['opt-score-overall', 'opt-score-skill', 'opt-score-background', 'opt-score-startup-fit'];
    for (const id of ids) {
        const el = document.getElementById(id);
        if (el) el.value = '';
    }
}

async function submitOptimizationFeedback() {
    const suggestion = document.getElementById('optimization-suggestion')?.value?.trim() || '';
    const analysis = getCurrentAnalysisForOptimization();
    const candidateId = getCandidateData('candidate_id');
    const conversationId = getCandidateData('conversation_id');
    const candidateName = getCandidateData('name') || '';
    const jobApplied = getCandidateData('job_applied') || '';

    const jobId = window.__resolved_optimization_job_id || (await resolveOptimizationJobIdAndRender());
    if (!jobId) {
        showToast('æ— æ³•åŒ¹é…å²—ä½ï¼šè¯·å…ˆåœ¨â€œå²—ä½ç”»åƒâ€é¡µåˆ›å»ºä¸ job_applied åŒåçš„å²—ä½', 'error');
        return;
    }
    if (!analysis) {
        showToast('æš‚æ— å¯ç”¨çš„åˆ†æç»“æœï¼Œè¯·å…ˆå®Œæˆåˆ†æåå†åé¦ˆ', 'error');
        return;
    }
    if (!candidateId || !conversationId) {
        showToast('å€™é€‰äººä¿¡æ¯ä¸å®Œæ•´ï¼ˆç¼ºå°‘ candidate_id / conversation_idï¼‰', 'error');
        return;
    }
    if (!suggestion || suggestion.length < 5) {
        showToast('è¯·å¡«å†™ä¼˜åŒ–å»ºè®®ä¸ç†ç”±ï¼ˆè‡³å°‘5ä¸ªå­—ï¼‰', 'error');
        return;
    }

    const targetScores = {
        overall: _getOptScoreInputValue('opt-score-overall'),
        skill: _getOptScoreInputValue('opt-score-skill'),
        background: _getOptScoreInputValue('opt-score-background'),
        startup_fit: _getOptScoreInputValue('opt-score-startup-fit'),
    };
    const hasAnyScore = Object.values(targetScores).some(v => v !== null);
    if (!hasAnyScore) {
        showToast('è¯·è‡³å°‘å¡«å†™ä¸€ä¸ªç›®æ ‡åˆ†æ•°ï¼ˆ1-10ï¼‰ï¼›æœªå¡«å†™è¡¨ç¤ºâ€œä¸å˜/ä¸éœ€è¦ä¼˜åŒ–â€', 'error');
        return;
    }

    const body = {
        job_id: jobId,
        candidate_id: candidateId,
        conversation_id: conversationId,
        candidate_name: candidateName,
        job_applied: jobApplied,
        current_analysis: analysis,
        target_scores: targetScores,
        suggestion: suggestion,
    };

    try {
        const resp = await fetch('/api/jobs/optimizations/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });
        const result = await resp.json();
        if (!result?.success) {
            showToast(result?.error || 'ä¿å­˜å¤±è´¥', 'error');
            return;
        }
        showToast('å·²åŠ å…¥ä¼˜åŒ–æ¸…å•', 'success');
        closeOptimizationFeedbackModal();
    } catch (e) {
        console.error(e);
        showToast('ä¿å­˜å¤±è´¥ï¼ˆç½‘ç»œ/æœåŠ¡å¼‚å¸¸ï¼‰', 'error');
    }
}

// Expose optimization feedback handlers for inline onclick=... (and for module/iframe contexts).
// Some bundlers/runtimes don't attach top-level declarations to `window` reliably.
window.openOptimizationFeedbackModal = openOptimizationFeedbackModal;
window.closeOptimizationFeedbackModal = closeOptimizationFeedbackModal;
window.submitOptimizationFeedback = submitOptimizationFeedback;


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 6.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0
    };
}

/**
 * Copy candidate detail link to clipboard
 */
async function copyCandidateLink() {
    const candidate = getCandidateData();
    const candidate_id = candidate?.candidate_id;
    
    if (!candidate_id) {
        showToast('æ— æ³•è·å–å€™é€‰äººID', 'error');
        return;
    }
    
    // Get Vercel URL from server config
    try {
        const response = await fetch('/candidates/get-vercel-url');
        const data = await window.handleApiResponse(response);
        const vercel_url = data?.vercel_url || '';
        
        if (!vercel_url) {
            showToast('Vercel URLæœªé…ç½®', 'error');
            return;
        }
        
        const candidate_link = `${vercel_url}/candidate/${candidate_id}`;
        
        // Copy to clipboard
        await navigator.clipboard.writeText(candidate_link);
        showToast('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
    } catch (error) {
        console.error('Failed to copy link:', error);
        showToast('å¤åˆ¶é“¾æ¥å¤±è´¥', 'error');
    }
}

// ============================================================================
// UI Helper Functions
// ============================================================================

function switchResumeTab(tab) {
    // Hide all tab contents
    document.getElementById('tab-content-online').classList.add('hidden');
    document.getElementById('tab-content-full').classList.add('hidden');
    
    // Remove active styles from all tabs
    document.getElementById('tab-online').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-online').classList.add('text-gray-600');
    document.getElementById('tab-full').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-full').classList.add('text-gray-600');
    
    // Show/hide fetch buttons based on active tab
    const fetchOnlineBtn = document.getElementById('fetch-online-resume-btn');
    const fetchFullBtn = document.getElementById('fetch-full-resume-btn');
    
    // Show selected tab content and activate tab button
    if (tab === 'online') {
        document.getElementById('tab-content-online').classList.remove('hidden');
        document.getElementById('tab-online').classList.remove('text-gray-600');
        document.getElementById('tab-online').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show online resume button, hide full resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.remove('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.add('hidden');
    } else if (tab === 'full') {
        document.getElementById('tab-content-full').classList.remove('hidden');
        document.getElementById('tab-full').classList.remove('text-gray-600');
        document.getElementById('tab-full').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show full resume button, hide online resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.add('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.remove('hidden');
    }
}

// Run initialization when partial is loaded via HTMX
// This ensures process_candidate() runs on each HTMX swap
(function () {
    // å½“åœ¨æœç´¢é¡µé¢æŸ¥çœ‹å€™é€‰äººè¯¦æƒ…æ—¶ï¼Œä½¿ç”¨ readonly æ¨¡å¼ï¼Œä¸åº”è¯¥æ‰§è¡Œ
    const viewMode = window.__candidate_detail_view_mode || 'interactive';
    if (viewMode === 'readonly') return;
    
    // Function to run process_candidate with proper error handling
    async function runProcessCandidate() {
        // Set initial tab state - show online tab if resume_text exists, otherwise show full tab
        const fullTextarea = document.getElementById('resume-textarea-full');
        switchResumeTab( fullTextarea?.value?.trim().length > 100 ? 'full' : 'online');
        await process_candidate();
    }
    
    // Use setTimes paused when the tab is not visible, but setTimeout is only throttled
    setTimeout(() => {
        runProcessCandidate();
    }, 100);
})();

</script>
