<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}BOSSæ‹›è˜åŠ©æ‰‹{% endblock %}</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="alternate icon" href="/favicon.ico">
    
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- HTMX -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    
    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/static/css/custom.css">
    
    <!-- Public URL configuration -->
    <script>
        // Initialize public URL - will be set from config on page load
        window.__public_url = window.__public_url || '';
        
        // Fetch public URL from config on page load
        (function() {
            fetch('/api/public-url')
                .then(response => response.json())
                .then(data => {
                    if (data.public_url) {
                        window.__public_url = data.public_url;
                    }
                })
                .catch(err => console.warn('Failed to load public URL:', err));
        })();
    </script>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Navigation bar -->
    <nav class="bg-white shadow-lg sticky top-0 z-50">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center py-4">
                <!-- Logo and title -->
                <div class="flex items-center space-x-4">
                    <a href="/" class="text-2xl font-bold text-blue-600">ğŸ¤– BOSSæ‹›è˜åŠ©æ‰‹</a>
                </div>
                
                <!-- Navigation links -->
                <div class="flex space-x-6">
                    <a href="/" class="text-gray-700 hover:text-blue-600 transition {% if request.url.path == '/' %}tab-active{% endif %}">
                        é¦–é¡µ
                    </a>
                    <a href="/candidates" class="text-gray-700 hover:text-blue-600 transition {% if '/candidates' in request.url.path %}tab-active{% endif %}">
                        å€™é€‰äººç®¡ç†
                    </a>
                    <a href="/search" class="text-gray-700 hover:text-blue-600 transition {% if '/search' in request.url.path %}tab-active{% endif %}">
                        æ•°æ®æŸ¥è¯¢
                    </a>
                    <a href="/automation" class="text-gray-700 hover:text-blue-600 transition {% if '/automation' in request.url.path %}tab-active{% endif %}">
                        è‡ªåŠ¨åŒ–å·¥ä½œæµ
                    </a>
                    <a href="/jobs" class="text-gray-700 hover:text-blue-600 transition {% if '/jobs' in request.url.path %}tab-active{% endif %}">
                        å²—ä½ç”»åƒ
                    </a>
                </div>
                
                <!-- Status indicator and version -->
                <div class="flex items-center space-x-4">
                    <button 
                        onclick="reopenBossZhipin()"
                        class="px-3 py-1.5 bg-blue-600 text-white text-sm rounded-lg hover:bg-blue-700 transition flex items-center space-x-2"
                        title="é‡æ–°æ‰“å¼€Bossç›´è˜çª—å£">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"/>
                        </svg>
                        <span>é‡æ–°æ‰“å¼€Bossç›´è˜</span>
                    </button>
                    <div id="service-status" class="flex items-center space-x-2">
                        <div id="status-dot" class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>
                        <span id="status-text" class="text-sm text-gray-600">æœåŠ¡è¿è¡Œä¸­</span>
                    </div>
                    <span id="version-tag" class="text-xs text-gray-500 font-mono">v-...</span>
                </div>
            </div>
        </div>
    </nav>
    
    <!-- Main content -->
    <main class="container mx-auto p-4">
        {% block content %}{% endblock %}
    </main>
    
    <!-- Footer -->
    <footer class="bg-white border-t mt-12">
        <div class="container mx-auto px-4 py-6">
            <div class="text-center text-gray-600 text-sm">
                <p>BOSSæ‹›è˜åŠ©æ‰‹ v2.4.3 | Powered by FastAPI + HTMX + Alpine.js</p>
            </div>
        </div>
    </footer>
    
    <!-- Toast notification container -->
    <div id="toast-container" class="fixed top-4 right-4 z-50 flex flex-col"></div>
    
    <!-- Global loading indicator removed (using showToast with spinner instead) -->
    
    <!-- Version Update Modal -->
    <div x-data="{ 
            get modal() { 
                const store = Alpine.store('versionUpdateModal');
                return store || { 
                    show: false, 
                    title: '', 
                    message: '', 
                    currentCommit: null, 
                    remoteCommit: null,
                    dismiss: () => {},
                    update: () => {}
                };
            }
         }" 
         x-show="modal && modal.show"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-200"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
         style="display: none;"
         @keydown.escape.window="modal && modal.dismiss()">
        <div class="bg-white rounded-lg shadow-2xl max-w-md w-full mx-4"
             x-transition:enter="transition ease-out duration-300"
             x-transition:enter-start="opacity-0 transform scale-95"
             x-transition:enter-end="opacity-100 transform scale-100"
             x-transition:leave="transition ease-in duration-200"
             x-transition:leave-start="opacity-100 transform scale-100"
             x-transition:leave-end="opacity-0 transform scale-95"
             @click.away="modal && modal.dismiss()">
            <div class="p-6">
                <div class="flex items-center mb-4">
                    <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center mr-3">
                        <span class="text-2xl">ğŸ”„</span>
                    </div>
                    <h3 class="text-xl font-bold text-gray-800" x-text="modal.title || ''"></h3>
                </div>
                <div class="mb-6">
                    <p class="text-gray-700 leading-relaxed mb-2 whitespace-pre-line" x-text="modal.message || ''"></p>
                </div>
                <div class="flex justify-end">
                    <!-- Success: Only show OK button -->
                    <template x-if="modal && modal.stage === 'success'">
                        <button @click="modal && modal.dismiss()" 
                                class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-medium">
                            ç¡®å®š
                        </button>
                    </template>
                    
                    <!-- Failure or Available: Show single dismiss button -->
                    <template x-if="modal && modal.stage !== 'success'">
                        <button @click="modal && modal.dismiss()" 
                                class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-medium">
                            å…³é—­
                        </button>
                    </template>
                </div>
            </div>
        </div>
    </div>
    
    
    <!-- Alpine.js global store -->
    <script src="/static/js/app.js"></script>
    
    <!-- Boss Zhipin Window Reopener -->
    <script>
    /**
     * Reopen the Boss Zhipin standalone window
     */
    let reopenBossZhipinInProgress = false;
    async function reopenBossZhipin() {
        // Prevent duplicate calls while request is in progress
        if (reopenBossZhipinInProgress) {
            console.log('Reopen already in progress, ignoring duplicate call');
            return;
        }
        
        reopenBossZhipinInProgress = true;
        
        try {
            const response = await fetch('/browser/reopen', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            
            const data = await response.json();
            
            if (data.success) {
                if (typeof showToast === 'function') {
                    showToast(data.message || 'å·²é‡æ–°æ‰“å¼€Bossç›´è˜çª—å£', 'success');
                } else {
                    alert(data.message || 'å·²é‡æ–°æ‰“å¼€Bossç›´è˜çª—å£');
                }
            } else {
                if (typeof showToast === 'function') {
                    showToast(data.message || 'æ‰“å¼€çª—å£å¤±è´¥', 'error');
                } else {
                    alert(data.message || 'æ‰“å¼€çª—å£å¤±è´¥');
                }
            }
        } catch (error) {
            console.error('Failed to reopen Boss Zhipin window:', error);
            if (typeof showToast === 'function') {
                showToast('æ‰“å¼€çª—å£å¤±è´¥: ' + error.message, 'error');
            } else {
                alert('æ‰“å¼€çª—å£å¤±è´¥: ' + error.message);
            }
        } finally {
            // Reset flag after a short delay to allow the operation to complete
            setTimeout(() => {
                reopenBossZhipinInProgress = false;
            }, 1000);
        }
    }
    </script>
    
    <!-- Runtime Check (Service Status + Version Update) -->
    <script>
    // ============================================================================
    // Runtime Check (Service Status + Version Update)
    // ============================================================================

    /**
     * Fetch with timeout and error handling
     */
    async function fetchWithTimeout(url, timeoutMs = 30000) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        
        const response = await fetch(url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' },
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        return response;
    }

    /**
     * Combined runtime check: service status and version updates
     * Runs every 30 seconds
     */
    function initRuntimeCheck() {
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const versionTag = document.getElementById('version-tag');
        
        let runtimeCheckInterval = null;
        let lastVersionCheck = 0;
        const VERSION_CHECK_INTERVAL = 3_600_000; // Check version every 1 hour (3600s)
        const STATUS_CHECK_INTERVAL = 300_000; // Check status every 5 minutes (300s)
        
        async function runtimeCheck() {
            // Always check service status
            if (statusDot && statusText) {
                const response = await fetchWithTimeout('/status').catch(error => {
                    // Handle fetch errors (network, timeout, etc.)
                    if (error.name === 'AbortError') {
                        statusDot.className = 'w-2 h-2 bg-yellow-500 rounded-full animate-pulse';
                        statusText.textContent = 'æœåŠ¡å“åº”è¶…æ—¶';
                        statusText.className = 'text-sm text-yellow-600';
                    } else {
                        statusDot.className = 'w-2 h-2 bg-red-500 rounded-full';
                        statusText.textContent = 'æœåŠ¡ç¦»çº¿';
                        statusText.className = 'text-sm text-red-600';
                    }
                    return null;
                });
                
                if (response?.ok) {
                    const data = await response.json();
                    // Check Zilliz connection status
                    if (data.zilliz_connected === false) {
                        // Zilliz connection failed - show error
                        statusDot.className = 'w-2 h-2 bg-red-500 rounded-full animate-pulse';
                        statusText.textContent = 'Zilliz è¿æ¥å¤±è´¥';
                        statusText.className = 'text-sm text-red-600 font-semibold';
                        
                        // Show error toast (only once per session)
                        if (!sessionStorage.getItem('zilliz_error_shown')) {
                            const errorMsg = data.zilliz_error 
                                ? `Zilliz æ•°æ®åº“è¿æ¥å¤±è´¥: ${data.zilliz_error}` 
                                : 'Zilliz æ•°æ®åº“è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®';
                            if (typeof showToast === 'function') {
                                showToast(errorMsg, 'error');
                            }
                            sessionStorage.setItem('zilliz_error_shown', 'true');
                        }
                    } else {
                        // Service is running normally
                        statusDot.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse';
                        statusText.textContent = 'æœåŠ¡è¿è¡Œä¸­';
                        statusText.className = 'text-sm text-gray-600';
                        // Clear error flag if connection is restored
                        sessionStorage.removeItem('zilliz_error_shown');
                    }
                    
                    // Update version tag - always update, even if version is null/undefined
                    if (versionTag) {
                        versionTag.textContent = data.version;
                    }
                } else if (response) {
                    // Service returned error
                    statusDot.className = 'w-2 h-2 bg-yellow-500 rounded-full animate-pulse';
                    statusText.textContent = 'æœåŠ¡å¼‚å¸¸';
                    statusText.className = 'text-sm text-yellow-600';
                }
            }
            
            // Check version update less frequently (every 5 minutes)
            const now = Date.now();
            if (now - lastVersionCheck >= VERSION_CHECK_INTERVAL) {
                lastVersionCheck = now;
                
                const response = await fetchWithTimeout('/version/check').catch(() => null);
                
                if (!response?.ok) {
                    return; // Silently fail
                }
                
                const data = await response.json();
                

                // If merge failed or update available, show modal
                if (data.has_update && data.remote_commit) {
                    // Check if this version was already dismissed
                    const dismissedVersion = localStorage.getItem('dismissedVersion');
                    if (dismissedVersion === data.remote_commit) {
                        return; // User already dismissed this version
                    }
                    
                    // Show modal
                    if (window.Alpine && Alpine.store('versionUpdateModal')) {
                        const modal = Alpine.store('versionUpdateModal');
                        modal.stage = 'initial';
                        
                        // Format commit messages
                        let commitList = '';
                        if (data.commit_messages && data.commit_messages.length > 0) {
                            commitList = '\n\næ›´æ–°å†…å®¹ï¼š\n' + data.commit_messages.map(msg => `â€¢ ${msg}`).join('\n');
                        }
                        
                        // Set title and message based on merge status
                        if (data.merge_success === true) {
                            modal.stage = 'success';
                            modal.title = 'âœ… ä»£ç å·²è‡ªåŠ¨æ›´æ–°';
                            modal.message = `æœåŠ¡å™¨å·²è‡ªåŠ¨æ›´æ–°å¹¶é‡å¯ã€‚${commitList}`;
                        } else if (data.merge_success === false) {
                            modal.title = 'âš ï¸ è‡ªåŠ¨æ›´æ–°å¤±è´¥';
                            modal.message = `æ£€æµ‹åˆ°æ–°ç‰ˆæœ¬ä½†è‡ªåŠ¨åˆå¹¶å¤±è´¥ã€‚\n\né”™è¯¯: ${data.merge_error || 'æœªçŸ¥é”™è¯¯'}\n\nè¯·æ‰‹åŠ¨è¿è¡Œ start.command æ›´æ–°ä»£ç ã€‚${commitList}`;
                        } else {
                            modal.title = 'æ–°ç‰ˆæœ¬å¯ç”¨';
                            modal.message = `æ£€æµ‹åˆ°æ–°çš„ Git ç‰ˆæœ¬å¯ç”¨ï¼Œå»ºè®®æ›´æ–°ä»¥è·å–æœ€æ–°åŠŸèƒ½ã€‚${commitList}`;
                        }
                        
                        modal.show = true;
                    }
                }
            }
        }
        
        // Check immediately on page load
        runtimeCheck();
        
        // Also update version tag immediately if element exists (in case status check hasn't run yet)
        if (versionTag) {
            fetchWithTimeout('/status')
                .then(response => response?.ok ? response.json() : null)
                .then(data => {
                    versionTag.textContent = data?.version || 'v-...';
                })
                .catch(() => {
                    // Silently fail - version will be updated on next status check
                    versionTag.textContent = 'v-...';
                });
        }
        
        // Then check every 30 seconds
        runtimeCheckInterval = setInterval(runtimeCheck, STATUS_CHECK_INTERVAL);
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (runtimeCheckInterval) {
                clearInterval(runtimeCheckInterval);
            }
        });
    }

    // Initialize runtime check when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initRuntimeCheck);
    } else {
        initRuntimeCheck();
    }
    </script>
    
    {% block scripts %}{% endblock %}
</body>
</html>

