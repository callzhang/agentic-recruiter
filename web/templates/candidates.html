{% extends "base.html" %}

{% block title %}å€™é€‰äººç®¡ç† - BOSSæ‹›è˜åŠ©æ‰‹{% endblock %}

{% block content %}

<!-- Troubleshooting Modal -->
<div x-data="{ 
        showTroubleshooting: false,
        contentKey: 'candidates-troubleshooting',
        content: 'å¦‚æœå‡ºç°é—®é¢˜ï¼Œè¯·æŒ‰ç…§ä¸‹é¢æµç¨‹æ’æŸ¥ï¼š\n1. è¯·æŸ¥çœ‹bossé¡µé¢æ˜¯å¦æ­£å¸¸\n2. åˆ·æ–°é¡µé¢\n3. æŸ¥çœ‹ç»ˆç«¯ï¼ˆterminalï¼‰çš„æç¤ºï¼Œæ˜¯å¦æœ‰é”™è¯¯\n4. å¦‚ç»ˆç«¯æœ‰é”™è¯¯ï¼Œå¤åˆ¶ç»ˆç«¯é”™è¯¯å¹¶é—®é—®cursoræˆ–è€…å°è¯•ç”¨cursorä¿®å¤\n5. å°†cursorçš„å›ç­”å‘é€åˆ°ç¾¤é‡Œè®©å·¥ç¨‹å¸ˆä¿®å¤',
        init() {
            // Use hash-based notification system
            if (typeof window.shouldShowNotification === 'function') {
                this.showTroubleshooting = window.shouldShowNotification(this.contentKey, this.content);
            }
            if (this.showTroubleshooting) {
                this.$el.style.display = 'flex';
            }
        },
        dismiss() {
            if (typeof window.acknowledgeNotification === 'function') {
                window.acknowledgeNotification(this.contentKey, this.content);
            }
            this.showTroubleshooting = false;
        }
     }" 
     x-show="showTroubleshooting"
     x-transition:enter="transition ease-out duration-300"
     x-transition:enter-start="opacity-0"
     x-transition:enter-end="opacity-100"
     x-transition:leave="transition ease-in duration-200"
     x-transition:leave-start="opacity-100"
     x-transition:leave-end="opacity-0"
     class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
     style="display: none;">
    <div class="bg-white rounded-lg shadow-2xl max-w-md w-full mx-4"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0 transform scale-95"
         x-transition:enter-end="opacity-100 transform scale-100"
         x-transition:leave="transition ease-in duration-200"
         x-transition:leave-start="opacity-100 transform scale-100"
         x-transition:leave-end="opacity-0 transform scale-95">
        <div class="p-4">
            <div class="flex items-center mb-4">
                <div class="w-10 h-10 bg-yellow-100 rounded-full flex items-center justify-center mr-3">
                    <span class="text-2xl">âš ï¸</span>
                </div>
                <h3 class="text-xl font-bold text-gray-800">é—®é¢˜æ’æŸ¥æç¤º</h3>
            </div>
            <div class="mb-6">
                <p class="text-gray-700 leading-relaxed whitespace-pre-line" x-text="content"></p>
            </div>
            <div class="flex justify-end">
                <button @click="dismiss()"
                        class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-medium">
                    å·²çŸ¥æ™“
                </button>
            </div>
        </div>
    </div>
</div>

<div x-data="candidateTabs()" x-init="init()" class="space-y-6">
    <!-- Page header with controls -->
    <div class="bg-white rounded-lg shadow p-4">
        <!-- <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800">å€™é€‰äººç®¡ç†</h1>
            <button onclick="location.reload()" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition">
                ğŸ”„ åˆ·æ–°
            </button>
        </div> -->
        
        <!-- Tab switcher with batch analyze button -->
        <div class="flex justify-between items-center border-b mb-4">
            <div class="flex space-x-2" id="tab-buttons">
            <button 
                @click="switchTab('recommend')"
                data-tab="recommend"
                :class="activeTab === 'recommend' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                â­ æ¨èç‰›äºº
            </button>
            <button 
                @click="switchTab('greet')"
                data-tab="greet"
                :class="activeTab === 'greet' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                ğŸ‘‹ æ–°æ‹›å‘¼
            </button>
            <button 
                @click="switchTab('chat')"
                data-tab="chat"
                :class="activeTab === 'chat' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                ğŸ’¬ æ²Ÿé€šä¸­
            </button>
            <button 
                @click="switchTab('followup')"
                data-tab="followup"
                :class="activeTab === 'followup' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                ğŸ“­ ç‰›äººå·²è¯»æœªå›
            </button>
            </div>
            <!-- Top-right controls: Auto-send checkbox and Process button -->
            <div class="flex items-center gap-4">
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="auto-send-checkbox" checked class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    <span class="text-sm text-gray-700 font-medium">è‡ªåŠ¨å‘é€</span>
                </label>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="process-all-modes-checkbox" class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                    <span class="text-sm text-gray-700 font-medium">å¤„ç†æ‰€æœ‰æ¨¡å¼</span>
                </label>
                <button 
                    id="cycle-reply-btn"
                    onclick="startCycleReply()"
                    title="å¤„ç†å€™é€‰äººï¼š&#10;&#10;â€¢ æœªå‹¾é€‰"å¤„ç†æ‰€æœ‰æ¨¡å¼"ï¼šåªå¤„ç†å½“å‰æ¨¡å¼çš„å€™é€‰äºº&#10;â€¢ å‹¾é€‰"å¤„ç†æ‰€æœ‰æ¨¡å¼"ï¼šè‡ªåŠ¨å¾ªç¯å¤„ç†æ‰€æœ‰4ä¸ªæ¨¡å¼ï¼ˆæ¨èç‰›äººã€æ–°æ‹›å‘¼ã€æ²Ÿé€šä¸­ã€ç‰›äººå·²è¯»æœªå›ï¼‰&#10;&#10;å¤„ç†æµç¨‹ï¼š&#10;1. åŠ è½½åœ¨çº¿ç®€å†ï¼ˆå¦‚æœªåŠ è½½ï¼‰&#10;2. åˆå§‹åŒ–å¯¹è¯ï¼ˆå¦‚æœªåˆå§‹åŒ–ï¼‰&#10;3. è¿›è¡ŒAIåˆ†æï¼ˆå¦‚æœªåˆ†æï¼‰&#10;4. æ ¹æ®åŒ¹é…åº¦é˜ˆå€¼ç”Ÿæˆæ¶ˆæ¯æˆ–å‘é€æ‹›å‘¼&#10;5. æ›´æ–°å€™é€‰äººå¡ç‰‡çŠ¶æ€&#10;&#10;æç¤ºï¼šç¡®ä¿å·²é€‰æ‹©å²—ä½å¹¶è®¾ç½®å¥½é˜ˆå€¼å‚æ•°"
                    class="px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition disabled:opacity-50 disabled:cursor-not-allowed">
                    ğŸ”„ å¼€å§‹å¤„ç†
                </button>
            </div>
        </div>
        
        <!-- Filters -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">å²—ä½</label>
                <select id="job-selector" name="job_id" class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                        hx-get="/jobs/list-simple" hx-trigger="load" hx-swap="innerHTML"
                        hx-on::after-swap="window.updateCandidateURL && window.updateCandidateURL()"
                        @change="updateURL()">
                    <option>åŠ è½½ä¸­...</option>
                </select>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    æ²Ÿé€šé˜ˆå€¼
                    <span class="text-xs text-gray-500">â‰¥ æ­¤åˆ†æ•°ç”Ÿæˆæ¶ˆæ¯</span>
                </label>
                <input type="number" id="threshold-chat" name="threshold_chat" 
                       value="6.0" 
                       min="1" max="10" step="0.5"
                       @change="updateURL()"
                       class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">
                     åŠæ ¼çº¿
                    <span class="text-xs text-gray-500">â‰¥ æ­¤åˆ†æ•°è¡¨ç¤ºå…´è¶£</span>
                </label>
                <input type="number" id="threshold-borderline" name="threshold_borderline" 
                       value="7.0" 
                       min="1" max="10" step="0.5"
                       @change="updateURL()"
                       class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    å¼ºåŒ¹é…é˜ˆå€¼
                    <span class="text-xs text-gray-500">â‰¥ æ­¤åˆ†æ•°è¦æ±‚è”ç³»æ–¹å¼</span>
                </label>
                <input type="number" id="threshold-seek" name="threshold_seek" 
                       value="8.0" 
                       min="1" max="10" step="0.5"
                       @change="updateURL()"
                       class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>
    </div>
    
    <!-- Main content area: List + Detail -->
    <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
        <!-- Candidate list (left sidebar) -->
        <div class="lg:col-span-4">
            <div class="bg-white rounded-lg shadow-lg h-[1000px] overflow-y-auto">
                <div id="candidate-list" class="p-4 space-y-2">
                    <!-- Initial message -->
                    <div id="initial-message" class="text-center text-gray-500 py-12">
                        ç‚¹å‡»ä¸‹æ–¹"æŸ¥è¯¢å€™é€‰äºº"æŒ‰é’®åŠ è½½æ•°æ®
                    </div>
                    <!-- Candidates will be appended here -->
                </div>
                
                <!-- Load more button at bottom of list -->
                <div class="p-4 border-t bg-gray-50">
                    <div class="flex gap-2 items-end">
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-1">æ•°é‡é™åˆ¶</label>
                            <input 
                                type="number" 
                                id="limit-input" 
                                name="limit" 
                                value="50" 
                                min="1" 
                                max="999" 
                                step="1"
                                @change="updateURL()"
                                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    <button 
                        @click="loadCandidates()"
                        id="load-more-btn"
                        :disabled="loading"
                        :class="loading ? 'opacity-50 cursor-not-allowed' : ''"
                            class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                        <span x-text="loading ? 'â³ åŠ è½½ä¸­...' : 'ğŸ” æŸ¥è¯¢å€™é€‰äºº'"></span>
                    </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Candidate detail (right panel) -->
        <div class="lg:col-span-8">
            <div id="detail-pane" class="bg-white rounded-lg shadow-lg p-4">
                <!-- Will be populated when candidate is selected -->
                <div class="text-center text-gray-500 py-24">
                    <div class="text-6xl mb-4">ğŸ‘¤</div>
                    <p class="text-lg">è¯·ä»å·¦ä¾§åˆ—è¡¨ä¸­é€‰æ‹©å€™é€‰äºº</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// ============================================================================
// Candidate Tabs Component
// ============================================================================

// Candidate tabs component
function candidateTabs() {
    return {
        activeTab: 'recommend',
        loading: false,
        
        init() {
            // Read URL parameters on page load
            this.restoreFromURL();
            
            // Listen for browser back/forward buttons
            window.addEventListener('popstate', () => {
                this.restoreFromURL();
            });
        },
        
        restoreFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Set active tab from URL
            const tab = urlParams.get('tab');
            if (tab && ['recommend', 'greet', 'chat', 'followup'].includes(tab)) {
                this.activeTab = tab;
            }
            
            // Set thresholds from URL
            const thresholdChat = urlParams.get('threshold_chat');
            if (thresholdChat) {
                const chatInput = document.getElementById('threshold-chat');
                if (chatInput) chatInput.value = thresholdChat;
            }
            
            const thresholdBorderline = urlParams.get('threshold_borderline');
            if (thresholdBorderline) {
                const borderlineInput = document.getElementById('threshold-borderline');
                if (borderlineInput) borderlineInput.value = thresholdBorderline;
            }
            
            const thresholdSeek = urlParams.get('threshold_seek');
            if (thresholdSeek) {
                const seekInput = document.getElementById('threshold-seek');
                if (seekInput) seekInput.value = thresholdSeek;
            }
            
            // Set job selector from URL (after jobs are loaded)
            const jobId = urlParams.get('job_id');
            if (jobId) {
                // Wait for job selector to be populated
                const checkJobSelector = setInterval(() => {
                    const jobSelector = document.getElementById('job-selector');
                    if (jobSelector && jobSelector.options.length > 1) {
                        // Check if the job_id exists in options
                        for (let option of jobSelector.options) {
                            if (option.value === jobId) {
                                jobSelector.value = jobId;
                                clearInterval(checkJobSelector);
                                break;
                            }
                        }
                        clearInterval(checkJobSelector);
                    }
                }, 100);
                
                // Stop checking after 5 seconds
                setTimeout(() => clearInterval(checkJobSelector), 5000);
            }
            
            // Set limit from URL
            const limit = urlParams.get('limit');
            if (limit) {
                const limitInput = document.getElementById('limit-input');
                if (limitInput) limitInput.value = limit;
            }
        },
        
        updateURL() {
            const params = new URLSearchParams();
            
            // Add tab
            params.set('tab', this.activeTab);
            
            // Add thresholds
            const thresholdChat = document.getElementById('threshold-chat')?.value;
            if (thresholdChat) params.set('threshold_chat', thresholdChat);
            
            const thresholdBorderline = document.getElementById('threshold-borderline')?.value;
            if (thresholdBorderline) params.set('threshold_borderline', thresholdBorderline);
            
            const thresholdSeek = document.getElementById('threshold-seek')?.value;
            if (thresholdSeek) params.set('threshold_seek', thresholdSeek);
            
            // Add job_id
            const jobSelector = document.getElementById('job-selector');
            const jobId = jobSelector?.value;
            if (jobId && jobId !== 'åŠ è½½ä¸­...') {
                params.set('job_id', jobId);
            }
            
            // Add limit
            const limitInput = document.getElementById('limit-input');
            const limit = limitInput?.value;
            if (limit) {
                params.set('limit', limit);
            }
            
            // Update URL without page reload
            const newURL = window.location.pathname + (params.toString() ? '?' + params.toString() : '');
            window.history.pushState({}, '', newURL);
        },
        
        switchTab(tab) {
            // If the tab is already active, keep the list and do nothing
            if (this.activeTab === tab) {
                console.log(`[switchTab] Tab ${tab} is already active, keeping list`);
                return;
            }
            
            this.activeTab = tab;
            // Reset selected candidate
            // Clear list when switching tabs
            const list = document.getElementById('candidate-list');
            if (list) {
                list.innerHTML = '';
                // Re-add initial message
                const initialMsg = document.createElement('div');
                initialMsg.id = 'initial-message';
                initialMsg.className = 'text-center text-gray-500 py-12';
                initialMsg.textContent = 'ç‚¹å‡»ä¸‹æ–¹"æŸ¥è¯¢å€™é€‰äºº"æŒ‰é’®åŠ è½½æ•°æ®';
                list.appendChild(initialMsg);
            }
            // Batch analyze button has been removed - no longer needed
            // Update URL
            this.updateURL();
            // Automatically reload candidates when switching tabs
            // this.loadCandidates();
        },
        
        loadCandidates() {
            
            this.loading = true;
            
            const jobSelector = document.getElementById('job-selector');
            const job_id = jobSelector?.value || jobSelector?.options[0]?.value;
            const job_title = jobSelector?.selectedOptions[0]?.getAttribute("data-title");
            
            // Check if job title is valid
            if (!job_title || job_title === 'åŠ è½½ä¸­...') {
                console.error('Job title not loaded yet');
                this.loading = false;
                showToast('è¯·ç­‰å¾…å²—ä½åˆ—è¡¨åŠ è½½å®Œæˆåå†æŸ¥è¯¢', 'warning');
                return;
            }
            
            let mode, chat_type;
            if (this.activeTab === 'recommend') {
                mode = 'recommend';
                chat_type = '';
            } else {
                mode = this.activeTab; // Use the tab name directly as mode
                const tabMap = {
                    'greet': 'æ–°æ‹›å‘¼',
                    'chat': 'æ²Ÿé€šä¸­',
                    'followup': 'ç‰›äººå·²è¯»æœªå›'
                };
                chat_type = tabMap[this.activeTab] || 'æ–°æ‹›å‘¼';
            }
            
            // Get limit from input
            const limitInput = document.getElementById('limit-input');
            const limit = limitInput?.value || '50';

            const params = new URLSearchParams({
                mode: mode,
                chat_type: chat_type,
                job_applied: job_title,
                job_id: job_id,
                limit: limit
            });
            
            console.log('Loading candidates, activeTab:', this.activeTab, 'params:', params);
            const url = `/candidates/list?${params.toString()}`;
            console.log('Fetching:', url);
            
            const candidateList = document.getElementById('candidate-list');
            
            // Clear all non-candidate content (error messages, initial messages, empty messages)
            // Keep only candidate cards if we're appending
            const initialMsg = document.getElementById('initial-message');
            if (initialMsg) {
                initialMsg.remove();
            }
            const emptyMsg = document.getElementById('empty-message');
            if (emptyMsg) {
                emptyMsg.remove();
            }
            
            // Remove any error messages (divs with text-red-500 or containing error indicators)
            const errorMessages = candidateList.querySelectorAll('.text-red-500, [class*="error"], [class*="å¤±è´¥"]');
            errorMessages.forEach(msg => {
                // Only remove if it's not a candidate card
                if (!msg.closest('.candidate-card')) {
                    msg.remove();
                }
            });
            
            // Use a custom handler to detect errors and handle swap accordingly
            fetch(url)
                .then(async (response) => {
                    const html = await response.text();
                    const candidateList = document.getElementById('candidate-list');
                    
                    // Check if response is an error message
                    if (!response.ok) {
                        // Error: replace list content with error message
                        candidateList.innerHTML = html;
                        this.loading = false;
                        showToast('è·å–å€™é€‰äººåˆ—è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                        return;
                    }
                    
                    // Success: replace the entire list with new candidate cards
                    // Use the HTML response directly
                    candidateList.innerHTML = html;
                    
                    // Tell HTMX to process the new content
                    htmx.process(candidateList);
                    
                    const loadedCount = candidateList.querySelectorAll('.candidate-card').length;
                    console.log(`Loaded ${loadedCount} candidate cards`);
                    
                    this.loading = false;
                    
                    // Count how many candidates are in the list now - use a fresh query after all updates
                    // Use requestAnimationFrame to ensure DOM is updated before counting
                    const self = this;
                    requestAnimationFrame(() => {
                        const count = candidateList.querySelectorAll('.candidate-card').length;
                        // Batch analyze button has been removed - no longer needed
                        
                        if (count === 0) {
                            // Show empty state message
                            const emptyMsg = document.createElement('div');
                            emptyMsg.id = 'empty-message';
                            emptyMsg.className = 'text-center text-gray-500 py-12';
                            emptyMsg.innerHTML = `
                                <div class="space-y-2">
                                    <p class="text-lg">ğŸ˜” æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å€™é€‰äºº</p>
                                    <p class="text-sm">è¯·å°è¯•åˆ‡æ¢æ ‡ç­¾æˆ–å²—ä½</p>
                                </div>
                            `;
                            candidateList.appendChild(emptyMsg);
                            showToast('æœªæ‰¾åˆ°å€™é€‰äºº', 'warning');
                        } else {
                            // Remove empty message if it exists
                            const emptyMsg = document.getElementById('empty-message');
                            if (emptyMsg) {
                                emptyMsg.remove();
                            }
                            
                            // Show toast with count
                            showToast(`åŠ è½½å®Œæˆï¼Œå…± ${count} ä¸ªå€™é€‰äºº`, 'success');
                        }
                    });
                })
                .catch((err) => {
                    console.error('Failed:', err);
                    this.loading = false;
                    const candidateList = document.getElementById('candidate-list');
                    candidateList.innerHTML = `
                        <div class="text-center text-red-500 py-12">
                            <p class="text-lg">âŒ è¯·æ±‚å¤±è´¥</p>
                            <p class="text-sm mt-2">${err.message}</p>
                        </div>
                    `;
                    showToast('åŠ è½½å¤±è´¥: ' + err.message, 'error');
                });
        }
    };
}

// Global function for HTMX events to call updateURL
window.updateCandidateURL = function() {
    // First, restore job selector value from URL if it exists
    const urlParams = new URLSearchParams(window.location.search);
    const jobId = urlParams.get('job_id');
    if (jobId) {
        const jobSelector = document.getElementById('job-selector');
        if (jobSelector && jobSelector.options.length > 1) {
            // Check if the job_id exists in options
            for (let option of jobSelector.options) {
                if (option.value === jobId) {
                    jobSelector.value = jobId;
                    break;
                }
            }
        }
    }
    
    // Find the Alpine component instance
    const candidateTabsElement = document.querySelector('[x-data*="candidateTabs"]');
    if (candidateTabsElement && candidateTabsElement._x_dataStack) {
        const component = candidateTabsElement._x_dataStack[0];
        if (component && component.updateURL) {
            component.updateURL();
        }
    }
};

// ============================================================================
// Candidate Selection Management
// ============================================================================

// Visual state management for candidate cards
document.body.addEventListener('htmx:beforeRequest', function(event) {
    // Check if this is a candidate card click
    const elt = event.detail.elt;
    // Check if elt itself is a candidate-card, or if it's inside one
    const card = elt.classList?.contains('candidate-card') ? elt : elt.closest('.candidate-card');
    if (!card) {
        return;  // Not a candidate card, allow request normally
    }
    
    // Remove selected state from all cards
    document.querySelectorAll('.candidate-card').forEach(c => {
        c.classList.remove('bg-blue-50', 'border-blue-500', 'ring-2', 'ring-blue-300');
        c.classList.add('border-gray-200');
    });
    
    // Add selected state to clicked card
    card.classList.remove('border-gray-200');
    card.classList.add('bg-blue-50', 'border-blue-500', 'ring-2', 'ring-blue-300');
    
    // Scroll card into view in the left panel
    card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
});

// ============================================================================
// Helper functions to disable/enable candidate cards
// ============================================================================

function disableAllCards() {
    const cards = document.querySelectorAll('.candidate-card');
    cards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.6';
    });
}

function enableAllCards() {
    const cards = document.querySelectorAll('.candidate-card');
    cards.forEach(card => {
        card.style.pointerEvents = '';
        card.style.opacity = '';
    });
}
// å°†å‡½æ•°æš´éœ²åˆ° window å¯¹è±¡
window.disableAllCards = disableAllCards;
window.enableAllCards = enableAllCards;

// ============================================================================
// Batch Processing Functions
// ============================================================================

// Global flags for batch processing control
window.batchProcessingActive = false;
window.stopBatchProcessing = false;

/**
 * Check if currently on the candidate page
 */
function isOnCandidatePage() {
    return window.location.pathname.includes('/candidates') || 
           window.location.pathname === '/candidates';
}

/**
 * Check if batch processing should be cancelled
 * Returns true if we should stop processing
 * Only checks page navigation, not tab visibility
 */
function shouldCancelBatchProcessing() {
    // Check if not on candidate page
    if (!isOnCandidatePage()) {
        return true;
    }
    
    // Don't cancel based on tab visibility - allow switching tabs
    return false;
}

/**
 * Process all candidate cards sequentially
 */
window.processAllCandidates = async function processAllCandidates() {
    const cards = document.querySelectorAll('.candidate-card');
    if (cards.length === 0) {
        showToast('æ²¡æœ‰æ‰¾åˆ°å€™é€‰äºº', 'warning');
        return;
    }
    
    // Find the currently selected card (has blue selection classes)
    // If found, start from next; otherwise start from beginning
    let startIndex = 0;
    const selectedCard = Array.from(cards).find(card => 
        card.classList.contains('bg-blue-50') || 
        card.classList.contains('border-blue-500')
    );
    if (selectedCard) {
        const selectedIndex = Array.from(cards).indexOf(selectedCard);
        startIndex = selectedIndex + 1; // Start from next card
        if (startIndex >= cards.length) {
            showToast('å½“å‰å·²æ˜¯æœ€åä¸€ä¸ªå€™é€‰äººï¼Œå°†ä»ç¬¬ä¸€ä¸ªå¼€å§‹', 'info');
            startIndex = 0;
        }
    }
    
    const total = cards.length;
    const remaining = total - startIndex;
    let processed = 0;
    let failed = 0;
    let skipped = 0; // Count skipped candidates (viewed)
    
    // Set batch processing flag
    window.batchProcessingActive = true;
    window.stopBatchProcessing = false;
    
    // Disable all candidate cards
    disableAllCards();
    
    // Update cycle reply button to show stop state
    let cycleReplyBtn = document.getElementById('cycle-reply-btn');
    if (cycleReplyBtn) {
        cycleReplyBtn.textContent = 'â¸ åœæ­¢å¤„ç†';
    }
    
    if (startIndex > 0) {
        showToast(`å¼€å§‹æ‰¹é‡å¤„ç† ${remaining} ä¸ªå€™é€‰äºº (ä»ç¬¬ ${startIndex + 1} ä¸ªå¼€å§‹)`, 'info');
    } else {
        showToast(`å¼€å§‹æ‰¹é‡å¤„ç† ${total} ä¸ªå€™é€‰äºº`, 'info');
    }
    
    for (let i = startIndex; i < cards.length; i++) {
        // Check if user requested stop
        if (window.stopBatchProcessing) {
            showToast(`æ‰¹é‡å¤„ç†å·²åœæ­¢ (${processed}/${total} å®Œæˆ)`, 'warning');
            break;
        }
        
        // Check if we should cancel due to page/tab change
        if (shouldCancelBatchProcessing()) {
            // Only show toast if it's a page navigation, not tab visibility change
            if (!isOnCandidatePage()) {
                showToast(`æ‰¹é‡å¤„ç†å·²å–æ¶ˆ (å·²ç¦»å¼€å€™é€‰äººé¡µé¢)`, 'warning');
            }
            window.stopBatchProcessing = true;
            break;
        }
        
        const card = cards[i];
        const cardData = JSON.parse(card.getAttribute('hx-vals'));
        const candidate = cardData.candidate || {};
        const name = candidate.name || cardData.name || `å€™é€‰äºº ${i + 1}`;
        const currentPosition = i + 1;
        
        // Skip if candidate is already viewed
        if (candidate.viewed === true || candidate.viewed === 'true') {
            skipped++;
            console.log(`[æ‰¹é‡å¤„ç†] è·³è¿‡å·²æŸ¥çœ‹çš„å€™é€‰äºº: ${name} (${skipped} å·²è·³è¿‡)`);
            continue;
        }
        
        showToast(`æ­£åœ¨å¤„ç†å€™é€‰äºº ${currentPosition}/${total}: ${name}`, 'info');
        
        try {
            // Get detailPane reference - check if it exists and is stable
            let detailPane = document.getElementById('detail-pane');
            if (!detailPane) {
                throw new Error('Detail pane not found');
            }
            
            // Set up event listeners BEFORE triggering HTMX click
            // This ensures we catch the event even if process_candidate() completes quickly
            const processingPromise = new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    reject(new Error('Processing timeout (180s)'));
                }, 180000); // 180s timeout to avoid hanging batch loops
                
                const onComplete = (event) => {
                    clearTimeout(timeout);
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    resolve(event.detail);
                };
                
                const onError = (event) => {
                    clearTimeout(timeout);
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    // Stop batch processing on processing error
                    window.stopBatchProcessing = true;
                    reject(new Error(event.detail.error || 'Processing failed'));
                };
                
                document.addEventListener('candidate:processing-complete', onComplete, { once: true });
                document.addEventListener('candidate:processing-error', onError, { once: true });
            });
            
            // Wait for HTMX swap to complete
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error('HTMX swap timeout'));
                }, 1000); // 1 second timeout for swap
                
                const cleanup = () => {
                    clearTimeout(timeout);
                    detailPane.removeEventListener('htmx:afterSwap', onSwap);
                    detailPane.removeEventListener('htmx:responseError', onResponseError);
                    detailPane.removeEventListener('htmx:sendError', onSendError);
                    detailPane.removeEventListener('htmx:swapError', onSwapError);
                };
                
                const onSwap = () => {
                    cleanup();
                    // Wait a bit for DOM to be ready
                    setTimeout(resolve, 200);
                };
                
                const onResponseError = (evt) => {
                    cleanup();
                    // Stop event propagation to prevent global handler from catching it
                    evt.stopPropagation();
                    const errorMsg = evt.detail?.error || evt.detail?.message || 'HTMX request failed';
                    reject(new Error(errorMsg));
                };
                
                const onSendError = (evt) => {
                    cleanup();
                    // Stop event propagation to prevent global handler from catching it
                    evt.stopPropagation();
                    const errorMsg = evt.detail?.error || evt.detail?.message || evt.detail?.failed || 'HTMX send failed';
                    reject(new Error(errorMsg));
                };
                
                const onSwapError = (evt) => {
                    cleanup();
                    // Stop event propagation to prevent global handler from catching it
                    evt.stopPropagation();
                    const errorMsg = evt.detail?.error || evt.detail?.message || 'HTMX swap failed';
                    reject(new Error(errorMsg));
                };
                
                detailPane.addEventListener('htmx:afterSwap', onSwap, { once: true });
                detailPane.addEventListener('htmx:responseError', onResponseError, { once: true });
                detailPane.addEventListener('htmx:sendError', onSendError, { once: true });
                detailPane.addEventListener('htmx:swapError', onSwapError, { once: true });
                
                // Scroll card into view before triggering click
                card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                
                // Trigger HTMX click (htmx:beforeRequest will handle highlighting)
                htmx.trigger(card, 'click');
            });
            
            // Wait for process_candidate() to complete
            await processingPromise;
            
            // Check again after processing completes
            if (shouldCancelBatchProcessing()) {
                // Only show toast if it's a page navigation, not tab visibility change
                if (!isOnCandidatePage()) {
                    showToast(`æ‰¹é‡å¤„ç†å·²å–æ¶ˆ (å·²ç¦»å¼€å€™é€‰äººé¡µé¢)`, 'warning');
                }
                window.stopBatchProcessing = true;
                break;
            }
            
            processed++;
            // Update last processed time for cycle reply idle timeout
            if (window.cycleReplyState) {
                window.cycleReplyState.lastProcessedTime = Date.now();
            }
            showToast(`âœ… ${name} å¤„ç†å®Œæˆ (${processed}/${total})`, 'success');
        } catch (error) {
            failed++;
            const errorMessage = error?.message || error?.toString() || 'æœªçŸ¥é”™è¯¯';
            console.error(`Failed to process candidate ${i + 1}:`, error);
            
            // Check if it's a connection/network error (transient error)
            const isConnectionError = errorMessage.includes('ERR_CONNECTION_REFUSED') ||
                                     errorMessage.includes('Connection refused') ||
                                     errorMessage.includes('HTMX') ||
                                     errorMessage.includes('network') ||
                                     errorMessage.includes('NetworkError') ||
                                     errorMessage.includes('Failed to fetch');
            
            if (isConnectionError) {
                showToast(`âš ï¸ ${name} è¿æ¥å¤±è´¥ï¼Œè·³è¿‡: ${errorMessage}`, 'warning');
            } else {
                showToast(`âŒ ${name} å¤„ç†å¤±è´¥: ${errorMessage}`, 'error');
            }
            
            // Stop batch processing only if explicitly requested, otherwise continue
            if (window.stopBatchProcessing) {
                showToast(`æ‰¹é‡å¤„ç†å·²åœæ­¢ (${processed}/${total} å®Œæˆ, ${failed} å¤±è´¥)`, 'warning');
                break;
            }
            // Otherwise continue to next candidate
        }
    }
    
    // Re-enable candidate cards
    enableAllCards();
    
    // Reset batch processing flag
    window.batchProcessingActive = false;
    window.stopBatchProcessing = false;
    
    // Reset cycle reply button
    cycleReplyBtn = document.getElementById('cycle-reply-btn');
    if (cycleReplyBtn) {
        cycleReplyBtn.textContent = 'ğŸ”„ å¼€å§‹å¤„ç†';
    }
    
    // Final summary
    const summary = `æ‰¹é‡å¤„ç†å®Œæˆ: æˆåŠŸ ${processed}/${total}, å¤±è´¥ ${failed}${skipped > 0 ? `, è·³è¿‡ ${skipped}` : ''}`;
    showToast(summary, processed === total ? 'success' : 'warning');
}

function stopBatchProcessingHandler() {
    window.stopBatchProcessing = true;
    const cycleBtn = document.getElementById('cycle-reply-btn');
    if (cycleBtn) {
        cycleBtn.textContent = 'â¹ï¸ æ­£åœ¨åœæ­¢...';
    }
    showToast('æ­£åœ¨åœæ­¢æ‰¹é‡å¤„ç†...', 'info');
}

// ============================================================================
// Batch Processing Cancellation Listeners
// ============================================================================

// Don't cancel batch processing when tab becomes hidden - allow switching tabs
// Batch processing will continue in the background

// Cancel batch processing when navigating away from candidate page
// Check after HTMX swaps complete
document.body.addEventListener('htmx:afterSwap', () => {
    if (window.batchProcessingActive && !isOnCandidatePage()) {
        window.stopBatchProcessing = true;
        showToast('æ‰¹é‡å¤„ç†å·²å–æ¶ˆ (å·²ç¦»å¼€å€™é€‰äººé¡µé¢)', 'warning');
    }
});

// Cancel batch processing on browser navigation (back/forward)
window.addEventListener('popstate', () => {
    if (window.batchProcessingActive && !isOnCandidatePage()) {
        window.stopBatchProcessing = true;
        showToast('æ‰¹é‡å¤„ç†å·²å–æ¶ˆ (å·²ç¦»å¼€å€™é€‰äººé¡µé¢)', 'warning');
    }
});

// Cancel batch processing on page unload
window.addEventListener('beforeunload', () => {
    if (window.batchProcessingActive) {
        window.stopBatchProcessing = true;
    }
});

// ============================================================================
// Candidate Card Update Functions
// ============================================================================

/**
 * Update a candidate card with the given updates
 */
function applyCardUpdate(card, updates, identifiers) {
    // Parse hx-vals which has structure: {"candidate": {...}}
    const hxValsData = JSON.parse(card.getAttribute('hx-vals') || '{"candidate": {}}');
    const cardData = hxValsData.candidate || {};
    
    // Update the card's candidate data
    Object.assign(cardData, updates);
    Object.assign(cardData, identifiers);
    
    // Apply updates - maintain the {"candidate": {...}} structure
    card.setAttribute('hx-vals', JSON.stringify({ candidate: cardData }));
    
    // Update viewed state (opacity of entire card)
    if ('viewed' in updates) {
        if (updates.viewed) {
            card.classList.add('opacity-60');
        } else {
            card.classList.remove('opacity-60');
        }
    }
    
    // Update stage badge
    if ('stage' in updates) {
        const stageBadge = card.querySelector('[data-badge="stage"]');
        if (stageBadge) {
            // Set base classes if not already set
            if (!stageBadge.className.includes('inline-flex')) {
                stageBadge.className = 'inline-flex items-center px-2 py-0.5 text-xs font-medium rounded-full shrink-0';
            }
            
            let stageEmoji = '';
            let stageClasses = '';
            
            switch (updates.stage) {
                case 'CHAT':
                    stageEmoji = 'ğŸ’¬';
                    stageClasses = 'bg-blue-100 text-blue-700';
                    break;
                case 'SEEK':
                    stageEmoji = 'âœ…';
                    stageClasses = 'bg-yellow-100 text-yellow-700';
                    break;
                case 'CONTACT':
                    stageEmoji = 'â­';
                    stageClasses = 'bg-emerald-100 text-emerald-700';
                    break;
                case 'PASS':
                    stageEmoji = 'âŒ';
                    stageClasses = 'bg-red-100 text-red-700';
                    break;
                default:
                    stageEmoji = '';
                    stageClasses = 'bg-gray-100 text-gray-700';
            }
            
            // Remove old stage color classes and add new one
            stageBadge.className = stageBadge.className.replace(/\b(bg-(blue|yellow|emerald|green|red|gray)-100 text-(blue|yellow|emerald|green|red|gray)-700)\b/g, '');
            stageBadge.className += ' ' + stageClasses;
            stageBadge.textContent = stageEmoji;
            
            if (updates.stage) {
                stageBadge.classList.remove('hidden');
            } else {
                stageBadge.classList.add('hidden');
            }
        }
        // If stageBadge doesn't exist, silently skip the update
    }
    
    // Update tags (greeted, saved, and notified - viewed is handled by card opacity)
    const tagsContainer = card.querySelector('#candidate-tags');
    // Update greeted tag
    if ('greeted' in updates) {
        const greetedTag = tagsContainer.querySelector('[data-tag="greeted"]');
        if (greetedTag) {
            if (updates.greeted) {
                greetedTag.classList.remove('hidden');
            } else {
                greetedTag.classList.add('hidden');
            }
        }
    }
    
    // Update saved tag
    if ('saved' in updates) {
        const savedTag = tagsContainer.querySelector('[data-tag="saved"]');
        if (savedTag) {
            if (updates.saved) {
                savedTag.classList.remove('hidden');
            } else {
                savedTag.classList.add('hidden');
            }
        }
    }
    
    // Update notified tag
    if ('notified' in updates) {
        const notifiedTag = tagsContainer.querySelector('[data-tag="notified"]');
        if (notifiedTag) {
            if (updates.notified) {
                notifiedTag.classList.remove('hidden');
            } else {
                notifiedTag.classList.add('hidden');
            }
        }
    }
    
    // Update score badge
    if ('score' in updates) {
        const cardContainer = card.querySelector('#candidate-card-content');
        const scoreBadge = cardContainer?.querySelector('[data-badge="score"]');
        if (updates.score !== null && updates.score !== undefined) {
            scoreBadge.textContent = updates.score.toString();
            scoreBadge.classList.remove('hidden');
        } else {
            scoreBadge.classList.add('hidden');
        }
    }
    
    // Update last_message/generated_message display: 
    // last_message is only for the first time loaded from website, 
    // generated_message is for the updated message generated by the assistant
    if ('generated_message' in updates) {
        // Find the last_message paragraph element (the one with text-xs text-gray-500 mt-1 line-clamp-2 classes)
        // Try multiple selector approaches for robustness
        let lastMessageElement = card.querySelector('#last-message');
        if (lastMessageElement) {
            lastMessageElement.textContent = updates.generated_message || 'æš‚æ— æ¶ˆæ¯';
        }
    }
}

// Centralized event listener for candidate updates
document.addEventListener('candidate:update', function(event) {
    const { identifiers = {}, updates = {} } = event.detail || {};
    const candidateCards = document.querySelectorAll('.candidate-card');
    
    // Convert NodeList to Array
    const cardsArray = Array.from(candidateCards);
    
    // Find matching card by identifiers
    let card = cardsArray.find(c => {
        const hxVals = c.getAttribute('hx-vals');
        const data = JSON.parse(hxVals);
        const candidateData = data.candidate || data;
        return idMatched(candidateData, identifiers);
    });

    if (!card) {
        console.warn('candidate:update: no matching card found', identifiers);
        return;
    }
    
    applyCardUpdate(card, updates, identifiers);
});

/**
 * Helper function to check if identifiers match
 */
function idMatched(data, identifiers) {
    if (identifiers.candidate_id && data.candidate_id === identifiers.candidate_id) {
        return true;
    }
    if (identifiers.chat_id && data.chat_id === identifiers.chat_id) {
        return true;
    }
    if (identifiers.name && data.name === identifiers.name) {
        return true;
    }
    if (identifiers.index && data.index === identifiers.index) {
        return true;
    }
    return false;
}
</script>
{% endblock %}