{% extends "base.html" %}

{% block title %}å€™é€‰äººç®¡ç† - BOSSæ‹›è˜åŠ©æ‰‹{% endblock %}

{% block content %}

<!-- Troubleshooting Modal -->
<div x-data="{ 
        showTroubleshooting: false,
        contentKey: 'candidates-troubleshooting',
        content: 'å¦‚æœå‡ºç°é—®é¢˜ï¼Œè¯·æŒ‰ç…§ä¸‹é¢æµç¨‹æ’æŸ¥ï¼š\n1. è¯·æŸ¥çœ‹bossé¡µé¢æ˜¯å¦æ­£å¸¸\n2. åˆ·æ–°é¡µé¢\n3. æŸ¥çœ‹ç»ˆç«¯ï¼ˆterminalï¼‰çš„æç¤ºï¼Œæ˜¯å¦æœ‰é”™è¯¯\n4. å¦‚ç»ˆç«¯æœ‰é”™è¯¯ï¼Œå¤åˆ¶ç»ˆç«¯é”™è¯¯å¹¶é—®é—®cursoræˆ–è€…å°è¯•ç”¨cursorä¿®å¤\n5. å°†cursorçš„å›ç­”å‘é€åˆ°ç¾¤é‡Œè®©å·¥ç¨‹å¸ˆä¿®å¤',
        init() {
            // Use hash-based notification system
            if (typeof window.shouldShowNotification === 'function') {
                this.showTroubleshooting = window.shouldShowNotification(this.contentKey, this.content);
            }
            if (this.showTroubleshooting) {
                this.$el.style.display = 'flex';
            }
        },
        dismiss() {
            if (typeof window.acknowledgeNotification === 'function') {
                window.acknowledgeNotification(this.contentKey, this.content);
            }
            this.showTroubleshooting = false;
        }
     }" 
     x-show="showTroubleshooting"
     x-transition:enter="transition ease-out duration-300"
     x-transition:enter-start="opacity-0"
     x-transition:enter-end="opacity-100"
     x-transition:leave="transition ease-in duration-200"
     x-transition:leave-start="opacity-100"
     x-transition:leave-end="opacity-0"
     class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
     style="display: none;">
    <div class="bg-white rounded-lg shadow-2xl max-w-md w-full mx-4"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0 transform scale-95"
         x-transition:enter-end="opacity-100 transform scale-100"
         x-transition:leave="transition ease-in duration-200"
         x-transition:leave-start="opacity-100 transform scale-100"
         x-transition:leave-end="opacity-0 transform scale-95">
        <div class="p-4">
            <div class="flex items-center mb-4">
                <div class="w-10 h-10 bg-yellow-100 rounded-full flex items-center justify-center mr-3">
                    <span class="text-2xl">âš ï¸</span>
                </div>
                <h3 class="text-xl font-bold text-gray-800">é—®é¢˜æ’æŸ¥æç¤º</h3>
            </div>
            <div class="mb-6">
                <p class="text-gray-700 leading-relaxed whitespace-pre-line" x-text="content"></p>
            </div>
            <div class="flex justify-end">
                <button @click="dismiss()"
                        class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition font-medium">
                    å·²çŸ¥æ™“
                </button>
            </div>
        </div>
    </div>
</div>

<div x-data="candidateTabs()" x-init="init()" class="space-y-6">
    <!-- Page header with controls -->
    <div class="bg-white rounded-lg shadow p-4">
        <!-- <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800">å€™é€‰äººç®¡ç†</h1>
            <button onclick="location.reload()" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition">
                ğŸ”„ åˆ·æ–°
            </button>
        </div> -->
        
        <!-- Tab switcher with batch analyze button -->
        <div class="flex justify-between items-center border-b mb-4">
            <div class="flex space-x-2" id="tab-buttons">
            <button 
                @click="switchTab('recommend')"
                data-tab="recommend"
                :class="activeTab === 'recommend' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                â­ æ¨èç‰›äºº
            </button>
            <button 
                @click="switchTab('greet')"
                data-tab="greet"
                :class="activeTab === 'greet' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                ğŸ‘‹ æ–°æ‹›å‘¼
            </button>
            <button 
                @click="switchTab('chat')"
                data-tab="chat"
                :class="activeTab === 'chat' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                ğŸ’¬ æ²Ÿé€šä¸­
            </button>
            <button 
                @click="switchTab('followup')"
                data-tab="followup"
                :class="activeTab === 'followup' ? 'border-b-2 border-blue-600 text-blue-600' : 'text-gray-600'"
                class="tab-btn px-4 py-3 font-medium hover:text-blue-600 transition">
                ğŸ“­ ç‰›äººå·²è¯»æœªå›
            </button>
            </div>
            <!-- Top-right controls: Auto-send checkbox and Process button -->
            <div class="flex items-center gap-4">
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="auto-send-checkbox" checked class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" @change="saveState()">
                    <span class="text-sm text-gray-700 font-medium">è‡ªåŠ¨å‘é€</span>
                </label>
                <label class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="process-all-modes-checkbox" class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" @change="saveState()">
                    <span class="text-sm text-gray-700 font-medium">å¤„ç†æ‰€æœ‰æ¨¡å¼</span>
                </label>
            </div>
        </div>
        
        <!-- Filters -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div class="md:col-span-1">
                <div class="flex items-end gap-2">
                    <div class="shrink-0">
                        <label class="block text-sm font-medium text-gray-700 mb-2">è‡ªåŠ¨å¤„ç†</label>
                        <button 
                            id="cycle-reply-btn"
                            onclick="window.startProcessCandidate()"
                            title="è‡ªåŠ¨å¤„ç†å€™é€‰äººï¼š&#10;&#10;â€¢ æœªå‹¾é€‰&quot;å¤„ç†æ‰€æœ‰æ¨¡å¼&quot;ï¼šåªå¤„ç†å½“å‰æ¨¡å¼çš„å€™é€‰äºº&#10;â€¢ å‹¾é€‰&quot;å¤„ç†æ‰€æœ‰æ¨¡å¼&quot;ï¼šè‡ªåŠ¨å¾ªç¯å¤„ç†æ‰€æœ‰4ä¸ªæ¨¡å¼ï¼ˆæ¨èç‰›äººã€æ–°æ‹›å‘¼ã€æ²Ÿé€šä¸­ã€ç‰›äººå·²è¯»æœªå›ï¼‰&#10;&#10;å¤„ç†æµç¨‹ï¼š&#10;1. åŠ è½½åœ¨çº¿ç®€å†ï¼ˆå¦‚æœªåŠ è½½ï¼‰&#10;2. åˆå§‹åŒ–å¯¹è¯ï¼ˆå¦‚æœªåˆå§‹åŒ–ï¼‰&#10;3. è¿›è¡ŒAIåˆ†æï¼ˆå¦‚æœªåˆ†æï¼‰&#10;4. æ ¹æ®åŒ¹é…åº¦é˜ˆå€¼ç”Ÿæˆæ¶ˆæ¯æˆ–å‘é€æ‹›å‘¼&#10;5. æ›´æ–°å€™é€‰äººå¡ç‰‡çŠ¶æ€&#10;&#10;æç¤ºï¼šç¡®ä¿å·²é€‰æ‹©å²—ä½å¹¶è®¾ç½®å¥½é˜ˆå€¼å‚æ•°"
                            class="px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition disabled:opacity-50 disabled:cursor-not-allowed">
                            â–¶ è‡ªåŠ¨å¤„ç†
                        </button>
                    </div>
                    <div class="flex-1 min-w-0">
                <label class="block text-sm font-medium text-gray-700 mb-2">å²—ä½</label>
                <select id="job-selector" name="job_id" class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                        hx-get="/jobs/list-simple" hx-trigger="load" hx-swap="innerHTML"
                                @change="saveState()">
                    <option>åŠ è½½ä¸­...</option>
                </select>
                    </div>
                </div>
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">
                    æ²Ÿé€šé˜ˆå€¼
                    <span class="text-xs text-gray-500">â‰¥ æ­¤åˆ†æ•°ç”Ÿæˆæ¶ˆæ¯</span>
                </label>
                    <input type="number" id="threshold-chat" name="threshold_chat" 
                       value="6.0" 
                           min="1" max="10" step="0.5"
                       @change="saveState()"
                       class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-2">
                     åŠæ ¼çº¿
                    <span class="text-xs text-gray-500">â‰¥ æ­¤åˆ†æ•°è¡¨ç¤ºå…´è¶£</span>
                </label>
                <input type="number" id="threshold-borderline" name="threshold_borderline" 
                       value="7.0" 
                       min="1" max="10" step="0.5"
                       @change="saveState()"
                       class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>
    </div>
    
    <!-- Main content area: List + Detail -->
    <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
        <!-- Candidate list (left sidebar) -->
        <div class="lg:col-span-4">
            <div class="bg-white rounded-lg shadow-lg h-[1000px] overflow-y-auto">
                <div id="candidate-list" class="p-4 space-y-2">
                    <!-- Initial message -->
                    <div id="initial-message" class="text-center text-gray-500 py-12">
                        ç‚¹å‡»ä¸‹æ–¹"æŸ¥è¯¢å€™é€‰äºº"æŒ‰é’®åŠ è½½æ•°æ®
                    </div>
                    <!-- Candidates will be appended here -->
                </div>
                
                <!-- Load more button at bottom of list -->
                <div class="p-4 border-t bg-gray-50">
                    <div class="flex gap-2 items-end">
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-1">æ•°é‡é™åˆ¶</label>
                            <input 
                                type="number" 
                                id="limit-input" 
                                name="limit" 
                                value="50" 
                                min="1" 
                                max="999" 
                                step="1"
                                @change="saveState()"
                                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                    <button 
                        @click="loadCandidates()"
                        id="load-more-btn"
                        :disabled="loading"
                        :class="loading ? 'opacity-50 cursor-not-allowed' : ''"
                            class="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                        <span x-text="loading ? 'â³ åŠ è½½ä¸­...' : 'ğŸ” æŸ¥è¯¢å€™é€‰äºº'"></span>
                    </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Candidate detail (right panel) -->
        <div class="lg:col-span-8">
            <div id="detail-pane" class="bg-white rounded-lg shadow-lg p-4">
                <!-- Will be populated when candidate is selected -->
                <div class="text-center text-gray-500 py-24">
                    <div class="text-6xl mb-4">ğŸ‘¤</div>
                    <p class="text-lg">è¯·ä»å·¦ä¾§åˆ—è¡¨ä¸­é€‰æ‹©å€™é€‰äºº</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// ============================================================================
// Candidate Tabs Component
// ============================================================================

const CANDIDATE_STORAGE_KEY = 'candidate_page_state';

// Candidate tabs component
function candidateTabs() {
    return {
        activeTab: 'recommend',
        loading: false,
        
        init() {
            // Restore state from localStorage or URL on page load
            this.restoreState();
            
            // Listen for browser back/forward buttons
            window.addEventListener('popstate', () => {
                this.restoreState();
            });
        },
        
        saveState() {
            const state = {
                tab: this.activeTab,
                threshold_chat: document.getElementById('threshold-chat')?.value,
                threshold_borderline: document.getElementById('threshold-borderline')?.value,
                job_id: document.getElementById('job-selector')?.value,
                limit: document.getElementById('limit-input')?.value,
                auto_send: document.getElementById('auto-send-checkbox')?.checked ? 'true' : 'false',
                process_all_modes: document.getElementById('process-all-modes-checkbox')?.checked ? 'true' : 'false'
            };
            
            // Only save non-empty values
            const cleanedState = {};
            for (const [key, value] of Object.entries(state)) {
                if (value && value !== 'åŠ è½½ä¸­...') {
                    cleanedState[key] = value;
                }
            }
            
            localStorage.setItem(CANDIDATE_STORAGE_KEY, JSON.stringify(cleanedState));
        },
        
        restoreState() {
            // First, try to get values from URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            let state = {};
            
            // Check if URL has query parameters
            const hasUrlParams = Array.from(urlParams.keys()).length > 0;
            
            if (hasUrlParams) {
                // Restore from URL parameters
                for (const [key, value] of urlParams.entries()) {
                    state[key] = value;
                }
                // Save URL params to localStorage
                localStorage.setItem(CANDIDATE_STORAGE_KEY, JSON.stringify(state));
            } else {
                // Restore from localStorage
                const saved = localStorage.getItem(CANDIDATE_STORAGE_KEY);
                if (saved) {
                    try {
                        state = JSON.parse(saved);
                    } catch (e) {
                        console.error('Failed to parse saved candidate state:', e);
                    }
                }
            }
            
            // Apply saved values
            // Set active tab
            const tab = state.tab;
            if (tab && ['recommend', 'greet', 'chat', 'followup'].includes(tab)) {
                this.activeTab = tab;
            }
            
            // Set thresholds
            if (state.threshold_chat) {
                const chatInput = document.getElementById('threshold-chat');
                if (chatInput) chatInput.value = state.threshold_chat;
            }
            
            if (state.threshold_borderline) {
                const borderlineInput = document.getElementById('threshold-borderline');
                if (borderlineInput) borderlineInput.value = state.threshold_borderline;
            }
            
            // Set job selector (after jobs are loaded)
            if (state.job_id) {
                const checkJobSelector = setInterval(() => {
                    const jobSelector = document.getElementById('job-selector');
                    if (jobSelector && jobSelector.options.length > 1) {
                        for (let option of jobSelector.options) {
                            if (option.value === state.job_id) {
                                jobSelector.value = state.job_id;
                                clearInterval(checkJobSelector);
                                break;
                            }
                        }
                        clearInterval(checkJobSelector);
                    }
                }, 100);
                setTimeout(() => clearInterval(checkJobSelector), 5000);
            }
            
            // Set limit
            if (state.limit) {
                const limitInput = document.getElementById('limit-input');
                if (limitInput) limitInput.value = state.limit;
            }
            
            // Set auto-send checkbox
            const autoSendCheckbox = document.getElementById('auto-send-checkbox');
            if (autoSendCheckbox) {
                autoSendCheckbox.checked = state.auto_send === 'true';
            }
            
            // Set process-all-modes checkbox
            const processAllModesCheckbox = document.getElementById('process-all-modes-checkbox');
            if (processAllModesCheckbox) {
                processAllModesCheckbox.checked = state.process_all_modes === 'true';
            }
        },
        
        
        switchTab(tab) {
            // If the tab is already active, keep the list and do nothing
            if (this.activeTab === tab) {
                console.log(`[switchTab] Tab ${tab} is already active, keeping list`);
                return;
            }
            
            this.activeTab = tab;
            // Reset selected candidate
            // Clear list when switching tabs
            const list = document.getElementById('candidate-list');
            if (list) {
                list.innerHTML = '';
                // Re-add initial message
                const initialMsg = document.createElement('div');
                initialMsg.id = 'initial-message';
                initialMsg.className = 'text-center text-gray-500 py-12';
                initialMsg.textContent = 'ç‚¹å‡»ä¸‹æ–¹"æŸ¥è¯¢å€™é€‰äºº"æŒ‰é’®åŠ è½½æ•°æ®';
                list.appendChild(initialMsg);
            }
            // Batch analyze button has been removed - no longer needed
            // Save state to localStorage
            this.saveState();
        },
        
        loadCandidates() {
            this.loading = true;
            loadCandidatesList(this.activeTab)
                .then(() => {
                    this.loading = false;
                })
                .catch(() => {
                    this.loading = false;
                });
        }
    };
}

// ============================================================================
// Load Candidates Function
// ============================================================================

/**
 * Load candidates list for the given tab/mode
 * @param {string} activeTab - The active tab name ('recommend', 'greet', 'chat', 'followup')
 * @returns {Promise<void>}
 */
async function loadCandidatesList(activeTab) {
    const jobSelector = document.getElementById('job-selector');
    const job_id = jobSelector?.value || jobSelector?.options[0]?.value;
    const job_title = jobSelector?.selectedOptions[0]?.getAttribute("data-title");
    
    // Check if job title is valid
    if (!job_title || job_title === 'åŠ è½½ä¸­...') {
        console.error('Job title not loaded yet');
        showToast('è¯·ç­‰å¾…å²—ä½åˆ—è¡¨åŠ è½½å®Œæˆåå†æŸ¥è¯¢', 'warning');
        throw new Error('Job title not loaded');
    }
    
    let mode, chat_type;
    if (activeTab === 'recommend') {
        mode = 'recommend';
        chat_type = '';
    } else {
        mode = activeTab; // Use the tab name directly as mode
        const tabMap = {
            'greet': 'æ–°æ‹›å‘¼',
            'chat': 'æ²Ÿé€šä¸­',
            'followup': 'ç‰›äººå·²è¯»æœªå›'
        };
        chat_type = tabMap[activeTab] || 'æ–°æ‹›å‘¼';
    }
    
    // Get limit from input
    const limitInput = document.getElementById('limit-input');
    const limit = limitInput?.value || '50';

    const params = new URLSearchParams({
        mode: mode,
        chat_type: chat_type,
        job_applied: job_title,
        job_id: job_id,
        limit: limit
    });
    
    const url = `/candidates/list?${params.toString()}`;
    console.log('Loading candidates:', url);
    
    const candidateList = document.getElementById('candidate-list');
    
    // Clear all non-candidate content (error messages, initial messages, empty messages)
    // Keep only candidate cards if we're appending
    const initialMsg = document.getElementById('initial-message');
    if (initialMsg) {
        initialMsg.remove();
    }
    const emptyMsg = document.getElementById('empty-message');
    if (emptyMsg) {
        emptyMsg.remove();
    }
    
    // Remove any error messages (divs with text-red-500 or containing error indicators)
    const errorMessages = candidateList.querySelectorAll('.text-red-500, [class*="error"], [class*="å¤±è´¥"]');
    errorMessages.forEach(msg => {
        // Only remove if it's not a candidate card
        if (!msg.closest('.candidate-card')) {
            msg.remove();
        }
    });
    
    // Use a custom handler to detect errors and handle swap accordingly
    const response = await fetch(url);
    const html = await response.text();
    
    // Check if response is an error message
    if (!response.ok) {
        // Error: replace list content with error message
        candidateList.innerHTML = html;
        showToast('è·å–å€™é€‰äººåˆ—è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
        throw new Error('Failed to load candidates');
    }
    
    // Success: replace the entire list with new candidate cards
    // Use the HTML response directly
    candidateList.innerHTML = html;
    
    // Tell HTMX to process the new content
    htmx.process(candidateList);
    
    const loadedCount = candidateList.querySelectorAll('.candidate-card').length;
    console.log(`Loaded ${loadedCount} candidate cards`);
    
    // Dispatch event to notify that candidate list has been loaded
    // This allows other parts of the UI to react to the list update
    document.dispatchEvent(new CustomEvent('candidates:list-loaded', {
        detail: {
            count: loadedCount,
            hasEmptyMessage: loadedCount === 0
        }
    }));
}

// Function is already global (defined with 'async function' keyword)
// It can be accessed via window.loadCandidatesList or directly as loadCandidatesList


// ============================================================================
// Candidate Selection Management
// ============================================================================

// Visual state management for candidate cards
document.body.addEventListener('htmx:beforeRequest', function(event) {
    // Check if this is a candidate card click
    const elt = event.detail.elt;
    // Check if elt itself is a candidate-card, or if it's inside one
    const card = elt.classList?.contains('candidate-card') ? elt : elt.closest('.candidate-card');
    if (!card) {
        return;  // Not a candidate card, allow request normally
    }
    
    // Remove selected state from all cards
    document.querySelectorAll('.candidate-card').forEach(c => {
        c.classList.remove('bg-blue-50', 'border-blue-500', 'ring-2', 'ring-blue-300');
        c.classList.add('border-gray-200');
    });
    
    // Add selected state to clicked card
    card.classList.remove('border-gray-200');
    card.classList.add('bg-blue-50', 'border-blue-500', 'ring-2', 'ring-blue-300');
    
    // Scroll card into view in the left panel
    card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
});

// ============================================================================
// Helper functions to disable/enable candidate cards
// ============================================================================

function disableAllCards() {
    const cards = document.querySelectorAll('.candidate-card');
    cards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.6';
    });
}

function enableAllCards() {
    const cards = document.querySelectorAll('.candidate-card');
    cards.forEach(card => {
        card.style.pointerEvents = '';
        card.style.opacity = '';
    });
}
// Functions are already global (defined with 'function' keyword)
// They can be accessed via window.disableAllCards or directly as disableAllCards

// ============================================================================
// Processing Cancellation Listeners
// ============================================================================

// Don't cancel processing when tab becomes hidden - allow switching tabs
// Processing will continue in the background

// Cancel processing on page unload
window.addEventListener('beforeunload', () => {
    if (window.cycleReplyState?.running) {
        window.cycleReplyState.stopRequested = true;
    }
});

// ============================================================================
// Candidate Card Update Functions
// ============================================================================
/**
 * Update a candidate card with the given updates
 */
function applyCardUpdate(card, updates, identifiers) {
    // Parse hx-vals which has structure: {"candidate": {...}}
    const hxValsData = JSON.parse(card.getAttribute('hx-vals') || '{"candidate": {}}');
    const cardData = hxValsData.candidate || {};
    
    // Update the card's candidate data
    Object.assign(cardData, updates);
    Object.assign(cardData, identifiers);
    
    // Apply updates - maintain the {"candidate": {...}} structure
    card.setAttribute('hx-vals', JSON.stringify({ candidate: cardData }));
    
    // Update viewed state (opacity of entire card)
    if ('viewed' in updates) {
        if (updates.viewed) {
            card.classList.add('opacity-60');
        } else {
            card.classList.remove('opacity-60');
        }
    }
    
    // Update stage badge
    if ('stage' in updates) {
        const stageBadge = card.querySelector('[data-badge="stage"]');
        if (stageBadge) {
            // Set base classes if not already set
            if (!stageBadge.className.includes('inline-flex')) {
                stageBadge.className = 'inline-flex items-center px-2 py-0.5 text-xs font-medium rounded-full shrink-0';
            }
            
            let stageEmoji = '';
            let stageClasses = '';
            
            switch (updates.stage) {
                case 'CHAT':
                    stageEmoji = 'ğŸ’¬';
                    stageClasses = 'bg-blue-100 text-blue-700';
                    break;
                case 'SEEK':
                    stageEmoji = 'âœ…';
                    stageClasses = 'bg-yellow-100 text-yellow-700';
                    break;
                case 'CONTACT':
                    stageEmoji = 'â­';
                    stageClasses = 'bg-emerald-100 text-emerald-700';
                    break;
                case 'PASS':
                    stageEmoji = 'âŒ';
                    stageClasses = 'bg-red-100 text-red-700';
                    break;
                default:
                    stageEmoji = '';
                    stageClasses = 'bg-gray-100 text-gray-700';
            }
            
            // Remove old stage color classes and add new one
            stageBadge.className = stageBadge.className.replace(/\b(bg-(blue|yellow|emerald|green|red|gray)-100 text-(blue|yellow|emerald|green|red|gray)-700)\b/g, '');
            stageBadge.className += ' ' + stageClasses;
            stageBadge.textContent = stageEmoji;
            
            if (updates.stage) {
                stageBadge.classList.remove('hidden');
            } else {
                stageBadge.classList.add('hidden');
            }
        }
        // If stageBadge doesn't exist, silently skip the update
    }
    
    // Update tags (greeted, saved, and notified - viewed is handled by card opacity)
    const tagsContainer = card.querySelector('#candidate-tags');
    // Update greeted tag
    if ('greeted' in updates) {
        const greetedTag = tagsContainer.querySelector('[data-tag="greeted"]');
        if (greetedTag) {
            if (updates.greeted) {
                greetedTag.classList.remove('hidden');
            } else {
                greetedTag.classList.add('hidden');
            }
        }
    }
    
    // Update saved tag
    if ('saved' in updates) {
        const savedTag = tagsContainer.querySelector('[data-tag="saved"]');
        if (savedTag) {
            if (updates.saved) {
                savedTag.classList.remove('hidden');
            } else {
                savedTag.classList.add('hidden');
            }
        }
    }
    
    // Update notified tag
    if ('notified' in updates) {
        const notifiedTag = tagsContainer.querySelector('[data-tag="notified"]');
        if (notifiedTag) {
            if (updates.notified) {
                notifiedTag.classList.remove('hidden');
            } else {
                notifiedTag.classList.add('hidden');
            }
        }
    }
    
    // Update score badge
    if ('score' in updates) {
        const cardContainer = card.querySelector('#candidate-card-content');
        const scoreBadge = cardContainer?.querySelector('[data-badge="score"]');
        if (updates.score !== null && updates.score !== undefined) {
            scoreBadge.textContent = updates.score.toString();
            scoreBadge.classList.remove('hidden');
        } else {
            scoreBadge.classList.add('hidden');
        }
    }
    
    // Update last_message/generated_message display: 
    // last_message is only for the first time loaded from website, 
    // generated_message is for the updated message generated by the assistant
    if ('generated_message' in updates) {
        // Find the last_message paragraph element (the one with text-xs text-gray-500 mt-1 line-clamp-2 classes)
        // Try multiple selector approaches for robustness
        let lastMessageElement = card.querySelector('#last-message');
        if (lastMessageElement) {
            lastMessageElement.textContent = updates.generated_message || 'æš‚æ— æ¶ˆæ¯';
        }
    }
}

// Centralized event listener for candidate updates
document.addEventListener('candidate:update', function(event) {
    const { identifiers = {}, updates = {} } = event.detail || {};
    console.log('[updateCandidateData] received event', { identifiers, updates });
    const candidateCards = document.querySelectorAll('.candidate-card');
    
    // Convert NodeList to Array
    const cardsArray = Array.from(candidateCards);
    
    // Find matching card by identifiers
    let card = cardsArray.find(c => {
        const hxVals = c.getAttribute('hx-vals');
        const data = JSON.parse(hxVals);
        const candidateData = data.candidate || data;
        return idMatched(candidateData, identifiers);
    });

    if (!card) {
        debugger;
        console.warn('candidate:update: no matching card found', identifiers);
        return;
    }
    
    applyCardUpdate(card, updates, identifiers);
});

/**
 * Helper function to check if identifiers match
 */
function idMatched(data, identifiers) {
    if (identifiers.candidate_id && data.candidate_id === identifiers.candidate_id) {
        return true;
    }
    if (identifiers.chat_id && data.chat_id === identifiers.chat_id) {
        return true;
    }
    if (identifiers.conversation_id && data.conversation_id === identifiers.conversation_id) {
        return true;
    }
    if (identifiers.index !== undefined && data.index === identifiers.index) {
        return true;
    }
    return false;
}

// Event listener for candidate list loaded - re-apply UI state
document.addEventListener('candidates:list-loaded', function(event) {
    // Re-apply mask if batch processing is active
    if (window.cycleReplyState?.running) {
        document.dispatchEvent(new CustomEvent('candidates:disable-cards'));
    }
});

// Event listener for disabling candidate cards
document.addEventListener('candidates:disable-cards', function(event) {
    disableAllCards();
});

// Event listener for enabling candidate cards
document.addEventListener('candidates:enable-cards', function(event) {
    enableAllCards();
});

// Event listener for removing candidate card with fade out animation
document.addEventListener('candidate:remove', function(event) {
    const { identifiers = {} } = event.detail || {};
    const candidateCards = document.querySelectorAll('.candidate-card');
    const cardsArray = Array.from(candidateCards);
    
    // Find matching card by identifiers
    const card = cardsArray.find(c => {
        const hxVals = c.getAttribute('hx-vals');
        const data = JSON.parse(hxVals);
        const candidateData = data.candidate || data;
        return idMatched(candidateData, identifiers);
    });
    
    if (!card) {
        console.warn('candidate:remove: no matching card found', identifiers);
        return;
    }
    
    // Add fade out animation
    card.style.transition = 'opacity 0.3s ease-out';
    card.style.opacity = '0';
    
    // Remove card after animation completes
    setTimeout(() => {
        card.remove();
    }, 300);
});


// ============================================================================
// Process a single candidate card
// ============================================================================
async function processCandidateCard(card) {
    const cardData = JSON.parse(card.getAttribute('hx-vals'));
    const candidate = cardData.candidate || {};
    const name = candidate.name;
    
    // Skip only if candidate is both viewed AND analyzed
    if (candidate.viewed && candidate.analysis) {
        return { skipped: true, name };
    }
    
    console.log(`æ­£åœ¨å¤„ç†å€™é€‰äºº: ${name}`);
    
    // Get detailPane reference
    const detailPane = document.getElementById('detail-pane');
    if (!detailPane) {
        throw new Error('Detail pane not found');
    }
    
    document.dispatchEvent(new CustomEvent('candidates:disable-cards'));
    
    // Combined promise: wait for swap, then processing
    let swapTimeout = null;
    let processingTimeout = null;
    let cleanup = null;
    
    const processingPromise = new Promise((resolve, reject) => {
        // Set up processing event listeners (registered before swap to catch early events)
        const onProcessingComplete = () => {
            if (cleanup) cleanup();
            resolve();
        };
        
        const onProcessingError = (event) => {
            if (cleanup) cleanup();
            reject(new Error(event.detail?.error || 'Processing failed'));
        };
        
        // Set up swap event listeners
        const onSwap = () => {
            clearTimeout(swapTimeout);
            // Processing timeout starts after swap completes
            processingTimeout = setTimeout(() => {
                if (cleanup) cleanup();
                reject(new Error('Processing timeout (180s)'));
            }, 180000);
        };
        
        const onResponseError = (evt) => {
            if (cleanup) cleanup();
            evt.stopPropagation();
            reject(new Error(evt.detail?.error || evt.detail?.message || 'HTMX request failed'));
        };
        
        const onSendError = (evt) => {
            if (cleanup) cleanup();
            evt.stopPropagation();
            reject(new Error(evt.detail?.error || evt.detail?.message || evt.detail?.failed || 'HTMX send failed'));
        };
        
        const onSwapError = (evt) => {
            if (cleanup) cleanup();
            evt.stopPropagation();
            reject(new Error(evt.detail?.error || evt.detail?.message || 'HTMX swap failed'));
        };
        
        // Swap timeout
        swapTimeout = setTimeout(() => {
            if (cleanup) cleanup();
            reject(new Error('HTMX swap timeout'));
        }, 1000);
        
        cleanup = () => {
            clearTimeout(swapTimeout);
            clearTimeout(processingTimeout);
            document.removeEventListener('candidate:processing-complete', onProcessingComplete);
            document.removeEventListener('candidate:processing-error', onProcessingError);
            detailPane.removeEventListener('htmx:afterSwap', onSwap);
            detailPane.removeEventListener('htmx:responseError', onResponseError);
            detailPane.removeEventListener('htmx:sendError', onSendError);
            detailPane.removeEventListener('htmx:swapError', onSwapError);
        };
        
        document.addEventListener('candidate:processing-complete', onProcessingComplete, { once: true });
        document.addEventListener('candidate:processing-error', onProcessingError, { once: true });
        detailPane.addEventListener('htmx:afterSwap', onSwap, { once: true });
        detailPane.addEventListener('htmx:responseError', onResponseError, { once: true });
        detailPane.addEventListener('htmx:sendError', onSendError, { once: true });
        detailPane.addEventListener('htmx:swapError', onSwapError, { once: true });
    });
    
    try {
        // Trigger HTMX click (htmx:beforeRequest will handle scrollIntoView and highlighting)
        htmx.trigger(card, 'click');
        
        // Wait for both swap and processing to complete
        await processingPromise;
        
        return { success: true, name };
    } catch (error) {
        // Cleanup is handled in promise cleanup function
        throw error;
    }
}

// Expose to window for use in app.js
window.processCandidateCard = processCandidateCard;
</script>
{% endblock %}
