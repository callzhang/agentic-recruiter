<!-- Candidate detail view with automatic workflow 
    the passed data:
    - "analysis": data.pop("analysis"),
    - "generated_message": data.pop("last_message"),
    - "resume_text": data.pop("resume_text"),
    - "full_resume": data.pop("full_resume"),
    - "candidate": data,
-->
{% set view_mode = view_mode or 'interactive' %}
{% set allow_optimization_feedback = allow_optimization_feedback if allow_optimization_feedback is defined else (view_mode != 'readonly') %}
<div id="candidate-detail-root" class="space-y-6" data-view-mode="{{ view_mode }}">
    {% set metadata = candidate.metadata if candidate.metadata else {} %}
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div class="flex items-center gap-2">
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <button 
                id="copy-link-btn"
                onclick="copyCandidateLink()"
                class="p-1.5 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded transition hidden"
                title="å¤åˆ¶å€™é€‰äººè¯¦æƒ…é“¾æ¥"
                style="display: none;">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                </svg>
            </button>
            
            <!-- Feedback Buttons removed from here -->
        </div>
        <div class="flex space-x-2">
            {% if metadata.contacted %}
            <span class="px-4 py-2 rounded-lg font-medium bg-indigo-100 text-indigo-700 border border-indigo-200">
                å·²è”ç³»
            </span>
            {% endif %}
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>
    
    <!-- Contact Information Section -->
    {% set phone_number = metadata.phone_number if metadata and metadata.phone_number else None %}
    {% set wechat_number = metadata.wechat_number if metadata and metadata.wechat_number else None %}
    {% if phone_number or wechat_number %}
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
        <div class="flex flex-wrap gap-4">
            {% if phone_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="font-mono text-blue-700">{{ phone_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
            {% if wechat_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="font-mono text-blue-700">{{ wechat_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
        </div>
    </div>
    {% endif %}
    
    {% if candidate.name and ('å…ˆç”Ÿ' in candidate.name or 'å¥³å£«' in candidate.name) and candidate.chat_id and candidate.mode == 'recommend' %}
        <div class="flex items-center space-x-2 bg-yellow-100 border-l-4 border-yellow-400 text-yellow-800 px-4 py-2 rounded shadow-sm my-2">
            <span>âš ï¸</span>
            <span>
                æ£€æµ‹åˆ°å€™é€‰äººå§“ååŒ…å«<strong>ã€Œå…ˆç”Ÿã€</strong>æˆ–<strong>ã€Œå¥³å£«ã€</strong>ï¼Œå¯¼è‡´æ•°æ®å¯èƒ½é‡å¤ï¼Œè¯·è®¤çœŸæ£€æŸ¥ä»¥ä¸‹å†…å®¹æ˜¯å¦å’Œæ‹›è˜ç½‘ç«™ä¸€è‡´ã€‚å¦‚æœä¸ä¸€è‡´ï¼Œè¯·é‡æ–°è·å–ç®€å†ã€‚
            </span>
        </div>
    {% endif %}

    <!-- Hidden context for HTMX requests - using JSON to preserve types -->
    <div id="candidate-context" class="hidden" hx-vals='{{ candidate | tojson | safe }}'></div>
    
    <!-- Rejection Feedback Modal -->
    <div id="rejection-feedback-modal"
         class="fixed inset-0 z-50 hidden items-center justify-center bg-black bg-opacity-50 p-4"
         role="dialog"
         aria-modal="true">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-lg">
            <div class="flex items-center justify-between px-5 py-4 border-b">
                <h3 class="text-lg font-semibold text-gray-800">å€™é€‰äººæ”¾å¼ƒ/ä¸åŒ¹é…åŸå› </h3>
                <button onclick="closeRejectModal()" class="text-gray-500 hover:text-gray-800">âœ•</button>
            </div>
            <div class="p-5 space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">åŸå› è¯´æ˜ *</label>
                    <textarea id="rejection-reason"
                              rows="4"
                              class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                              placeholder="ä¾‹å¦‚ï¼šè–ªèµ„é¢„æœŸè¿‡é«˜ï¼›åœ°ç†ä½ç½®ä¸åˆé€‚ï¼›å·²å…¥èŒå…¶ä»–å…¬å¸..."></textarea>
                </div>
            </div>
            <div class="flex justify-end gap-2 px-5 py-4 border-t bg-gray-50">
                <button onclick="closeRejectModal()"
                        class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">
                    å–æ¶ˆ
                </button>
                <button onclick="submitRejectReason()"
                        class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition">
                    ç¡®è®¤å¹¶æäº¤
                </button>
            </div>
        </div>
    </div>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <!-- <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div> -->
        <!-- Tab Navigation -->
        <div class="flex border-b bg-gray-100 items-center">
            <button id="tab-online" onclick="switchResumeTab('online')" 
                    class="px-4 py-2 font-medium text-sm transition-colors bg-white border-b-2 border-blue-500 text-blue-600">
                åœ¨çº¿ç®€å†
            </button>
            <button id="tab-full" onclick="switchResumeTab('full')" 
                    class="px-4 py-2 font-medium text-sm transition-colors text-gray-600 hover:text-gray-800">
                å®Œæ•´ç®€å†
            </button>
            <div class="flex-1"></div>
            {% if view_mode != 'readonly' %}
            <button 
                id="fetch-online-resume-btn"
                onclick="fetchOnlineResume()"
                class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–åœ¨çº¿ç®€å†</span>
            </button>
            <button 
                id="fetch-full-resume-btn"
                onclick="fetchFullResume().catch(err => console.warn('Re-fetch failed:', err))"
                class="hidden px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–å®Œæ•´ç®€å†</span>
            </button>
            {% endif %}
        </div>
        <!-- Tab Content -->
        <div id="resume-content" class="p-2"> 
            <!-- Online Resume Tab -->
            <div id="tab-content-online" class="tab-content">
                <div id="resume-online-container">
                    <textarea id="resume-textarea-online" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if resume_text -%}{{ resume_text }}{%- else -%}â³ æ­£åœ¨åŠ è½½åœ¨çº¿ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
            <!-- Full Resume Tab -->
            <div id="tab-content-full" class="tab-content hidden">
                <div id="resume-full-container">
                    <textarea id="resume-textarea-full" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if full_resume -%}{{ full_resume }}{%- else -%}â³ æ­£åœ¨åŠ è½½å®Œæ•´ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
            <div id="analysis-resume-type-badge" class="ml-3">
                <!-- Will be populated by JavaScript based on analysis result -->
            </div>
            <div class="flex-1"></div>
            {% if allow_optimization_feedback %}
            <button onclick="openOptimizationFeedbackModal()"
                    class="px-3 py-1 text-xs bg-red-100 text-red-800 rounded hover:bg-amber-200 transition flex items-center gap-1 mr-2">
                <span>âœï¸</span>
                <span>è¯„åˆ†ä¸å‡†</span>
            </button>
            {% endif %}
            {% if view_mode != 'readonly' %}
            <button onclick="startAnalysis()"
                    class="px-3 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°åˆ†æ</span>
            </button>
            {% endif %}
        </div>
        <div id="analysis-content" class="p-2">
            {% if analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center p-4 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    {% if allow_optimization_feedback %}
    <!-- Optimization Feedback Modal (è¯„åˆ†ä¸å‡†) -->
    <div id="optimization-feedback-modal"
         class="fixed inset-0 z-50 hidden items-center justify-center bg-black bg-opacity-50 p-4"
         role="dialog"
         aria-modal="true">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-2xl">
            <div class="flex items-center justify-between px-5 py-4 border-b">
                <h3 class="text-lg font-semibold text-gray-800">è¯„åˆ†ä¸å‡†ï¼ˆç”¨äºä¼˜åŒ–å²—ä½è‚–åƒï¼‰</h3>
                <button onclick="closeOptimizationFeedbackModal()" class="text-gray-500 hover:text-gray-800">âœ•</button>
            </div>
            <div class="p-5 space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">å²—ä½ï¼ˆå›ºå®šï¼‰</label>
                    <div id="optimization-job-display"
                         class="w-full px-3 py-2 border rounded-lg bg-gray-50 text-gray-800">
                        â³ è§£æä¸­...
                    </div>
                    <p class="text-xs text-gray-500 mt-1">æ ¹æ®å€™é€‰äººçš„ job_applied è‡ªåŠ¨åŒ¹é…å²—ä½ï¼ˆä¸å…è®¸æ‰‹åŠ¨é€‰æ‹©ï¼‰ã€‚</p>
                </div>

                <div class="grid grid-cols-4 gap-3">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ overall</label>
                        <input id="opt-score-overall" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ skill</label>
                        <input id="opt-score-skill" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ background</label>
                        <input id="opt-score-background" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">ç›®æ ‡ startup_fit</label>
                        <input id="opt-score-startup-fit" type="number" min="1" max="10"
                               class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                               placeholder="ä¸å˜">
                    </div>
                </div>
                <div class="text-xs text-gray-500" id="opt-original-scores">
                    å½“å‰åˆ†æ•°ï¼š-
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">ä¼˜åŒ–å»ºè®®ä¸ç†ç”± *</label>
                    <textarea id="optimization-suggestion"
                              rows="4"
                              class="w-full px-3 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                              placeholder="ä¾‹å¦‚ï¼šè¿™ä¸ªå€™é€‰äººçš„ overall è¢«æ‰“ä½äº†ï¼ŒåŸå› æ˜¯...ï¼›å¸Œæœ›å²—ä½è¯„åˆ†æ ‡å‡†æ˜ç¡®...ï¼›å“ªäº›ä¿¡æ¯ä¸åº”è¯¥åœ¨çº¿ä¸Šè¿½é—®..."></textarea>
                    <p class="text-xs text-gray-500 mt-1">è¿™æ®µä¼šç”¨äºè®© AI é‡å†™å²—ä½è‚–åƒï¼ˆä¸ç›´æ¥å‘ç»™å€™é€‰äººï¼‰ã€‚</p>
                </div>
            </div>
            <div class="flex justify-end gap-2 px-5 py-4 border-t bg-gray-50">
                <button onclick="closeOptimizationFeedbackModal()"
                        class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">
                    å–æ¶ˆ
                </button>
                <button onclick="submitOptimizationFeedback()"
                        class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition">
                    ä¿å­˜åˆ°ä¼˜åŒ–æ¸…å•
                </button>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- 3. Generated Message Section (shown only in interactive/write mode) -->
    {% if view_mode != 'readonly' %}
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
            <div class="flex-1"></div>
            <button onclick="generateMessage(force = true)"
                    class="px-3 py-1 text-xs bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°ç”Ÿæˆæ¶ˆæ¯</span>
            </button>
        </div>
        <div id="message-content" class="p-2">
            {% set chat_history_for_message = metadata.history if metadata and metadata.history else [] %}
            {% set ns = namespace(message='', action='', reason='', placeholder='') %}
            {% for msg in chat_history_for_message | reverse %}
                {% if not ns.message and msg.role == 'assistant' %}
                    {% set ns.action = msg.action if msg.action else '' %}
                    {% set ns.reason = msg.reason if msg.reason else '' %}
                    {% set ns.message = msg.message if msg.message else (msg.content if msg.content else '') %}
                {% endif %}
            {% endfor %}
            {% if generated_message not in ['', 'None', 'null', None] %}
                {% set ns.message = generated_message %}
            {% elif not ns.message %}
                {# Only show as textarea placeholder; never prefill as message to avoid accidental sending. #}
                {% set ns.placeholder = 'â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...' %}
            {% endif %}
            {% set message = ns.message %}
            {% set action = ns.action %}
            {% set reason = ns.reason %}
            {% set placeholder_message = ns.placeholder %}
            {% include 'partials/message_result.html' with context %}
        </div>
        </div>
        <!-- Buttons removed from here -->
    </div>
    </div>
    {% endif %}

    <!-- 4. Chat History Section (shown only in readonly mode) -->
    {% if view_mode == 'readonly' %}
    {% set chat_history = metadata.history if metadata and metadata.history else [] %}
    {% if chat_history %}
    <div id="chat-history-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">ğŸ’¬ èŠå¤©å†å²</h3>
        </div>
        <div class="p-2 space-y-2 max-h-48 overflow-y-auto">
            {% for msg in chat_history %}
            {% set is_candidate = msg.role == 'user' %}
            {% set is_developer = msg.role == 'developer' %}
            {% if is_developer %}
                <!-- Developer message: centered gray box -->
                <div class="flex justify-center">
                    <div class="bg-gray-200 rounded-lg p-2 max-w-[80%]">
                        <p class="text-gray-600 whitespace-pre-wrap text-xs text-center">{{ msg.content or msg.message or '' }}</p>
                    </div>
                </div>
            {% else %}
                {% set bg_color = 'bg-blue-50' if is_candidate else 'bg-gray-50' %}
                {% set icon = 'ğŸ‘¼' if is_candidate else 'ğŸ‘¨â€ğŸ’»â€' %}
                {% set align_class = 'justify-start' if is_candidate else 'justify-end' %}
                {% set text_align = 'text-left' if is_candidate else 'text-right' %}
                {% set display_text = msg.message if msg.message else (msg.content or '') %}
                <div class="flex {{ align_class }}">
                    <div class="{{ bg_color }} rounded-lg p-3 max-w-[80%]">
                        <div class="flex items-start space-x-2 {{ 'flex-row-reverse' if not is_candidate else '' }}">
                            <span class="text-lg">{{ icon }}</span>
                            <div class="flex-1 {{ text_align }}">
                                <div class="flex {{ 'justify-between' if is_candidate else 'justify-end' }} items-start mb-1">
                                    {% if is_candidate %}
                                        <span class="font-medium text-gray-900 text-xs">
                                            {{ candidate.name or 'å€™é€‰äºº' }}
                                        </span>
                                        {% if msg.timestamp %}
                                        <span class="text-xs text-gray-500 ml-2">{{ msg.timestamp }}</span>
                                        {% endif %}
                                    {% else %}
                                        {% if msg.timestamp %}
                                        <span class="text-xs text-gray-500">{{ msg.timestamp }}</span>
                                        {% endif %}
                                        <span class="font-medium text-gray-900 text-xs ml-2">
                                            æ‹›è˜é¡¾é—®
                                        </span>
                                    {% endif %}
                                </div>
                                {% if msg.action %}
                                <div class="mb-1">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-medium bg-indigo-100 text-indigo-700">
                                        {{ msg.action }}
                                    </span>
                                </div>
                                {% endif %}
                                <p class="text-gray-700 whitespace-pre-wrap text-sm">{{ display_text }}</p>
                                {% if msg.reason %}
                                <p class="text-gray-500 whitespace-pre-wrap text-xs mt-2">{{ msg.reason }}</p>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
            {% endif %}
            {% endfor %}
        </div>
    </div>
    {% endif %}
    {% endif %}
    
    <!-- Candidate Processing Section (moved to bottom) -->
    {% if view_mode != 'readonly' or allow_optimization_feedback %}
    <div id="processing-section" class="bg-white rounded-lg border shadow-sm mt-4">
        <div class="p-2 border-b bg-gray-100">
             <h3 class="font-bold text-gray-800">å€™é€‰äººå¤„ç†</h3>
        </div>
        <div class="p-4 flex flex-wrap gap-3 items-center">
             <!-- Action Buttons -->
             {% if view_mode != 'readonly' %}
             <button onclick="greetAndSendMessage()"
                     class="px-4 py-2 bg-green-600 text-white font-medium rounded hover:bg-green-700 shadow-sm transition flex items-center gap-2">
                 <span>ğŸ“¤</span> æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
             </button>
             
             <button onclick="passCandidate()"
                     class="px-4 py-2 bg-red-600 text-white font-medium rounded hover:bg-red-700 shadow-sm transition flex items-center gap-2">
                 <span>âŒ</span> PASS
             </button>
             
             <div class="w-px h-8 bg-gray-300 mx-2"></div>
             {% endif %}
             
             <!-- Feedback Buttons -->
             <button onclick="markContacted()"
                    class="px-4 py-2 bg-blue-600 text-white font-medium rounded hover:bg-blue-700 shadow-sm transition flex items-center gap-2"
                    title="æ ‡è®°ä¸ºå·²è”ç³»">
                <span>ğŸ“</span> å·²è”ç³»
            </button>
            
            <button onclick="openRejectModal()"
                    class="px-4 py-2 bg-gray-600 text-white font-medium rounded hover:bg-gray-700 shadow-sm transition flex items-center gap-2"
                    title="å€™é€‰äººæ”¾å¼ƒ/ä¸åŒ¹é…">
                <span>ğŸš«</span> å€™é€‰äººæ”¾å¼ƒ
            </button>
            
            {% if allow_optimization_feedback %}
            <button onclick="openOptimizationFeedbackModal()"
                    class="px-4 py-2 bg-orange-500 text-white font-medium rounded hover:bg-orange-600 shadow-sm transition flex items-center gap-2">
                <span>âœï¸</span> è¯„åˆ†ä¸å‡†
            </button>
            {% endif %}
        </div>
    </div>
    {% endif %}

    {% if candidate.updated_at %}
    {% set display_time = candidate.updated_at.replace('T', ' ')[:19] %}
    <p class="text-sm text-gray-500 mt-1">æ›´æ–°æ—¶é—´: {{ display_time }}</p>
    {% endif %}
</div>

<!-- Centralized Candidate Analysis & Workflow Logic -->
<script>
// Initialize root and view mode (runs on each HTMX swap)
// Use var to allow redeclaration when HTMX swaps content multiple times
var root = document.getElementById('candidate-detail-root');
var viewMode = root?.dataset?.viewMode || 'interactive';
// Persist on window for other scripts
window.__candidate_detail_root = window.__candidate_detail_root || root;
window.__candidate_detail_view_mode = window.__candidate_detail_view_mode || viewMode;

async function process_candidate() {
    let [newStage, currentScore, analysis, isFullAnalysis] = determineStage();
    try {
        // Step 0: short-circuit if already PASS
        // if (getCandidateData('stage') === 'PASS') {
        //     if (currentScore <= 4) await passCandidate('åˆ†æ•°ä½äº 4ï¼Œä¸åŒ¹é…');
        //     return;
        // }

        // Step 1: Ensure resume is loaded
        const onlineResume = document.getElementById('resume-textarea-online');
        if (!onlineResume?.value || onlineResume.value.includes('â³') || onlineResume.value.length < 100) {
            await fetchOnlineResume();
        }

        // Step 2: Initialize chat if no conversation_id
        if (!getCandidateData('conversation_id')) {
            await initializeNewChat();
        }

        // Step 3: Start analysis if not rendered or pending
        const analysisDiv = document.getElementById('analysis-content');
        const hasAnalysis = !!document.querySelector('#analysis-content #analysis-result-container');
        if (!hasAnalysis || analysisDiv?.textContent?.includes('â³')) {
            await startAnalysis();
        }

        // Step 4: Determine stage (PASS/CHAT/SEEK by score thresholds)
        [newStage, currentScore, analysis, isFullAnalysis] = determineStage();
        let needReply = await shouldReply();
        const {mode, name, job_applied, notified} = getCandidateData();
        
        // Step 4a: CHAT stage -> generate message if needed
        if (newStage === 'CHAT' && needReply) {
            const gen = await generateMessage(false);
            await handleChatAction(gen, analysis);
            needReply = false;
        }
        // Step 4b/4c: SEEK stage -> fetch full resume and re-analyze; then generate message if needed
        if (newStage === 'SEEK') {
            if (mode !== 'recommend') {
                let fullResume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                if (fullResume.includes('â³') || fullResume.length < 100) {
                    await fetchFullResume();
                    fullResume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                }
                if (!isFullAnalysis && fullResume.length > 100) {
                    await startAnalysis();
                    [newStage, currentScore, analysis, isFullAnalysis] = determineStage();
                    if (newStage === 'SEEK' && isFullAnalysis) {
                        needReply = true;
                        sendDingNotification(analysis, name, job_applied);
                    }
                }
                if (isFullAnalysis && ['SEEK', 'CONTACT'].includes(newStage)) {
                    await requestContact();
                }
            }
            // Step 4d: generate message if needed
            if (needReply) {
                const gen = await generateMessage(false);
                await handleChatAction(gen, analysis);
                needReply = false;
            }
        }
        // Step 5: PASS stage
        if (currentScore <= 4) {
            if (newStage !== 'PASS') showToast(`åˆ†æ•°ä½äº 4ï¼Œä½†æ˜¯å½“å‰çŠ¶æ€ï¼š${newStage}`, 'error');
            // å…œåº•ç­–ç•¥ï¼Œç¡®ä¿ä½åˆ†éƒ½PASSæ‰
            await passCandidate('åˆ†æ•°ä½äº 4ï¼Œä¸åŒ¹é…');
            newStage = 'PASS';
        }
    } catch (error) {
        error_message = error.message || String(error);
        showToast(`å¤„ç†å€™é€‰äººæ—¶å‡ºé”™: ${error_message}`, 'error');
        document.dispatchEvent(new CustomEvent('candidate:processing-error', { detail: { error: error_message } }));
    } finally {
        // update the candidate data in the cloud
        await updateCandidateData({ viewed: true, score: currentScore, stage: newStage });
        // dispatch the candidate:processing-complete event to the candidate cards
        document.dispatchEvent(new CustomEvent('candidate:processing-complete'));
    }
}


async function handleChatAction(gen, analysis) {
    const {name, job_applied, mode, notified} = getCandidateData();
    const action = gen?.action;
    const reason = gen?.reason || '';
    const score = analysis?.overall;
    switch (action) {
        case 'PASS':
            await passCandidate(reason);
            break;
        case 'WAIT':
            console.log(`WAIT: ${reason}`);
            break;
        case 'CONTACT':
            if (!notified) await sendDingNotification(analysis, name, job_applied);
            await requestContact();
            await greetAndSendMessage();
            break;
        default:
            await greetAndSendMessage();
            break;
    }
};

/**
 * Send DingTalk notification when candidate score exceeds borderline threshold
 */
async function sendDingNotification(analysis, candidateName, jobApplied) {
    // Get candidate data for server-side notification
    const candidate = getCandidateData();
    const notified = candidate.notified;
    
    // Skip if already notified
    if (notified) {
        showToast('å€™é€‰äººå·²é€šçŸ¥è¿‡ï¼Œè·³è¿‡é€šçŸ¥', 'info');
        return;
    }
    
    // Send analysis data to server - server will format the message
    const response = await fetch('/candidates/notify', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            ...candidate,
            analysis: analysis 
        })
    });
    const result = await window.handleApiResponse(response);
    
    // Update candidate data with notified status if notification was successful
    if (result && result.success) {
        await updateCandidateData({ notified: true });
    }
}

async function fetchOnlineResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    const values = getCandidateData();
    await htmxAjaxPromise('POST', '/candidates/fetch-online-resume', {
        target: '#resume-online-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to online tab after fetch
    switchResumeTab('online');
}

async function fetchFullResume() {
    const values = getCandidateData();
    const mode = values.mode;
    if (mode === 'recommend') {
        return;
    }
    showToast('æŠ“å–å®Œæ•´ç®€å†...', 'info');

    await htmxAjaxPromise('POST', '/candidates/fetch-full-resume', {
        target: '#resume-full-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to full tab after fetch
    switchResumeTab('full');
}

function getGeneratedMessage() {
    const container = document.getElementById('message-result-container');
    const textarea = document.getElementById('message-text');
    const message = textarea?.value?.trim() || '';
    const action = container?.dataset?.action;
    const reason = container?.dataset?.reason;
    return { action, reason, message };
}

async function generateMessage(force = false) {
    const values = getCandidateData();
    showToast(`æ­£åœ¨ä¸ºã€${values.name}ã€‘ç”Ÿæˆæ¶ˆæ¯...`, 'info');
    const mode = values.mode;
    // if force is true or mode is followup, use followup action
    const purpose = mode == 'followup' ? 'FOLLOWUP_ACTION' : 'CHAT_ACTION';
    await htmxAjaxPromise('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        values: {...values, purpose: purpose, force: force}
    });
    const message = getGeneratedMessage();
    await updateCandidateData({generated_message: message.message});
    return message;
}

async function greetAndSendMessage() {
    const autoSend = document.getElementById('auto-send-checkbox')?.checked ?? true;
    const message_textarea = document.getElementById('message-text');
    const message = message_textarea.value.trim();
    const action = document.getElementById('message-result-container')?.dataset?.action;
    const reason = document.getElementById('message-result-container')?.dataset?.reason;
    const mode = getCandidateData('mode');
    let values = getCandidateData();
    if (message === '' || !autoSend) {
        return;
    }
    values.message = message;
    // Remove keys with null or undefined values
    values = Object.fromEntries(
        Object.entries(values).filter(([key, value]) => value !== null && value !== undefined)
    );

    // check if we should send message
    if (!autoSend) {
        if (mode === 'recommend') {
            values.message = '';// if mode is thanrecommend and auto send is false, greet only
        } else {
            return; // skip sending message if auto send is false and mode is not recommend
        }
    }
    showToast(`å‘é€æ¶ˆæ¯: ${values.name}\n[${action}]: ${reason}\n${message}`, 'info', 60_000);
    // send message
    await htmxAjaxPromise('POST', '/candidates/send', {
        target: '#message-content',
        swap: 'none',
        values: values
    });


    // Show browser notification after successful message send
    const candidateName = getCandidateData('name') || 'å€™é€‰äºº';
    const candidateId = getCandidateData('candidate_id');
    const notificationTitle = `å·²å‘ ${candidateName} å‘é€æ¶ˆæ¯`;
    
    // Build Vercel candidate URL
    let candidateUrl = null;
    if (window.__public_url && candidateId) {
        // Vercel candidate detail route is `/candidate/<id>` (singular).
        candidateUrl = `${window.__public_url}/candidate/${candidateId}`;
    }
    
    await showBrowserNotification(notificationTitle, message, null, candidateUrl);
    
    // Update to CHAT stage
    const currentStage = getCandidateData('stage');
    const nextStage = (action === 'CONTACT') ? 'CONTACT' : (currentStage || 'CHAT');
    await updateCandidateData({
        stage: nextStage,
        greeted: true
    });
}


/**
 * Start analysis (current flow)
 */
async function startAnalysis() {
    const resume_text = document.getElementById('resume-textarea-online')?.value?.trim() || '';
    const full_resume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
    const has_full_resume = !full_resume.includes('â³') && full_resume.length > 0;
    const has_online_resume = !resume_text.includes('â³') && resume_text.length > 0;
    
    if (has_full_resume) {
        showToast('æ­£åœ¨åˆ†æå®Œæ•´ç®€å†...', 'info');
    } else if(has_online_resume) {
        showToast('æ­£åœ¨åˆ†æåœ¨çº¿ç®€å†...', 'info');
    } else {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
    }
    
    const values = getCandidateData();
    values.resume_text = resume_text.includes('â³') ? '' : resume_text;
    values.full_resume = full_resume.includes('â³') ? '' : full_resume;
    
    const result = await htmxAjaxPromise('POST', '/candidates/analyze', {
        target: '#analysis-content',
        swap: 'innerHTML',
        values: values
    });
    // Extract analysis from data attribute
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    await updateCandidateData({score: analysis?.overall});
    showToast(`åˆ†æå®Œæˆï¼Œåˆ†æ•°ï¼šã€${analysis?.overall}ã€‘\nåç»­æ²Ÿé€šå»ºè®®ï¼š${analysis?.followup_tips}`, 'info', 60_000);
    // Update resume type badge in tab row
    updateAnalysisResumeTypeBadge(analysis);
}

/**
 * Update the resume type badge in the analysis section tab row
 */
function updateAnalysisResumeTypeBadge(analysis) {
    const badgeContainer = document.getElementById('analysis-resume-type-badge');
    if (badgeContainer && analysis) {
        const resumeType = analysis.resume_type || 'online';
        const badgeClass = resumeType === 'full' 
            ? 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-indigo-100 text-indigo-700'
            : 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-700';
        const badgeText = resumeType === 'full' ? 'ğŸ“„ å®Œæ•´ç®€å†' : 'ğŸŒ åœ¨çº¿ç®€å†';
        badgeContainer.innerHTML = `<span class="${badgeClass}">${badgeText}</span>`;
    }
}

/**
 * Request contact information from candidate
 */
async function requestContact() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const candidate_id = values.candidate_id;
    const mode = values.mode;
    // Skip contact request for recommend mode (no chat_id available)
    if (mode === 'recommend' || !chat_id) {
        return;
    }
    // å¦‚æœå·²æœ‰è”ç³»æ–¹å¼ï¼Œåˆ™ä¸é‡å¤è¯·æ±‚
    if (values.metadata?.phone_number || values.metadata?.wechat_number) {
        return;
    }
    // hisotory = values.metadata?.history || [];
    // for (let i = history.length - 1; i >= 0; i--) {
    //     const msg = history[i] || {};
    //     const role = msg.role;
    //     if (role === 'developer') continue;
    //     const content = msg.content || '';
    //     if (content.includes('è¯·æ±‚äº¤æ¢è”ç³»æ–¹å¼å·²å‘é€') || content.includes('è¯·æ±‚äº¤æ¢å¾®ä¿¡å·²å‘é€')) {
    //         return;
    //     }
    // }
    
    // Call new endpoint with both chat_id and candidate_id
    showToast('æ­£åœ¨è·å–è”ç³»æ–¹å¼...', 'info');
    const response = await fetch('/candidates/request-contact', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(values)
    });
    const data = await window.handleApiResponse(response);
    
    // Update candidate data with contact info in metadata
    // Metadata merging is handled automatically by backend upsert_candidate()
    if (data && (data.phone_number || data.wechat_number)) {
        await updateCandidateData({
            stage: 'CONTACT',
            metadata: {
                phone_number: data.phone_number,
                wechat_number: data.wechat_number,
            }
        });
        showToast(`è”ç³»æ–¹å¼å·²è·å–å¹¶ä¿å­˜: ${data.phone_number} ${data.wechat_number}`, 'success');
        
        // Update contact info display dynamically
        updateContactInfoDisplay(data.phone_number, data.wechat_number);
    } else if (data && data.success !== false) {
        // Contact request succeeded but no numbers obtained yet
        await updateCandidateData({stage: 'CONTACT'});
    }
}

/**
 * Update contact information display in the DOM
 */
function updateContactInfoDisplay(phoneNumber, wechatNumber) {
    // Check if contact info section exists
    let contactSection = document.querySelector('.bg-blue-50.border.border-blue-200');
    
    if (!contactSection && (phoneNumber || wechatNumber)) {
        // Create contact info section if it doesn't exist
        const header = document.querySelector('#candidate-detail-root > div.flex.justify-between');
        if (header && header.nextElementSibling) {
            contactSection = document.createElement('div');
            contactSection.className = 'bg-blue-50 border border-blue-200 rounded-lg p-4';
            contactSection.innerHTML = `
                <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
                <div class="flex flex-wrap gap-4" id="contact-info-content"></div>
            `;
            header.parentNode.insertBefore(contactSection, header.nextElementSibling);
        }
    }
    
    if (contactSection) {
        const contentDiv = contactSection.querySelector('#contact-info-content') || contactSection.querySelector('.flex.flex-wrap');
        if (contentDiv) {
            let html = '';
            if (phoneNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="font-mono text-blue-700">${phoneNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            if (wechatNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="font-mono text-blue-700">${wechatNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            contentDiv.innerHTML = html;
        }
    }
}

/**
 * Initialize new chat - reads all data from DOM
 */
async function initializeNewChat() {
    let candidate = getCandidateData();
    //always use online resume at first time (full resume is not available at first time)
    const resume_text = document.getElementById('resume-textarea-online')?.value;
    if (!resume_text) {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
        return;
    }
    candidate.resume_text = resume_text;

    const formData = new FormData();
    for (const [key, value] of Object.entries(candidate)) {
        if (value !== null && value !== undefined) {
            formData.append(key, value);
        }
    }

    const response = await fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    });
    candidate = await window.handleApiResponse(response);
    console.log('Chat initialized:', candidate);
    await updateCandidateData(candidate);
    return candidate.candidate_id;
}


// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================
function determineStage() {
    let stage = 'PASS';
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const { chat_threshold, borderline_threshold } = getThresholdValues();
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    const {overall, skill, startup_fit, background} = analysis || {};
    const isFullAnalysis = analysis?.resume_type === 'full';
    if (overall >= borderline_threshold){
        stage = 'SEEK';
    }else if(overall >= chat_threshold || skill >= borderline_threshold || startup_fit >= borderline_threshold || background >= borderline_threshold){
        stage = 'CHAT';
    }else if (overall <= chat_threshold) {
        stage = 'PASS';
    }else {
        stage = 'PASS';
    }
    return [stage, overall, analysis, isFullAnalysis];
}

async function passCandidate(reason = '') {
    url = '/candidates/pass';
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const candidate_id = values.candidate_id;
    const index = values.index;
    const mode = values.mode;
    
    showToast('æ­£åœ¨æ ‡è®°ä¸º PASS...', 'info');
    
    const response = await fetch(url, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            mode: mode,
            index: index,
            chat_id: chat_id,
            candidate_id: candidate_id
        })
    });
    try{
        const data = await window.handleApiResponse(response);
        await updateCandidateData({stage: 'PASS'});
    } catch (error) {
        console.error('Failed to pass candidate:', error);
    }
    
    // Remove card with fade out animation
    const identifiers = {
        chat_id: chat_id,
        candidate_id: candidate_id,
        conversation_id: values.conversation_id,
        index: index
    };
    
    // Dispatch event to remove card with animation
    const event = new CustomEvent('candidate:remove', {
        detail: { identifiers: identifiers }
    });
    document.dispatchEvent(event);
    
    // Show toast with reason if available
    let toastMessage = `å€™é€‰äºº ${values.name} å·²æ ‡è®°ä¸º PASSï¼š${reason}`;
    showToast(toastMessage, 'success');
}


/**
 * Check if we should reply based on chat history
 * Prefer local decision using stored candidate.metadata.history (avoid extra backend request).
 */
async function shouldReply() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const mode = values.mode;
    const greeted = values.greeted;
    const viewed = values.viewed;
    const stage = values.stage;
    // if Boss marks this conversation as unread, assume it needs a reply.
    if (viewed === false) return true;
    // For recommend mode, only rely on greeted flag
    if (mode === 'recommend') {
        return !greeted; // if not greeted, we need to reply
    }
    // if the candidate is already passed, don't reply
    if (stage === 'PASS') return false;

    function parseTimestamp(ts) {
        if (!ts) return null;
        const d = new Date(String(ts).replace(' ', 'T'));
        return isNaN(d.getTime()) ? null : d;
    }

    function extractNewUserMessagesAndLastAssistant(history) {
        const newUserMessages = [];
        let lastAssistantMessage = null;
        let lastGeneratedAction = '';
        if (!Array.isArray(history) || history.length === 0) return { newUserMessages, lastAssistantMessage, lastGeneratedAction };

        for (let i = history.length - 1; i >= 0; i--) {
            const msg = history[i] || {};
            const role = msg.role;
            if (role === 'developer') continue;

            const content = msg.content || '';
            if (role === 'assistant') {
                if (!lastGeneratedAction) {
                    const action = msg.action || '';
                    if (action) lastGeneratedAction = String(action).toUpperCase();
                }
                if (!lastAssistantMessage) lastAssistantMessage = msg;
                if (content.includes('æ–¹ä¾¿å‘ä¸€ä»½ç®€å†è¿‡æ¥å—')) continue;
                break;
            }
            if (role === 'user') {
                newUserMessages.unshift(msg);
            }
        }
        return { newUserMessages, lastAssistantMessage, lastGeneratedAction };
    }
    // If greeted and updated_at is less than 10 minutes ago, don't reply
    const updatedAt = new Date(values.updated_at);
    const now = new Date();
    const diffMs = now - updatedAt;
    const diffMinutes = diffMs / (1000 * 60);
    if (greeted && values.updated_at && diffMinutes < 10) {
        return false;
    }
    // Followup: if no new user messages, allow followup after a time window unless last action says WAIT/PASS.
    if (mode === 'followup') {
        const diffDays = diffMinutes / (60 * 24);
        return diffDays >= 3; // followup after 3 days
    }
    // if updated less than 5 minutes, repy on local metadata
    if (diffMinutes < 5) {
        const { newUserMessages, lastAssistantMessage, lastGeneratedAction } = extractNewUserMessagesAndLastAssistant(history);
        if (newUserMessages.length > 0) return true;
        if (lastGeneratedAction === 'WAIT') return false;
    }
    // fallback to backend (check user's new message)
    const response = await fetch('/candidates/should-reply', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(values)
    });
    const should_reply = await window.handleApiResponse(response);
    return should_reply;
}


/**
 * Update candidate data in the form and broadcast update to card
 * This function combines both updateCandidateData and updateCandidateCard
 */
async function updateCandidateData(data) {
    data.saved = true
    data = Object.fromEntries(
        Object.entries(data).filter(([k, v]) => v !== null && v !== undefined && v !== '')
    );
    
    // Get current data from hx-vals
    const currentData = getCandidateData();
    // get the updated fields
    const updates = Object.fromEntries(
        Object.entries(data).filter(([k, v]) => v!== currentData[k] && v !== null && v !== undefined && v !== '')
    );
    // update the resume, analysis and generated_message fields, since these fields are from server, no need to update the stored data
    if (data.resume_text) {
        document.getElementById('resume-textarea-online').value = data.resume_text;
        document.getElementById('resume-textarea-online').textContent = data.resume_text;
        delete data.resume_text;
    }
    if (data.full_resume) {
        document.getElementById('resume-textarea-full').value = data.full_resume;
        document.getElementById('resume-textarea-full').textContent = data.full_resume;
        delete data.full_resume;
    }
    if (data.analysis) {
        // use server-side rendering to render the analysis result
        await htmxAjaxPromise('POST', '/candidates/render-analysis-result', {
            swap: 'innerHTML',
            values: { analysis: JSON.stringify(data.analysis) },
            target: '#analysis-content',
        });
        delete data.analysis;
    }
    if (data.generated_message) {
        const messageTextArea = document.getElementById('message-text')
        messageTextArea.value = data.generated_message;
        messageTextArea.textContent = data.generated_message;
        // delete data.generated_message; //ä¿ç•™generated_messageï¼Œç”¨äºæ›´æ–°UIï¼ŒåŒæ—¶ä¿ç•™last_messageä¸å˜
    }

    // if no updates, return
    if (Object.keys(updates).length === 0) {
        return;
    }
    
    // Merge updates
    const mergedData = { ...currentData, ...data };
    
    // Update hx-vals attribute with merged data
    const container = document.getElementById('candidate-context');
    container.setAttribute('hx-vals', JSON.stringify(mergedData));
    
    // Get identifiers from the updated data for matching
    const identifiers = {
        chat_id: mergedData.chat_id,
        conversation_id: mergedData.conversation_id,
        candidate_id: mergedData.candidate_id,
        index: mergedData.index
    };
    
    // Broadcast the update event to candidate cards
    const event = new CustomEvent('candidate:update', {
        detail: {
            identifiers: identifiers,
            updates: updates,  // Send only the changed fields, not mergedData
        }
    });
    document.dispatchEvent(event);
    
    // Update copy link button visibility if candidate_id was added or updated
    if (updates.candidate_id || mergedData.candidate_id) {
        updateCopyLinkButton();
    }

    // update to cloud 
    if (Object.keys(updates).length > 0) {
        const response = await fetch('/candidates/save', {
            method: 'POST',
            body: JSON.stringify({...identifiers, ...updates}),
        });
        await window.handleApiResponse(response);
    }
}

function getCandidateData(key) {
    const hxVals = document.getElementById('candidate-context').getAttribute('hx-vals');
    if (hxVals) {
        const data = JSON.parse(hxVals);
        // If key is provided, return that property; otherwise return the whole object
        return key !== undefined ? data[key] : data;
    }
    return key !== undefined ? null : {};
}


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 6.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0
    };
}

/**
 * Copy candidate detail link to clipboard
 */
async function copyCandidateLink() {
    const candidate_id = getCandidateData('candidate_id');
    const public_url = window.__public_url;
    
    if (!candidate_id) {
        showToast('æ— æ³•è·å–å€™é€‰äººID', 'error');
        return;
    }
    
    if (!public_url) {
        showToast('Public URLæœªé…ç½®', 'error');
        return;
    }
    
    try {
        const candidate_link = `${public_url}/candidate/${candidate_id}`;
        
        // Copy to clipboard
        await navigator.clipboard.writeText(candidate_link);
        showToast('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
    } catch (error) {
        console.error('Failed to copy link:', error);
        showToast('å¤åˆ¶é“¾æ¥å¤±è´¥', 'error');
    }
}

/**
 * Show/hide copy link button based on candidate_id availability
 */
function updateCopyLinkButton() {
    const candidate_id = getCandidateData('candidate_id');
    const public_url = window.__public_url;
    const copyBtn = document.getElementById('copy-link-btn');
    
    if (copyBtn && candidate_id && public_url) {
        copyBtn.classList.remove('hidden');
        copyBtn.style.display = '';
    } else if (copyBtn) {
        copyBtn.classList.add('hidden');
        copyBtn.style.display = 'none';
    }
}

// ============================================================================
// UI Helper Functions
// ============================================================================

// Use window object to avoid redeclaration errors when HTMX swaps content
if (typeof window.__optimization_jobs_cache === 'undefined') {
    window.__optimization_jobs_cache = null;
}
if (typeof window.__resolved_optimization_job_id === 'undefined') {
    window.__resolved_optimization_job_id = null;
}

async function openOptimizationFeedbackModal() {
    const modal = document.getElementById('optimization-feedback-modal');
    if (!modal) return;
    modal.classList.remove('hidden');
    modal.classList.add('flex');
    await ensureOptimizationJobsLoaded();
    await resolveOptimizationJobIdAndRender();
    renderOptimizationOriginalScores();
    clearOptimizationTargetScores();
}

function closeOptimizationFeedbackModal() {
    const modal = document.getElementById('optimization-feedback-modal');
    if (!modal) return;
    modal.classList.add('hidden');
    modal.classList.remove('flex');
}

function getCurrentAnalysisForOptimization() {
    const container = document.getElementById('analysis-result-container');
    const raw = container?.dataset?.analysis;
    if (!raw) return null;
    try {
        return JSON.parse(raw);
    } catch (e) {
        return null;
    }
}

async function ensureOptimizationJobsLoaded() {
    if (window.__optimization_jobs_cache) return window.__optimization_jobs_cache;
    try {
        const resp = await fetch('/jobs/api/list');
        const data = await resp.json();
        if (!data?.success) throw new Error(data?.error || 'failed');
        window.__optimization_jobs_cache = data.data || [];
    } catch (e) {
        console.error('Failed to load jobs:', e);
        window.__optimization_jobs_cache = [];
    }

    return window.__optimization_jobs_cache;
}

function _normalizeText(s) {
    return (s || '').toString().replace(/\s+/g, '').trim().toLowerCase();
}

function _getOptScoreInputValue(id) {
    const v = document.getElementById(id)?.value;
    if (v === undefined || v === null || v === '') return null;
    const n = parseInt(v, 10);
    if (Number.isNaN(n)) return null;
    return Math.max(1, Math.min(10, n));
}

async function resolveOptimizationJobIdAndRender() {
    window.__resolved_optimization_job_id = null;
    const display = document.getElementById('optimization-job-display');
    const contextJobId = (getCandidateData('job_id') || '').trim();
    const jobApplied = (getCandidateData('job_applied') || '').trim();

    if (!display) return null;

    // Prefer explicit job_id from context (candidates page sets it).
    if (contextJobId) {
        const baseId = contextJobId.replace(/_v\d+$/, '');
        const matchedById = (window.__optimization_jobs_cache || []).find(j => {
            const jBase = (j.base_job_id || (j.job_id || '').replace(/_v\d+$/, '')).trim();
            return jBase === baseId;
        });
        window.__resolved_optimization_job_id = baseId;
        display.textContent = matchedById ? `${matchedById.position || baseId} (${baseId})` : baseId;
        return baseId;
    }

    // Fallback: infer by job_applied -> match job position.
    if (!jobApplied) {
        display.textContent = 'âš ï¸ æ—  job_id/job_appliedï¼Œæ— æ³•åŒ¹é…å²—ä½';
        return null;
    }

    const normalizedJobApplied = _normalizeText(jobApplied);
    const matched = (window.__optimization_jobs_cache || []).find(j => _normalizeText(j.position) === normalizedJobApplied);

    if (!matched) {
        display.textContent = `âš ï¸ æœªæ‰¾åˆ°åŒ¹é…å²—ä½ï¼š${jobApplied}ï¼ˆè¯·å…ˆåœ¨"å²—ä½ç”»åƒ"é¡µåˆ›å»ºåŒåå²—ä½ï¼‰`;
        return null;
    }

    const baseId = matched.base_job_id || (matched.job_id || '').replace(/_v\d+$/, '');
    window.__resolved_optimization_job_id = baseId;
    display.textContent = `${matched.position || jobApplied} (${baseId})`;
    return baseId;
}

function renderOptimizationOriginalScores() {
    const analysis = getCurrentAnalysisForOptimization();
    if (!analysis) {
        const label = document.getElementById('opt-original-scores');
        if (label) label.textContent = 'å½“å‰åˆ†æ•°ï¼šæš‚æ— ï¼ˆè¯·å…ˆå®Œæˆåˆ†æï¼‰';
        return;
    }

    const overall = analysis.overall ?? null;
    const skill = analysis.skill ?? null;
    const background = analysis.background ?? null;
    const startupFit = analysis.startup_fit ?? null;

    const label = document.getElementById('opt-original-scores');
    if (label) {
        label.textContent = `å½“å‰åˆ†æ•°ï¼šoverall=${overall ?? '-'}ï¼Œskill=${skill ?? '-'}ï¼Œbackground=${background ?? '-'}ï¼Œstartup_fit=${startupFit ?? '-'}`;
    }
}

function clearOptimizationTargetScores() {
    const ids = ['opt-score-overall', 'opt-score-skill', 'opt-score-background', 'opt-score-startup-fit'];
    for (const id of ids) {
        const el = document.getElementById(id);
        if (el) el.value = '';
    }
}

async function submitOptimizationFeedback() {
    const suggestion = document.getElementById('optimization-suggestion')?.value?.trim() || '';
    const analysis = getCurrentAnalysisForOptimization();
    const candidateId = getCandidateData('candidate_id');
    const conversationId = getCandidateData('conversation_id');
    const candidateName = getCandidateData('name') || '';
    const jobApplied = getCandidateData('job_applied') || '';
    const currentMetadata = getCandidateData('metadata') || {};

    const jobId = window.__resolved_optimization_job_id || (await resolveOptimizationJobIdAndRender());
    if (!jobId) {
        showToast('æ— æ³•åŒ¹é…å²—ä½ï¼šè¯·å…ˆåœ¨â€œå²—ä½ç”»åƒâ€é¡µåˆ›å»ºä¸ job_applied åŒåçš„å²—ä½', 'error');
        return;
    }
    if (!analysis) {
        showToast('æš‚æ— å¯ç”¨çš„åˆ†æç»“æœï¼Œè¯·å…ˆå®Œæˆåˆ†æåå†åé¦ˆ', 'error');
        return;
    }
    if (!candidateId || !conversationId) {
        showToast('å€™é€‰äººä¿¡æ¯ä¸å®Œæ•´ï¼ˆç¼ºå°‘ candidate_id / conversation_idï¼‰', 'error');
        return;
    }
    if (!suggestion || suggestion.length < 5) {
        showToast('è¯·å¡«å†™ä¼˜åŒ–å»ºè®®ä¸ç†ç”±ï¼ˆè‡³å°‘5ä¸ªå­—ï¼‰', 'error');
        return;
    }

    const targetScores = {
        overall: _getOptScoreInputValue('opt-score-overall'),
        skill: _getOptScoreInputValue('opt-score-skill'),
        background: _getOptScoreInputValue('opt-score-background'),
        startup_fit: _getOptScoreInputValue('opt-score-startup-fit'),
    };

    const hasAnyScore = Object.values(targetScores).some(v => v !== null);
    if (!hasAnyScore) {
        showToast('è¯·è‡³å°‘å¡«å†™ä¸€ä¸ªç›®æ ‡åˆ†æ•°ï¼ˆ1-10ï¼‰ï¼›æœªå¡«å†™è¡¨ç¤ºâ€œä¸å˜/ä¸éœ€è¦ä¼˜åŒ–â€', 'error');
        return;
    }

    const body = {
        job_id: jobId,
        candidate_id: candidateId,
        conversation_id: conversationId,
        candidate_name: candidateName,
        job_applied: jobApplied,
        current_analysis: analysis,
        target_scores: targetScores,
        suggestion: suggestion,
    };

    try {
        const resp = await fetch('/jobs/api/optimizations/add', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
        });
        const result = await resp.json();
        if (!result?.success) {
            showToast(result?.error || 'ä¿å­˜å¤±è´¥', 'error');
            return;
        }
        showToast('å·²åŠ å…¥ä¼˜åŒ–æ¸…å•', 'success');
        
        // Also mark as contacted since feedback was given
        await updateCandidateData({ 
            metadata: { 
                contacted: true 
            } 
        });
        
        closeOptimizationFeedbackModal();
    } catch (e) {
        console.error(e);
        showToast('ä¿å­˜å¤±è´¥ï¼ˆç½‘ç»œ/æœåŠ¡å¼‚å¸¸ï¼‰', 'error');
    }
}

// ===========================================
// Feedback Action Functions
// ===========================================

async function markContacted() {
    try {
        await updateCandidateData({ 
            metadata: { 
                contacted: true 
            } 
        });
        showToast('å·²æ ‡è®°ä¸ºå·²è”ç³»', 'success');
    } catch (e) {
        console.error('Failed to mark contacted:', e);
        showToast('æ“ä½œå¤±è´¥', 'error');
    }
}

function openRejectModal() {
    const modal = document.getElementById('rejection-feedback-modal');
    if (modal) {
        // Clear previous input
        const textarea = document.getElementById('rejection-reason');
        if (textarea) textarea.value = '';
        
        modal.classList.remove('hidden');
        modal.classList.add('flex');
    }
}

function closeRejectModal() {
    const modal = document.getElementById('rejection-feedback-modal');
    if (modal) {
        modal.classList.add('hidden');
        modal.classList.remove('flex');
    }
}

async function submitRejectReason() {
    const reason = document.getElementById('rejection-reason')?.value?.trim();
    if (!reason) {
        showToast('è¯·å¡«å†™æ”¾å¼ƒåŸå› ', 'error');
        return;
    }
    
    try {
        await updateCandidateData({ 
            metadata: { 
                contacted: true,
                candidate_reject_reason: reason
            } 
        });
        showToast('å·²è®°å½•æ”¾å¼ƒåŸå› ', 'success');
        closeRejectModal();
    } catch (e) {
        console.error('Failed to submit reject reason:', e);
        showToast('æäº¤å¤±è´¥', 'error');
    }
}

function switchResumeTab(tab) {
    // Hide all tab contents
    document.getElementById('tab-content-online').classList.add('hidden');
    document.getElementById('tab-content-full').classList.add('hidden');
    
    // Remove active styles from all tabs
    document.getElementById('tab-online').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-online').classList.add('text-gray-600');
    document.getElementById('tab-full').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-full').classList.add('text-gray-600');
    
    // Show/hide fetch buttons based on active tab
    const fetchOnlineBtn = document.getElementById('fetch-online-resume-btn');
    const fetchFullBtn = document.getElementById('fetch-full-resume-btn');
    
    // Show selected tab content and activate tab button
    if (tab === 'online') {
        document.getElementById('tab-content-online').classList.remove('hidden');
        document.getElementById('tab-online').classList.remove('text-gray-600');
        document.getElementById('tab-online').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show online resume button, hide full resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.remove('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.add('hidden');
    } else if (tab === 'full') {
        document.getElementById('tab-content-full').classList.remove('hidden');
        document.getElementById('tab-full').classList.remove('text-gray-600');
        document.getElementById('tab-full').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show full resume button, hide online resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.add('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.remove('hidden');
    }
}

// Run initialization when partial is loaded via HTMX
// This ensures process_candidate() runs on each HTMX swap
(function () {
    // Update copy link button on initial load
    updateCopyLinkButton();
    
    // å½“åœ¨æœç´¢é¡µé¢æŸ¥çœ‹å€™é€‰äººè¯¦æƒ…æ—¶ï¼Œä½¿ç”¨ readonly æ¨¡å¼ï¼Œä¸åº”è¯¥æ‰§è¡Œ
    const viewMode = window.__candidate_detail_view_mode || 'interactive';
    if (viewMode === 'readonly') return;
    
    // Function to run process_candidate with proper error handling
    async function runProcessCandidate() {
        // Set initial tab state - show online tab if resume_text exists, otherwise show full tab
        const fullTextarea = document.getElementById('resume-textarea-full');
        switchResumeTab( fullTextarea?.value?.trim().length > 100 ? 'full' : 'online');
        await process_candidate();
    }
    
    // Use setTimes paused when the tab is not visible, but setTimeout is only throttled
    setTimeout(() => {
        runProcessCandidate();
    }, 100);
})();

</script>
