<!-- Candidate detail view with automatic workflow 
    the passed data:
    - "analysis": data.pop("analysis"),
    - "generated_message": data.pop("last_message"),
    - "resume_text": data.pop("resume_text"),
    - "full_resume": data.pop("full_resume"),
    - "candidate": data,
-->
<div class="space-y-6">
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div>
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <p class="text-gray-600">{{ candidate.job_applied or 'æœªæŒ‡å®šå²—ä½' }}</p>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>
    {% if candidate.name and ('å…ˆç”Ÿ' in candidate.name or 'å¥³å£«' in candidate.name) and not candidate.chat_id%}
        <div class="flex items-center space-x-2 bg-yellow-100 border-l-4 border-yellow-400 text-yellow-800 px-4 py-2 rounded shadow-sm my-2">
            <span>âš ï¸</span>
            <span>
                æ£€æµ‹åˆ°å€™é€‰äººå§“ååŒ…å«<strong>ã€Œå…ˆç”Ÿã€</strong>æˆ–<strong>ã€Œå¥³å£«ã€</strong>ï¼Œå¯¼è‡´æ•°æ®å¯èƒ½é‡å¤ï¼Œè¯·è®¤çœŸæ£€æŸ¥ä»¥ä¸‹å†…å®¹æ˜¯å¦å’Œæ‹›è˜ç½‘ç«™ä¸€è‡´ã€‚å¦‚æœä¸ä¸€è‡´ï¼Œè¯·é‡æ–°è·å–ç®€å†ã€‚
            </span>
        </div>
    {% endif %}

    <!-- Hidden context for HTMX requests - using JSON to preserve types -->
    <div id="candidate-context" class="hidden" hx-vals='{{ candidate | tojson | safe }}'></div>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <!-- <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div> -->
        <!-- Tab Navigation -->
        <div class="flex border-b bg-gray-100">
            <button id="tab-online" onclick="switchResumeTab('online')" 
                    class="px-4 py-2 font-medium text-sm transition-colors bg-white border-b-2 border-blue-500 text-blue-600">
                åœ¨çº¿ç®€å†
            </button>
            <button id="tab-full" onclick="switchResumeTab('full')" 
                    class="px-4 py-2 font-medium text-sm transition-colors text-gray-600 hover:text-gray-800">
                å®Œæ•´ç®€å†
            </button>
        </div>
        <!-- Tab Content -->
        <div id="resume-content" class="p-2"> 
            <!-- Online Resume Tab -->
            <div id="tab-content-online" class="tab-content">
                <div class="mb-2 flex justify-end">
                    <button 
                        onclick="fetchOnlineResume()"
                        class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1">
                        <span>ğŸ”„</span>
                        <span>é‡æ–°è·å–åœ¨çº¿ç®€å†</span>
                    </button>
                </div>
                <div id="resume-online-container">
                    <textarea id="resume-textarea-online" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {% if resume_text %} {{ resume_text }} {% else %} â³ æ­£åœ¨åŠ è½½åœ¨çº¿ç®€å†... {% endif %}
                    </textarea>
                </div>
            </div>
            <!-- Full Resume Tab -->
            <div id="tab-content-full" class="tab-content hidden">
                <div class="mb-2 flex justify-end">
                    <button 
                        onclick="fetchFullResume().catch(err => console.warn('Re-fetch failed:', err))"
                        class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1">
                        <span>ğŸ”„</span>
                        <span>é‡æ–°è·å–å®Œæ•´ç®€å†</span>
                    </button>
                </div>
                <div id="resume-full-container">
                    <textarea id="resume-textarea-full" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {% if full_resume %} {{ full_resume }} {% else %} â³ æ­£åœ¨åŠ è½½å®Œæ•´ç®€å†... {% endif %}
                    </textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
        </div>
        <div id="analysis-content" class="p-2">
            {% if analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center py-8 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only if score >= borderline) -->
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
        </div>
        <div id="message-content" class="p-2">
            {% if generated_message not in ['', 'None', 'null', None] %}
            <textarea id="message-text" name="generated_message" class="w-full h-32 p-2 border rounded-lg">{{ generated_message }}</textarea>
            {% else %}
            <div class="text-center py-8 text-gray-500">â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...</div>
            {% endif %}
        </div>
        <div class="flex p-2 gap-2">
            <button onclick="greetAndSendMessage()"
                    class="px-4 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-800">
                ğŸ“¤ æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
            </button>
            <button hx-post="/candidates/pass"
                    hx-include="#candidate-context"
                    hx-target="body"
                    hx-swap="none"
                    class="px-4 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-800">
                âŒ PASS
            </button>
            <button onclick="generateMessage()"
                    class="px-3 py-1 bg-indigo-600 text-white text-sm rounded hover:bg-indigo-800">
                ğŸ”„ é‡æ–°ç”Ÿæˆæ¶ˆæ¯
            </button>
        </div>
    </div>

</div>

<!-- Centralized Candidate Analysis & Workflow Logic -->
<script>

async function process_candidate() {
    const getIdentifiers = () => {
        const candidate = getCandidateData();
        return {
            candidate_id: candidate.candidate_id,
            chat_id: candidate.chat_id,
            conversation_id: candidate.conversation_id,
            job_applied: candidate.job_applied,
            name: candidate.name,
        };
    };
    const { candidate_id, chat_id, conversation_id, job_applied, name } = getIdentifiers();
    const mode = getCandidateData('mode');
    // Disable cards during processing
    disableAllCards();
    try {
        // Step 1: Ensure resume is loaded
        const online_resume_div = document.getElementById('resume-textarea-online');
        if (!online_resume_div?.value || online_resume_div?.value.includes('â³') || online_resume_div?.value.length < 100) {
            await fetchOnlineResume();
        }
        
        // Step 2: Initialize chat if no conversation_id
        if (!conversation_id) {
            await initializeNewChat();
        }
        
        // Step 3: Start analysis if pending
        const analysisDiv = document.getElementById('analysis-content');
        if (analysisDiv.textContent.includes('â³')) {
            await startAnalysis();
        }
        
        // Step 4: Check threshold and determine stage (sequential: chat â†’ borderline â†’ seek)
        const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
        let analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
        let is_full_analysis = analysis.resume_type === 'full';
        let current_score = analysis?.overall || 0;
        const { chat_threshold, borderline_threshold, seek_threshold } = getThresholdValues();
        
        let newStage = 'PASS'; // Default to PASS
        // Step 4a: Check chat_threshold - generate message if above
        if (current_score >= chat_threshold) {
            newStage = 'CHAT';
            const messageDiv = document.getElementById('message-content');
            if (messageDiv?.textContent?.includes('â³')) {
                await generateMessage();
            }
            
            // Step 4b: Check borderline_threshold - try to get full resume and re-analyze
            if (current_score >= borderline_threshold) {
                newStage = 'SEEK';
                
                // For chat mode, try to get full resume and re-analyze
                if (mode !== 'recommend') {
                    debugger;
                    let full_resume_text = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                    if (full_resume_text.includes('â³')) {
                        await fetchFullResume();
                        full_resume_text = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                    }
                    // check if analysis is from full resume
                    if (! is_full_analysis && full_resume_text.length > 100 && !full_resume_text.includes('â³')) {
                        await startAnalysis();
                        // Re-read analysis after full resume analysis
                        const updated_analysis_container = document.querySelector('#analysis-content #analysis-result-container');
                        analysis = JSON.parse(updated_analysis_container.getAttribute('data-analysis'));
                        is_full_analysis = analysis.resume_type === 'full';
                        current_score = analysis?.overall || current_score;
                    }
                    // Step 4c: Send notification if analysis was updated
                    if (is_full_analysis && current_score >= borderline_threshold) {
                        await sendDingNotification(analysis, name, getCandidateData('job_applied'));
                    }
                    // Step 4d: Check seek_threshold - request contact if above
                    if (is_full_analysis && current_score >= seek_threshold) {
                        newStage = 'CONTACT';
                        await requestContact();
                    }
                }else{
                    // For recommend mode, greet and send message
                    await greetAndSendMessage();
                    await sendDingNotification(analysis, name, getCandidateData('job_applied'));
                }
            }
            
        } else {
            showToast(`åŒ¹é…åº¦: ${current_score}, æœªè¾¾æœ€ä½å€¼: ${chat_threshold}`, 'info');
            newStage = 'PASS';
        }
        
        // Update stage and card
        updateCandidateData({
            stage: newStage,
            viewed: true,
            score: current_score
        });
        
        // Emit success event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-complete', {
            detail: {
                identifiers: getIdentifiers()
            }
        });
        setTimeout(() => {
            document.dispatchEvent(event);
        }, 100);
        
    } catch (error) {
        console.error('Error processing candidate:', error);
        showToast(`å¤„ç†å€™é€‰äººæ—¶å‡ºé”™: ${error.message || String(error)}`, 'error');
        // Emit error event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-error', {
            detail: {
                identifiers: getIdentifiers(),
                error: error.message || String(error)
            }
        });
        document.dispatchEvent(event);
        // Don't re-throw - let finally handle cleanup
    } finally {
        // Always re-enable cards after processing, even on error
        enableAllCards();
    }
}

/**
 * Send DingTalk notification when candidate score exceeds borderline threshold
 */
async function sendDingNotification(analysis, candidateName, jobApplied) {
    try {
        // Format analysis result in markdown
        const markdownMessage = `**å€™é€‰äºº**: ${candidateName}
**å²—ä½**: ${jobApplied}

**è¯„åˆ†ç»“æœ**:
- æŠ€èƒ½åŒ¹é…åº¦: ${analysis.skill || 'N/A'}/10
- åˆ›ä¸šå¥‘åˆåº¦: ${analysis.startup_fit || 'N/A'}/10
- åŸºç¡€èƒŒæ™¯: ${analysis.background || 'N/A'}/10
- **ç»¼åˆè¯„åˆ†: ${analysis.overall || 'N/A'}/10**

**åˆ†ææ€»ç»“**:
${analysis.summary || 'æš‚æ— '}

**è·Ÿè¿›å»ºè®®**:
${analysis.followup_tips || 'æš‚æ— '}`;

        // Get candidate data to check notified field
        const candidateData = getCandidateData();
        const notified = candidateData.notified;
        
        // Skip if already notified
        if (notified) {
            console.log('Candidate already notified, skipping notification');
            return;
        }
        
        const title = `å€™é€‰äºº ${candidateName} é€šè¿‡åˆæ­¥ç­›é€‰`;
        
        const formData = new FormData(candidateData);
        formData.append('title', title);
        formData.append('message', markdownMessage);
        
        const response = await fetch('/candidates/notify', {
            method: 'POST',
            body: formData
        });
        
        const result = await response.json();
        if (result.success) {
            console.log('DingTalk notification sent successfully');
            // Update local candidate data to reflect notified status
            updateCandidateData({ notified: true });
        } else {
            console.error('Failed to send DingTalk notification:', result.error);
        }
    } catch (error) {
        console.error('Error sending DingTalk notification:', error);
        // Don't throw - notification failure shouldn't block processing
    }
}

async function fetchOnlineResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    const values = getCandidateData();
    await htmxAjaxPromise('POST', '/candidates/fetch-online-resume', {
        target: '#resume-online-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to online tab after fetch
    switchResumeTab('online');
}

async function fetchFullResume() {
    showToast('æŠ“å–å®Œæ•´ç®€å†...', 'info');
    const values = getCandidateData();
    const mode = values.mode;
    if (mode === 'recommend') {
        const errorMsg = 'å®Œæ•´ç®€å†ä¸æ”¯æŒæ¨èæ¨¡å¼';
        showToast(errorMsg, 'warning');
        throw new Error(errorMsg);
    }

    await htmxAjaxPromise('POST', '/candidates/fetch-full-resume', {
        target: '#resume-full-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to full tab after fetch
    switchResumeTab('full');
}

function switchResumeTab(tab) {
    // Hide all tab contents
    document.getElementById('tab-content-online').classList.add('hidden');
    document.getElementById('tab-content-full').classList.add('hidden');
    
    // Remove active styles from all tabs
    document.getElementById('tab-online').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-online').classList.add('text-gray-600');
    document.getElementById('tab-full').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-full').classList.add('text-gray-600');
    
    // Show selected tab content and activate tab button
    if (tab === 'online') {
        document.getElementById('tab-content-online').classList.remove('hidden');
        document.getElementById('tab-online').classList.remove('text-gray-600');
        document.getElementById('tab-online').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    } else if (tab === 'full') {
        document.getElementById('tab-content-full').classList.remove('hidden');
        document.getElementById('tab-full').classList.remove('text-gray-600');
        document.getElementById('tab-full').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    }
}

async function generateMessage() {
    showToast('ç”Ÿæˆæ¶ˆæ¯...', 'info');
    const values = getCandidateData();
    values.purpose = 'CHAT_ACTION';

    const result = await htmxAjaxPromise('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        values: values
    });
    console.log('Generated message:', result);
    updateCandidateData({generated_message: result});
}

async function greetAndSendMessage() {
    showToast('æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯...', 'info');
    const message_textarea = document.getElementById('message-text');
    const message = message_textarea.value.trim();
    const stage = getCandidateData('stage');
    const greeted = getCandidateData('greeted');
    
    // Check if already greeted (stage is CHAT, SEEK, or CONTACT, or greeted flag is true)
    if (greeted) {
        showToast('å·²ç»æ‰“æ‹›å‘¼è¿‡äº†ï¼Œä¸èƒ½é‡å¤æ‰“æ‹›å‘¼', 'info');
        return 'å·²ç»æ‰“æ‹›å‘¼è¿‡äº†';
    }
    
    try {
        const values = getCandidateData();
        values.message = message;
        
        await htmxAjaxPromise('POST', '/candidates/send', {
            target: '#message-content',
            swap: 'none',
            values: values
        });
        showToast('æ¶ˆæ¯å‘é€æˆåŠŸï¼', 'success');
        // Update to CHAT stage (not GREET, as GREET is not in STAGES)
        const currentStage = getCandidateData('stage');
        updateCandidateData({
            stage: currentStage || 'CHAT',
            greeted: true
        });
    } catch (err) {
        showToast('æ¶ˆæ¯å‘é€å¤±è´¥ï¼', 'error');
        throw err;
    }
}


/**
 * Start analysis (current flow)
 */
async function startAnalysis() {
    const resume_text = document.getElementById('resume-textarea-online')?.value?.trim() || '';
    const full_resume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
    const has_full_resume = !full_resume.includes('â³') && full_resume.length > 0;
    const has_online_resume = !resume_text.includes('â³') && resume_text.length > 0;
    
    if (has_full_resume) {
        showToast('æ­£åœ¨åˆ†æå®Œæ•´ç®€å†...', 'info');
    } else if(has_online_resume) {
        showToast('æ­£åœ¨åˆ†æåœ¨çº¿ç®€å†...', 'info');
    } else {
        showToast('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†', 'error');
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
    }
    
    const values = getCandidateData();
    values.resume_text = resume_text.includes('â³') ? '' : resume_text;
    values.full_resume = full_resume.includes('â³') ? '' : full_resume;
    
    const result = await htmxAjaxPromise('POST', '/candidates/analyze', {
        target: '#analysis-content',
        swap: 'innerHTML',
        values: values
    });
    console.log('Analysis completed:', result.overall);
    // Extract analysis from data attribute
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    updateCandidateData({score: analysis?.overall});
}

async function requestContact() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const mode = values.mode;
    
    // Skip contact request for recommend mode (no chat_id available)
    if (mode === 'recommend' || !chat_id) {
        showToast('æ¨èæ¨¡å¼ä¸æ”¯æŒè¯·æ±‚è”ç³»æ–¹å¼', 'info');
        return;
    }
    
    showToast('è¯·æ±‚è”ç³»æ–¹å¼...', 'info');
    
    // Endpoint expects JSON body with embed=True format
    const response = await fetch('/chat/contact/request', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ chat_id: chat_id })
    });
    const data = await window.handleApiResponse(response);
    console.log('Contact requested:', data);
    
    // Update to CONTACT stage if contact was successfully obtained
    if (data && data.success !== false) {
        updateCandidateData({stage: 'CONTACT'});
    }
}

/**
 * Initialize new chat - reads all data from DOM
 */
async function initializeNewChat() {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    const candidate = getCandidateData();
    //always use online resume at first time (full resume is not available at first time)
    const resume_text = document.getElementById('resume-textarea-online')?.value;
    if (!resume_text) {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
        return;
    }
    candidate.resume_text = resume_text;

    const formData = new FormData();
    for (const [key, value] of Object.entries(candidate)) {
        if (value !== null && value !== undefined) {
            formData.append(key, value);
        }
    }

    const response = await fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    });
    const data = await window.handleApiResponse(response);
    console.log('Chat initialized:', data);
    updateCandidateData({
        ...data,
        saved: true
    });
    return data;
}


// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================

/**
 * Update candidate data in the form and broadcast update to card
 * This function combines both updateCandidateData and updateCandidateCard
 */
function updateCandidateData(record) {
    const container = document.getElementById('candidate-context');
    
    // Get current data from hx-vals
    const currentData = getCandidateData();
    
    // Merge updates
    const mergedData = { ...currentData, ...record };
    
    // Update hx-vals attribute with merged data
    container.setAttribute('hx-vals', JSON.stringify(mergedData));
    
    // Broadcast update to card (filter out null/undefined, keep false values)
    const updates = Object.fromEntries(
        Object.entries(record).filter(([k, v]) => v!== currentData[k] && v !== null && v !== undefined && v !== '')
    );
    
    if (Object.keys(updates).length > 0) {
        console.log('updateCandidateData:', updates);
        // Get identifiers from the updated data for matching
        const chat_id = mergedData.chat_id;
        const conversation_id = mergedData.conversation_id;
        const candidate_id = mergedData.candidate_id;
        const name = mergedData.name;
        const job_applied = mergedData.job_applied;
        
        // Broadcast the update event
        const event = new CustomEvent('candidate:update', {
            detail: {
                identifiers: {
                    chat_id,
                    conversation_id,
                    candidate_id,
                    name,
                    job_applied
                },
                updates
            }
        });
        document.dispatchEvent(event);
    }else{
        return;
    }
    // update to cloud - use values from hx-vals
    htmx.ajax('POST', '/candidates/save', {
        values: mergedData,
        swap: 'none',
    });
}

function getCandidateData(key) {
    const container = document.getElementById('candidate-context');
    const hxVals = container.getAttribute('hx-vals');
    if (hxVals) {
        const data = JSON.parse(hxVals);
        // If key is provided, return that property; otherwise return the whole object
        return key !== undefined ? data[key] : data;
    }
    return key !== undefined ? null : {};
}


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 5.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0,
        seek_threshold: parseFloat(document.getElementById('threshold-seek')?.value) || 9.0
    };
}

// ============================================================================
// HTMX Promise Wrapper
// ============================================================================

/**
 * Wrap htmx.ajax to return a Promise that resolves when swap completes
 */
 function htmxAjaxPromise(method, url, options) {
    return new Promise((resolve, reject) => {
        const target = document.querySelector(options.target);
        if (!target) {
            reject(new Error(`Target element not found: ${options.target}`));
            return;
        }
        
        // Listen for swap completion
        const afterSwap = (evt) => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            resolve(target.textContent.trim());
        };
        
        const onError = (evt) => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            const errorMsg = evt.detail?.error || evt.detail?.message || 'HTMX request failed';
            reject(new Error(errorMsg));
        };
        
        target.addEventListener('htmx:afterSwap', afterSwap, { once: true });
        target.addEventListener('htmx:responseError', onError, { once: true });
        
        // Trigger the ajax call
        htmx.ajax(method, url, options);
    });
}

// Trigger workflow when this partial is loaded via HTMX
// Since this script runs when HTMX swaps content, we can call it directly
// Use requestAnimationFrame to ensure DOM is ready
requestAnimationFrame(() => {
    // Set initial tab state - show online tab if resume_text exists, otherwise show full tab
    const fullTextarea = document.getElementById('resume-textarea-full');
    
    if (fullTextarea?.value?.trim().length > 100) {
        switchResumeTab('full');
    } else {
        // Default to online tab
        switchResumeTab('online');
    }
    
    // Wrap process_candidate in error handling to ensure cards are re-enabled
    process_candidate().catch(error => {
        console.error('Unhandled error in process_candidate:', error);
        showToast(`å¤„ç†å€™é€‰äººæ—¶å‡ºé”™: ${error.message || error}`, 'error');
        // Ensure cards are re-enabled even if error wasn't caught by finally
        enableAllCards();
    });
});

</script>

</script>
