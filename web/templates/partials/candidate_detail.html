<!-- Candidate detail view with automatic workflow -->
<div class="space-y-6">
    
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div>
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <p class="text-gray-600">{{ candidate.job_applied or 'æœªæŒ‡å®šå²—ä½' }}</p>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>

    <!-- Hidden context for HTMX requests -->
    <form id="candidate-context" class="hidden">
        <input type="hidden" name="chat_id" value="{{ candidate.chat_id or '' }}">
        <input type="hidden" name="mode" value="{{ candidate.mode}}">
        <input type="hidden" name="name" value="{{ candidate.name}}">
        <input type="hidden" name="assistant_id" value="{{ assistant_id }}">
        <input type="hidden" name="job_id" value="{{ job_id }}">
        <input type="hidden" name="job_applied" value="{{ job_applied or candidate.job_applied }}">
        <input type="hidden" name="conversation_id" value="{{ candidate.conversation_id or candidate.thread_id or '' }}">
        <input type="hidden" name="index" value="{{ candidate.index if candidate.index is not none else '' }}">
    </form>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div>
        {% if candidate.resume_text or candidate.full_resume %}
        <textarea readonly class="w-full h-64 p-4 bg-gray-50 border rounded-lg font-mono text-sm">{{ candidate.full_resume or candidate.resume_text }}</textarea>
        {% else %}
        <div id="resume-content" class="text-center py-8 text-gray-500" 
            hx-post="{% if candidate.mode == 'recommend' %}/candidates/fetch-recommend-resume{% else %}/candidates/fetch-online-resume{% endif %}" 
            hx-trigger="load"
            hx-include="#candidate-context"
            hx-target="#resume-content"
            hx-swap="innerHTML"
            hx-on::after-swap="handleResumeLoaded()"
            hx-on::htmx:after-swap="handleResumeLoaded()"> 
            â³ æ­£åœ¨åŠ è½½ç®€å†...
        </div>
        {% endif %}
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
        </div>
        <div id="analysis-content" 
             class="p-4"
             hx-on::after-swap="handleAnalysisComplete()">
            {% if candidate.analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center py-8 text-gray-500" id="analysis-trigger">
                â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...
            </div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only if score >= borderline) -->
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
        </div>
        <div id="message-content" 
             class="p-4"
             hx-on::after-swap="handleMessageGenerated()">
            {% if generated_message %}
            <div class="space-y-4">
                <textarea id="message-text" name="message" class="w-full h-32 p-4 border rounded-lg">{{ generated_message }}</textarea>
                <div class="flex space-x-2">
                    <button hx-post="/candidates/send"
                            hx-include="#candidate-context,#message-text"
                            class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">
                        ğŸ“¤ å‘é€æ¶ˆæ¯
                    </button>
                    <button hx-post="/candidates/pass"
                            hx-include="#candidate-context"
                            class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">
                        â­ï¸ PASS
                    </button>
                </div>
            </div>
            {% else %}
            <div class="text-center py-8 text-gray-500">åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡å°†è‡ªåŠ¨ç”Ÿæˆ...</div>
            {% endif %}
        </div>
    </div>


    <!-- Manual Actions (always available) -->
    <div class="bg-gray-50 rounded-lg p-4 space-y-2">
        <h3 class="font-bold text-gray-800 mb-2">ğŸ”§ æ‰‹åŠ¨æ“ä½œ</h3>
        <div class="flex flex-wrap gap-2">
            <button hx-post="{% if candidate.mode == 'recommend' %}/candidates/fetch-recommend-resume{% else %}/candidates/fetch-online-resume{% endif %}"
                    hx-include="#candidate-context"
                    hx-target="#resume-content"
                    hx-swap="innerHTML"
                    class="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">
                ğŸ”„ é‡æ–°è·å–ç®€å†
            </button>
            <button hx-post="/candidates/analyze"
                    hx-include="#candidate-context"
                    hx-target="#analysis-content"
                    hx-swap="innerHTML"
                    onclick="this.setAttribute('hx-vals', JSON.stringify({resume_text: document.querySelector('#resume-content textarea')?.value || ''}))"
                    class="px-3 py-1 bg-purple-600 text-white text-sm rounded hover:bg-purple-700">
                ğŸ”„ é‡æ–°åˆ†æ
            </button>
            <button hx-post="/candidates/generate-message"
                    hx-include="#candidate-context"
                    hx-target="#message-content"
                    hx-swap="innerHTML"
                    hx-vals='{"purpose": "CHAT_ACTION"}'
                    class="px-3 py-1 bg-indigo-600 text-white text-sm rounded hover:bg-indigo-700">
                ğŸ”„ é‡æ–°ç”Ÿæˆæ¶ˆæ¯
            </button>
        </div>
    </div>

</div>

<!-- Mode-specific record check logic -->
<script>
// ============================================================================
// Centralized Candidate Analysis & Workflow Logic
// ============================================================================

function getThresholdValues() {
    return {
        chat: parseFloat(document.getElementById('threshold-chat')?.value) || 5.0,
        borderline: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0,
        seek: parseFloat(document.getElementById('threshold-seek')?.value) || 9.0
    };
}

function handleResumeLoaded() {
    const textarea = document.querySelector('#resume-content textarea');
    if (!textarea?.value) return;
    
    const form = document.getElementById('candidate-context');
    const resume_text = textarea.value;
    const mode = form.querySelector('input[name="mode"]').value;
    const chat_id = form.querySelector('input[name="chat_id"]').value;
    const name = form.querySelector('input[name="name"]').value;
    const job_id = form.querySelector('input[name="job_id"]').value;
    console.log('handleResumeLoaded: job_id', job_id);
    initializeNewChat(mode, chat_id, job_id, name, resume_text)
    .then((conversation_id) => {
        updateFormData({'conversation_id': conversation_id});
        showToast('ç®€å†åŠ è½½å®Œæˆï¼Œæ­£åœ¨åˆ†æ...', 'success');
        startAnalysis();
    });
}


// Handle analysis completion after HTMX swap
// This function is called via hx-on::after-swap on #analysis-content element
function handleAnalysisComplete() {
    const analysisDiv = document.querySelector('#analysis-content #analysis-result-container');
    if (!analysisDiv) return;
    
    const analysis = JSON.parse(analysisDiv.getAttribute('data-analysis'));
    const mode = analysisDiv.getAttribute('data-mode');
    const conversation_id = analysisDiv.getAttribute('data-conversation-id');
    const chat_id = analysisDiv.getAttribute('data-chat-id');
    const name = analysisDiv.getAttribute('data-name');
    const job_applied = analysisDiv.getAttribute('data-job-applied');
    const resumeTextarea = document.querySelector('#resume-section textarea');
    const resume_text = resumeTextarea?.value || analysisDiv.getAttribute('data-resume-text');
    
    const { chat_threshold, borderline_threshold, seek_threshold } = getThresholdValues();
    const overall_score = analysis.overall || 0;
    
    updateCandidateCard(chat_id, conversation_id, { score: overall_score });
    
    if (overall_score >= chat_threshold) {
        showToast(`è¯„åˆ† ${overall_score} >= ${chat_threshold}ï¼Œç”Ÿæˆæ¶ˆæ¯...`, 'success');
        generateMessage(mode, conversation_id, job_applied, chat_id, name, resume_text, analysis);
        if (overall_score >= borderline_threshold) {
            requestFullResume(mode, chat_id, job_applied);
        }
    } else {
        showToast(`è¯„åˆ† ${overall_score} < ${chat}ï¼Œä¸æ¨è`, 'warning');
    }
}

function generateMessage(mode, conversation_id, job_applied, chat_id, name, resume_text, analysis) {

    showToast('ç”Ÿæˆæ¶ˆæ¯...', 'info');
    htmx.ajax('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        values: { mode, conversation_id: conversation_id, job_applied: job_applied, purpose: 'CHAT_ACTION', chat_id: chat_id }
    });
}

function handleMessageGenerated() {
    // Called via hx-on::after-swap when message is generated
    const messageTarget = document.getElementById('message-content');
    const analysis = JSON.parse(messageTarget.getAttribute('data-analysis') || '{}');
    const mode = messageTarget.getAttribute('data-mode');
    const conversation_id = messageTarget.getAttribute('data-conversation-id');
    const chat_id = messageTarget.getAttribute('data-chat-id');
    const name = messageTarget.getAttribute('data-name');
    const job_applied = messageTarget.getAttribute('data-job-applied');
    
    // Get resume_text from textarea
    const resumeTextarea = document.querySelector('#resume-section textarea');
    const resume_text = resumeTextarea?.value || '';
    
    // Save candidate after a short delay to ensure message is rendered
    setTimeout(() => {
        saveCandidateToCloud(mode, conversation_id, chat_id, name, job_applied, resume_text, analysis);
    }, 500);
}

function requestFullResume(mode, chat_id, job_applied) {
    if (!chat_id || !['chat', 'greet', 'followup'].includes(mode)) return;
    
    fetch('/chat/resume/request_full', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({chat_id: chat_id})
    })
    .then(handleApiResponse)
    .then(data => showToast(data ? 'âœ… å·²è¯·æ±‚å®Œæ•´ç®€å†' : 'è¯·æ±‚å¤±è´¥', data ? 'success' : 'error'))
    .catch(err => {
        console.error('Request full resume failed:', err);
        showToast(`è¯·æ±‚å®Œæ•´ç®€å†å¤±è´¥: ${err.message}`, 'error');
    });
}

function saveCandidateToCloud(mode, conversation_id, chat_id, name, job_applied, resume_text, analysis) {
    const formData = new FormData();
    formData.append('conversation_id', conversation_id);
    
    // Get candidate_id from form if available
    const form = document.getElementById('candidate-context');
    const candidate_id = form?.querySelector('input[name="candidate_id"]')?.value;
    if (candidate_id) formData.append('candidate_id', candidate_id);
    
    formData.append('name', name);
    formData.append('job_applied', job_applied);
    formData.append('resume_text', resume_text);
    formData.append('analysis', JSON.stringify(analysis));
    
    if (chat_id) formData.append('chat_id', chat_id);
    
    const lastMessage = document.getElementById('message-text')?.value?.trim() || 
                       document.getElementById('message-content')?.innerText?.trim();
    if (lastMessage) formData.append('last_message', lastMessage);
    
    fetch('/candidates/save-to-cloud', {method: 'POST', body: formData})
        .then(handleApiResponse)
        .then(candidate_id => {
            showToast('âœ… å·²ä¿å­˜', 'success');
            updateCandidateCard(chat_id, conversation_id, {saved: true, score: analysis.overall, viewed: true});
        })
        .catch(err => {
            console.error('Save failed:', err);
            showToast(`ä¿å­˜å¤±è´¥: ${err.message}`, 'error');
        });
}

function updateCandidateCard(chat_id, conversation_id, updates) {
    // Find the candidate card by chat_id, candidate_id, conversation_id, thread_id, or name+job
    const candidateCards = document.querySelectorAll('.candidate-card');
    let found = false;
    
    // Get name and job_applied from the form for fallback matching
    const form = document.getElementById('candidate-context');
    const name = form?.querySelector('input[name="name"]')?.value;
    const job_applied = form?.querySelector('input[name="job_applied"]')?.value;
    
    // Debug: log what we're looking for
    console.log('updateCandidateCard: searching for', { chat_id, conversation_id, name, job_applied, updates });
    
    candidateCards.forEach(card => {
        const candidateData = JSON.parse(card.getAttribute('data-candidate') || '{}');
        const cardId = card.getAttribute('data-candidate-id');
        
        // Match by multiple identifiers:
        // 1. chat_id match (in data or cardId)
        // 2. conversation_id match (direct, via thread_id, or in cardId)
        // 3. Fallback: name + job_applied match (for cases where conversation_id isn't in card yet)
        const matches = (chat_id && (candidateData.chat_id === chat_id || cardId === chat_id)) ||
                       (conversation_id && (
                           candidateData.conversation_id === conversation_id ||
                           candidateData.thread_id === conversation_id ||
                           cardId === conversation_id
                       )) ||
                       // Fallback: match by name and job_applied if we have them
                       (name && job_applied && 
                        candidateData.name === name && 
                        candidateData.job_applied === job_applied);
        
        if (matches) {
            console.log('Found matching candidate card:', { chat_id, conversation_id, candidateData, cardId });
            // Update the card's data attributes
            candidateData.saved = updates.saved;
            candidateData.viewed = updates.viewed;
            candidateData.score = updates.score;
            // Store conversation_id in card data for future lookups
            if (conversation_id && !candidateData.conversation_id && !candidateData.thread_id) {
                candidateData.thread_id = conversation_id; // Store as thread_id for backward compatibility
            }
            card.setAttribute('data-candidate', JSON.stringify(candidateData));
            
            // Update saved tag
            if (updates.saved !== undefined) {
                const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1');
                if (tagsContainer) {
                    let savedTag = tagsContainer.querySelector('[data-tag="saved"]');
                    if (updates.saved && !savedTag) {
                        savedTag = document.createElement('span');
                        savedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-700';
                        savedTag.setAttribute('data-tag', 'saved');
                        savedTag.textContent = 'ğŸ’¾ å·²ä¿å­˜';
                        tagsContainer.appendChild(savedTag);
                    } else if (!updates.saved && savedTag) {
                        savedTag.remove();
                    }
                }
            }
            
            // Update viewed tag
            if (updates.viewed !== undefined) {
                candidateData.viewed = updates.viewed;
                const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1');
                if (tagsContainer) {
                    let viewedTag = tagsContainer.querySelector('[data-tag="viewed"]');
                    if (updates.viewed && !viewedTag) {
                        viewedTag = document.createElement('span');
                        viewedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-purple-100 text-purple-700';
                        viewedTag.setAttribute('data-tag', 'viewed');
                        viewedTag.textContent = 'ğŸ‘ï¸ å·²æŸ¥çœ‹';
                        tagsContainer.appendChild(viewedTag);
                    } else if (!updates.viewed && viewedTag) {
                        viewedTag.remove();
                    }
                }
            }
            
            // Update score badge
            if (updates.score !== undefined) {
                const cardContainer = card.querySelector('.flex.items-start.space-x-3');
                if (cardContainer) {
                    let scoreBadge = cardContainer.querySelector('[data-badge="score"]');
                    if (updates.score !== null && updates.score !== undefined && !scoreBadge) {
                        scoreBadge = document.createElement('div');
                        scoreBadge.className = 'absolute top-0 right-0 bg-gradient-to-r from-blue-500 to-indigo-600 text-white text-xs font-bold px-2 py-1 rounded-bl-lg rounded-tr-lg shadow-md';
                        scoreBadge.setAttribute('data-badge', 'score');
                        scoreBadge.textContent = updates.score.toString();
                        cardContainer.appendChild(scoreBadge);
                    } else if (scoreBadge) {
                        if (updates.score !== null && updates.score !== undefined) {
                            scoreBadge.textContent = updates.score.toString();
                        } else {
                            scoreBadge.remove();
                        }
                    }
                }
            }
            found = true;
            console.log('Updated candidate card:', candidateData);
        }
    });
    if (!found) {
        const identifier = chat_id || conversation_id || 'unknown';
        console.warn('updateCandidateCard: could not find card with identifier', identifier, 'total cards:', candidateCards.length);
        // Debug: log all candidate data to help diagnose
        candidateCards.forEach((card, index) => {
            const candidateData = JSON.parse(card.getAttribute('data-candidate') || '{}');
            const cardId = card.getAttribute('data-candidate-id');
            console.log(`Card ${index}:`, {
                cardId,
                chat_id: candidateData.chat_id,
                conversation_id: candidateData.conversation_id,
                thread_id: candidateData.thread_id,
                name: candidateData.name
            });
        });
    }
}

// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================

function updateFormData(record) {
    dataElement = document.getElementById('candidate-context');
    const formData = new FormData(dataElement);
    for (const [key, value] of Object.entries(record)) {
        let input = dataElement.querySelector(`input[name="${key}"]`);
        if (input) {
            input.value = value;
        }else{
            // create a input element
            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = key;
            input.value = value;
            dataElement.appendChild(input);
        }
    }
}


/**
 * Start analysis (current flow)
 */
function startAnalysis() {
    const form = document.getElementById('candidate-context');
    const resumeTextarea = document.querySelector('#resume-content textarea');
    const formData = new FormData(form);
    formData.append('resume_text', resumeTextarea?.value || '');
    
    htmx.ajax('POST', '/candidates/analyze', {
        target: '#analysis-content',
        swap: 'innerHTML',
        values: Object.fromEntries(formData)
    });
}


/**
 * Initialize new chat (current flow)
 */
function initializeNewChat(mode, chat_id, job_id, name, resume_text) {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    const formData = new FormData();
    formData.append('mode', mode);
    if (chat_id) formData.append('chat_id', chat_id);
    formData.append('job_id', job_id);
    formData.append('name', name);
    formData.append('resume_text', resume_text);

    return fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    })
    .then(handleApiResponse)
    .then(data => {
        console.log('Chat initialized:', data);
        const conversation_id = data.conversation_id;
        if (conversation_id) {
            // Add conversation_id to context
            updateFormData({'conversation_id': conversation_id})
        }
        return conversation_id;
    }).catch(err => {
        console.error('Failed to init chat:', err);
        showToast(`åˆå§‹åŒ–å¯¹è¯å¤±è´¥: ${err.message}`, 'error');
        throw err;
    });
}


</script>
