<!-- Candidate detail view with automatic workflow 
    the passed data:
    - "analysis": data.pop("analysis"),
    - "generated_message": data.pop("last_message"),
    - "resume_text": data.pop("resume_text"),
    - "full_resume": data.pop("full_resume"),
    - "candidate": data,
-->
<div id="candidate-detail-root" class="space-y-6" data-view-mode="{{ view_mode or 'interactive' }}">
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div>
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <p class="text-gray-600">{{ candidate.job_applied or 'æœªæŒ‡å®šå²—ä½' }}</p>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>
    
    <!-- Contact Information Section -->
    {% set metadata = candidate.metadata if candidate.metadata else {} %}
    {% set phone_number = metadata.phone_number if metadata and metadata.phone_number else None %}
    {% set wechat_number = metadata.wechat_number if metadata and metadata.wechat_number else None %}
    {% if phone_number or wechat_number %}
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
        <div class="flex flex-wrap gap-4">
            {% if phone_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="font-mono text-blue-700">{{ phone_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
            {% if wechat_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="font-mono text-blue-700">{{ wechat_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
        </div>
    </div>
    {% endif %}
    
    {% if candidate.name and ('å…ˆç”Ÿ' in candidate.name or 'å¥³å£«' in candidate.name) and not candidate.chat_id%}
        <div class="flex items-center space-x-2 bg-yellow-100 border-l-4 border-yellow-400 text-yellow-800 px-4 py-2 rounded shadow-sm my-2">
            <span>âš ï¸</span>
            <span>
                æ£€æµ‹åˆ°å€™é€‰äººå§“ååŒ…å«<strong>ã€Œå…ˆç”Ÿã€</strong>æˆ–<strong>ã€Œå¥³å£«ã€</strong>ï¼Œå¯¼è‡´æ•°æ®å¯èƒ½é‡å¤ï¼Œè¯·è®¤çœŸæ£€æŸ¥ä»¥ä¸‹å†…å®¹æ˜¯å¦å’Œæ‹›è˜ç½‘ç«™ä¸€è‡´ã€‚å¦‚æœä¸ä¸€è‡´ï¼Œè¯·é‡æ–°è·å–ç®€å†ã€‚
            </span>
        </div>
    {% endif %}

    <!-- Hidden context for HTMX requests - using JSON to preserve types -->
    <div id="candidate-context" class="hidden" hx-vals='{{ candidate | tojson | safe }}'></div>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <!-- <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div> -->
        <!-- Tab Navigation -->
        <div class="flex border-b bg-gray-100 items-center">
            <button id="tab-online" onclick="switchResumeTab('online')" 
                    class="px-4 py-2 font-medium text-sm transition-colors bg-white border-b-2 border-blue-500 text-blue-600">
                åœ¨çº¿ç®€å†
            </button>
            <button id="tab-full" onclick="switchResumeTab('full')" 
                    class="px-4 py-2 font-medium text-sm transition-colors text-gray-600 hover:text-gray-800">
                å®Œæ•´ç®€å†
            </button>
            <div class="flex-1"></div>
            <button 
                id="fetch-online-resume-btn"
                onclick="fetchOnlineResume()"
                class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–åœ¨çº¿ç®€å†</span>
            </button>
            <button 
                id="fetch-full-resume-btn"
                onclick="fetchFullResume().catch(err => console.warn('Re-fetch failed:', err))"
                class="hidden px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–å®Œæ•´ç®€å†</span>
            </button>
        </div>
        <!-- Tab Content -->
        <div id="resume-content" class="p-2"> 
            <!-- Online Resume Tab -->
            <div id="tab-content-online" class="tab-content">
                <div id="resume-online-container">
                    <textarea id="resume-textarea-online" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if resume_text -%}{{ resume_text }}{%- else -%}â³ æ­£åœ¨åŠ è½½åœ¨çº¿ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
            <!-- Full Resume Tab -->
            <div id="tab-content-full" class="tab-content hidden">
                <div id="resume-full-container">
                    <textarea id="resume-textarea-full" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if full_resume -%}{{ full_resume }}{%- else -%}â³ æ­£åœ¨åŠ è½½å®Œæ•´ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
            <div id="analysis-resume-type-badge" class="ml-3">
                <!-- Will be populated by JavaScript based on analysis result -->
            </div>
            <div class="flex-1"></div>
            <button onclick="startAnalysis()"
                    class="px-3 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°åˆ†æ</span>
            </button>
        </div>
        <div id="analysis-content" class="p-2">
            {% if analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center py-8 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only if score >= borderline) -->
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
            <div class="flex-1"></div>
            <button onclick="generateMessage()"
                    class="px-3 py-1 text-xs bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°ç”Ÿæˆæ¶ˆæ¯</span>
            </button>
        </div>
        <div id="message-content" class="p-2">
            <textarea id="message-text" name="generated_message" class="w-full h-32 p-2 border rounded-lg text-center text-gray-500">
                {%- if generated_message not in ['', 'None', 'null', None] -%}{{ generated_message }}{%- else -%}â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...{%- endif -%}
            </textarea>
        </div>
        <div class="flex p-2 gap-2">
            <button onclick="greetAndSendMessage()"
                    class="px-4 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-800">
                ğŸ“¤ æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
            </button>
            <button hx-post="/candidates/pass"
                    hx-vals='{{ candidate | tojson | safe }}'
                    hx-target="body"
                    hx-swap="none"
                    class="px-4 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-800">
                âŒ PASS
            </button>
        </div>
    </div>

    {% if candidate.updated_at %}
    {% set display_time = candidate.updated_at.replace('T', ' ')[:19] %}
    <p class="text-sm text-gray-500 mt-1">æ›´æ–°æ—¶é—´: {{ display_time }}</p>
    {% endif %}
</div>

<!-- Centralized Candidate Analysis & Workflow Logic -->
<script>
// Initialize root and view mode (runs on each HTMX swap)
// Use var to allow redeclaration when HTMX swaps content multiple times
var root = document.getElementById('candidate-detail-root');
var viewMode = root?.dataset?.viewMode || 'interactive';
// Persist on window for other scripts
window.__candidate_detail_root = window.__candidate_detail_root || root;
window.__candidate_detail_view_mode = window.__candidate_detail_view_mode || viewMode;

async function process_candidate() {
    const getIdentifiers = () => {
        const candidate = getCandidateData();
        return {
            candidate_id: candidate.candidate_id,
            chat_id: candidate.chat_id,
            conversation_id: candidate.conversation_id,
            job_applied: candidate.job_applied,
            name: candidate.name,
        };
    };
    const { candidate_id, chat_id, conversation_id, job_applied, name } = getIdentifiers();
    const mode = getCandidateData('mode');
    // Disable cards during processing
    disableAllCards();
    try {
        // Step 1: Ensure resume is loaded
        const online_resume_div = document.getElementById('resume-textarea-online');
        if (!online_resume_div?.value || online_resume_div?.value.includes('â³') || online_resume_div?.value.length < 100) {
            await fetchOnlineResume();
        }
        
        // Step 2: Initialize chat if no conversation_id
        if (!conversation_id) {
            await initializeNewChat();
        }
        
        // Step 3: Start analysis if pending
        const analysisDiv = document.getElementById('analysis-content');
        if (analysisDiv.textContent.includes('â³')) {
            await startAnalysis();
        }
        
        // Step 4: Check threshold and determine stage (sequential: chat â†’ borderline â†’ seek)
        const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
        let analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
        let is_full_analysis = analysis?.resume_type === 'full';
        let current_score = analysis?.overall || 0;
        const skill_score = analysis?.skill || 0;
        const startup_fit_score = analysis?.startup_fit || 0;
        const background_score = analysis?.background || 0;
        const { chat_threshold, borderline_threshold, seek_threshold } = getThresholdValues();
        debugger;
        let newStage = 'PASS'; // Default to PASS
        // Step 4a: Check chat_threshold - generate message if above
        if (current_score >= chat_threshold || skill_score >= seek_threshold || startup_fit_score >= seek_threshold || background_score >= seek_threshold) {
            newStage = 'CHAT';
            const messageText = document.getElementById('message-text').value;
            if (messageText?.includes('â³')) {
                await generateMessage();
            }
        } else {
            showToast(`åŒ¹é…åº¦: ${current_score}, æœªè¾¾æœ€ä½å€¼: ${chat_threshold}`, 'info');
        }
        // Step 4b: Check borderline_threshold - try to get full resume and re-analyze
        let need_reply = await shouldReply();
        const auto_send = document.getElementById('auto-send-checkbox')?.checked ?? true;
        if (current_score >= borderline_threshold || skill_score >= seek_threshold || startup_fit_score >= seek_threshold || background_score >= seek_threshold) {
            newStage = 'SEEK';
            // For chat mode, try to get full resume and re-analyze
            if (mode !== 'recommend') {
                debugger;
                let full_resume_text = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                if (full_resume_text.includes('â³')) {
                    await fetchFullResume();
                    full_resume_text = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                }
                // check if analysis is from full resume
                if (! is_full_analysis && full_resume_text.length > 100 && !full_resume_text.includes('â³')) {
                    await startAnalysis();
                    // Re-read analysis after full resume analysis
                    const updated_analysis_container = document.querySelector('#analysis-content #analysis-result-container');
                    analysis = JSON.parse(updated_analysis_container.getAttribute('data-analysis'));
                    is_full_analysis = analysis.resume_type === 'full';
                    current_score = analysis?.overall || current_score;
                }
                if (need_reply && is_full_analysis && current_score >= borderline_threshold ) {
                    // Step 4c: Send notification if analysis was updated
                    await generateMessage();
                    await greetAndSendMessage(autoSend=auto_send);
                }
                // Step 4d: Check seek_threshold - request contact if above
                if (is_full_analysis && current_score >= seek_threshold) {
                    newStage = 'CONTACT';
                    await sendDingNotification(analysis, name, getCandidateData('job_applied'));
                    await requestContact();
                }
            }else{
                // For recommend mode, greet and send message
                await greetAndSendMessage(autoSend=auto_send);
                need_reply = false;
                // await sendDingNotification(analysis, name, getCandidateData('job_applied'));
            }
        }
        //step 4e: check if we need to reply candidate
        if (mode !== 'recommend' && need_reply) {
            // Step 4c: Send notification if analysis was updated
            await generateMessage();
            await greetAndSendMessage(autoSend=auto_send);
            need_reply = false;
        }
        
        // Update stage and card
        await updateCandidateData({
            stage: newStage,
            viewed: true,
            score: current_score
        });
        
        // Emit success event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-complete', {
            detail: {
                identifiers: getIdentifiers()
            }
        });
        document.dispatchEvent(event);
        
    } catch (error) {
        console.error('Error processing candidate:', error);
        showToast(`å¤„ç†å€™é€‰äººæ—¶å‡ºé”™: ${error.message || String(error)}`, 'error');
        // Emit error event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-error', {
            detail: {
                identifiers: getIdentifiers(),
                error: error.message || String(error)
            }
        });
        document.dispatchEvent(event);
        debugger;
        // throw error;
        // Don't re-throw - let finally handle cleanup
    } finally {
        // Always re-enable cards after processing, even on error
        // Use setTimeout to ensure this runs even if there are unhandled promise rejections
        setTimeout(() => {
            enableAllCards();
        }, 0);
    }
}

/**
 * Send DingTalk notification when candidate score exceeds borderline threshold
 */
async function sendDingNotification(analysis, candidateName, jobApplied) {
    // Get candidate data for server-side notification
    const candidate = getCandidateData();
    const notified = candidate.notified;
    
    // Skip if already notified
    if (notified) {
        showToast('å€™é€‰äººå·²é€šçŸ¥è¿‡ï¼Œè·³è¿‡é€šçŸ¥', 'info');
        return;
    }
    
    // Send analysis data to server - server will format the message
    const response = await fetch('/candidates/notify', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            ...candidate,
            analysis: analysis 
        })
    });
    const result = await window.handleApiResponse(response);
    
    // Update candidate data with notified status if notification was successful
    if (result && result.success) {
        await updateCandidateData({ notified: true });
    }
}

async function fetchOnlineResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    const values = getCandidateData();
    await htmxAjaxPromise('POST', '/candidates/fetch-online-resume', {
        target: '#resume-online-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to online tab after fetch
    switchResumeTab('online');
}

async function fetchFullResume() {
    showToast('æŠ“å–å®Œæ•´ç®€å†...', 'info');
    const values = getCandidateData();
    const mode = values.mode;
    if (mode === 'recommend') {
        const errorMsg = 'å®Œæ•´ç®€å†ä¸æ”¯æŒæ¨èæ¨¡å¼';
        showToast(errorMsg, 'warning');
        throw new Error(errorMsg);
    }

    await htmxAjaxPromise('POST', '/candidates/fetch-full-resume', {
        target: '#resume-full-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to full tab after fetch
    switchResumeTab('full');
}

async function generateMessage() {
    showToast('ç”Ÿæˆæ¶ˆæ¯...', 'info');
    const values = getCandidateData();
    const result = await htmxAjaxPromise('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        values: {...values, purpose: 'CHAT_ACTION'}
    });
    console.log('Generated message:', result);
    await updateCandidateData({generated_message: result});
}

async function greetAndSendMessage(autoSend = true) {
    const message_textarea = document.getElementById('message-text');
    const message = autoSend ? message_textarea.value.trim() : '';
    const stage = getCandidateData('stage');
    const greeted = getCandidateData('greeted');
    
    // const need_reply = await shouldReply();
    if (greeted) {
        showToast('å·²å‘é€è¿‡æ¶ˆæ¯ï¼Œç­‰å¾…å€™é€‰äººå›å¤åå†å‘é€æ¶ˆæ¯', 'info');
        return;
    }
    const mode = getCandidateData('mode');
    const chat_id = getCandidateData('chat_id');
    const index = getCandidateData('index');
    const values = {
        mode,
        chat_id,
        index,
        message,
    };
    // if not auto send and not recommend mode, skip sending message
    if (!autoSend && mode !== 'recommend') {
        return;
    }
    await htmxAjaxPromise('POST', '/candidates/send', {
        target: '#message-content',
        swap: 'none',
        values: values
    });
    
    // Show browser notification after successful message send
    const candidateName = getCandidateData('name') || 'å€™é€‰äºº';
    const notificationTitle = `å·²å‘ ${candidateName} å‘é€æ¶ˆæ¯`;
    await showBrowserNotification(notificationTitle, message);
    
    // Update to CHAT stage
    const currentStage = getCandidateData('stage');
    await updateCandidateData({
        stage: currentStage || 'CHAT',
        greeted: true
    });
}


/**
 * Start analysis (current flow)
 */
async function startAnalysis() {
    const resume_text = document.getElementById('resume-textarea-online')?.value?.trim() || '';
    const full_resume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
    const has_full_resume = !full_resume.includes('â³') && full_resume.length > 0;
    const has_online_resume = !resume_text.includes('â³') && resume_text.length > 0;
    
    if (has_full_resume) {
        showToast('æ­£åœ¨åˆ†æå®Œæ•´ç®€å†...', 'info');
    } else if(has_online_resume) {
        showToast('æ­£åœ¨åˆ†æåœ¨çº¿ç®€å†...', 'info');
    } else {
        showToast('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†', 'error');
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
    }
    
    const values = getCandidateData();
    values.resume_text = resume_text.includes('â³') ? '' : resume_text;
    values.full_resume = full_resume.includes('â³') ? '' : full_resume;
    
    const result = await htmxAjaxPromise('POST', '/candidates/analyze', {
        target: '#analysis-content',
        swap: 'innerHTML',
        values: values
    });
    console.log('Analysis completed:', result.overall);
    // Extract analysis from data attribute
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    await updateCandidateData({score: analysis?.overall});
    
    // Update resume type badge in tab row
    updateAnalysisResumeTypeBadge(analysis);
}

/**
 * Update the resume type badge in the analysis section tab row
 */
function updateAnalysisResumeTypeBadge(analysis) {
    const badgeContainer = document.getElementById('analysis-resume-type-badge');
    if (badgeContainer && analysis) {
        const resumeType = analysis.resume_type || 'online';
        const badgeClass = resumeType === 'full' 
            ? 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-indigo-100 text-indigo-700'
            : 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-700';
        const badgeText = resumeType === 'full' ? 'ğŸ“„ å®Œæ•´ç®€å†' : 'ğŸŒ åœ¨çº¿ç®€å†';
        badgeContainer.innerHTML = `<span class="${badgeClass}">${badgeText}</span>`;
    }
}

/**
 * Check if we should reply based on chat history
 * Returns true if last message is from user, false if from assistant
 */
async function shouldReply() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const mode = values.mode;
    const greeted = values.greeted;
    const autoSend = document.getElementById('auto-send-checkbox')?.checked ?? true;
    if (greeted) {
        return false;
    }
    // For recommend mode, always return true (no chat history)
    if (mode === 'recommend') {
        return !greeted; // if not greeted, we need to reply
    }
    // for other modes, check if we should reply based on chat history
    const response = await fetch('/candidates/should-reply', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            chat_id: chat_id,
            mode: mode
        })
    });
    const data = await window.handleApiResponse(response);
    const should_reply = data.should_reply === true;
    return should_reply;
}

async function requestContact() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const candidate_id = values.candidate_id;
    const mode = values.mode;
    
    // Skip contact request for recommend mode (no chat_id available)
    if (mode === 'recommend' || !chat_id) {
        showToast('æ¨èæ¨¡å¼ä¸æ”¯æŒè¯·æ±‚è”ç³»æ–¹å¼', 'info');
        return;
    }
    
    showToast('è¯·æ±‚è”ç³»æ–¹å¼...', 'info');
    
    // Call new endpoint with both chat_id and candidate_id
    const response = await fetch('/candidates/request-contact', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            chat_id: chat_id,
            candidate_id: candidate_id 
        })
    });
    const data = await window.handleApiResponse(response);
    console.log('Contact requested:', data);
    
    // Update candidate data with contact info in metadata
    // metadata merging is now handled in backend upsert_candidate()
    if (data && (data.phone_number || data.wechat_number)) {
        await updateCandidateData({
            stage: 'CONTACT',
            metadata: {
                phone_number: data.phone_number,
                wechat_number: data.wechat_number,
            }
        });
        
        // Update contact info display dynamically
        updateContactInfoDisplay(data.phone_number, data.wechat_number);
        
        showToast('è”ç³»æ–¹å¼å·²è·å–å¹¶ä¿å­˜', 'success');
    } else if (data && data.success !== false) {
        // Contact request succeeded but no numbers obtained yet
        await updateCandidateData({stage: 'CONTACT'});
    }
}

/**
 * Update contact information display in the DOM
 */
function updateContactInfoDisplay(phoneNumber, wechatNumber) {
    // Check if contact info section exists
    let contactSection = document.querySelector('.bg-blue-50.border.border-blue-200');
    
    if (!contactSection && (phoneNumber || wechatNumber)) {
        // Create contact info section if it doesn't exist
        const header = document.querySelector('#candidate-detail-root > div.flex.justify-between');
        if (header && header.nextElementSibling) {
            contactSection = document.createElement('div');
            contactSection.className = 'bg-blue-50 border border-blue-200 rounded-lg p-4';
            contactSection.innerHTML = `
                <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
                <div class="flex flex-wrap gap-4" id="contact-info-content"></div>
            `;
            header.parentNode.insertBefore(contactSection, header.nextElementSibling);
        }
    }
    
    if (contactSection) {
        const contentDiv = contactSection.querySelector('#contact-info-content') || contactSection.querySelector('.flex.flex-wrap');
        if (contentDiv) {
            let html = '';
            if (phoneNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="font-mono text-blue-700">${phoneNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            if (wechatNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="font-mono text-blue-700">${wechatNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            contentDiv.innerHTML = html;
        }
    }
}

/**
 * Initialize new chat - reads all data from DOM
 */
async function initializeNewChat() {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    let candidate = getCandidateData();
    //always use online resume at first time (full resume is not available at first time)
    const resume_text = document.getElementById('resume-textarea-online')?.value;
    if (!resume_text) {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
        return;
    }
    candidate.resume_text = resume_text;

    const formData = new FormData();
    for (const [key, value] of Object.entries(candidate)) {
        if (value !== null && value !== undefined) {
            formData.append(key, value);
        }
    }

    const response = await fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    });
    candidate = await window.handleApiResponse(response);
    console.log('Chat initialized:', candidate);
    await updateCandidateData(candidate);
    return candidate.candidate_id;
}


// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================

/**
 * Update candidate data in the form and broadcast update to card
 * This function combines both updateCandidateData and updateCandidateCard
 */
async function updateCandidateData(data) {
    const dataCopy = {...data};
    data.saved = true
    // update the resume, analysis and generated_message fields
    if (data.resume_text) {
        document.getElementById('resume-textarea-online').value = data.resume_text;
        document.getElementById('resume-textarea-online').textContent = data.resume_text;
        delete data.resume_text;
    }
    if (data.full_resume) {
        document.getElementById('resume-textarea-full').value = data.full_resume;
        document.getElementById('resume-textarea-full').textContent = data.full_resume;
        delete data.full_resume;
    }
    if (data.analysis) {
        // Await the HTMX ajax call using htmxAjaxPromise
        await htmxAjaxPromise('POST', '/candidates/render-analysis-result', {
            swap: 'innerHTML',
            values: { analysis: JSON.stringify(data.analysis) },
            target: '#analysis-content',
        });
        delete data.analysis;
    }
    if (data.generated_message) {
        const messageTextArea = document.getElementById('message-text')
        messageTextArea.value = data.generated_message;
        messageTextArea.textContent = data.generated_message;
        delete data.generated_message;
    }

    // Get current data from hx-vals
    const currentData = getCandidateData();
    // get the updated fields
    const updates = Object.fromEntries(
        Object.entries(dataCopy).filter(([k, v]) => v!== currentData[k] && v !== null && v !== undefined && v !== '')
    );
    // if no updates, return
    if (Object.keys(updates).length === 0) {
        return;
    }
    
    // Merge updates
    const mergedData = { ...currentData, ...data };
    
    // Update hx-vals attribute with merged data
    const container = document.getElementById('candidate-context');
    container.setAttribute('hx-vals', JSON.stringify(mergedData));
    
    // Get identifiers from the updated data for matching
    const identifiers = {
        chat_id: mergedData.chat_id,
        conversation_id: mergedData.conversation_id,
        candidate_id: mergedData.candidate_id,
        index: mergedData.index
    };
    
    // Broadcast the update event to candidate cards
    const event = new CustomEvent('candidate:update', {
        detail: {
            identifiers: identifiers,
            updates: mergedData,
        }
    });
    document.dispatchEvent(event);

    // update to cloud 
    if (Object.keys(updates).length > 0) {
        const response = await fetch('/candidates/save', {
            method: 'POST',
            body: JSON.stringify({...identifiers, ...updates}),
        });
        // await window.handleApiResponse(response);
    }
}

function getCandidateData(key) {
    const container = document.getElementById('candidate-context');
    const hxVals = container.getAttribute('hx-vals');
    if (hxVals) {
        const data = JSON.parse(hxVals);
        // If key is provided, return that property; otherwise return the whole object
        return key !== undefined ? data[key] : data;
    }
    return key !== undefined ? null : {};
}


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 5.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0,
        seek_threshold: parseFloat(document.getElementById('threshold-seek')?.value) || 9.0
    };
}

// ============================================================================
// UI Helper Functions
// ============================================================================

function switchResumeTab(tab) {
    // Hide all tab contents
    document.getElementById('tab-content-online').classList.add('hidden');
    document.getElementById('tab-content-full').classList.add('hidden');
    
    // Remove active styles from all tabs
    document.getElementById('tab-online').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-online').classList.add('text-gray-600');
    document.getElementById('tab-full').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-full').classList.add('text-gray-600');
    
    // Show/hide fetch buttons based on active tab
    const fetchOnlineBtn = document.getElementById('fetch-online-resume-btn');
    const fetchFullBtn = document.getElementById('fetch-full-resume-btn');
    
    // Show selected tab content and activate tab button
    if (tab === 'online') {
        document.getElementById('tab-content-online').classList.remove('hidden');
        document.getElementById('tab-online').classList.remove('text-gray-600');
        document.getElementById('tab-online').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show online resume button, hide full resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.remove('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.add('hidden');
    } else if (tab === 'full') {
        document.getElementById('tab-content-full').classList.remove('hidden');
        document.getElementById('tab-full').classList.remove('text-gray-600');
        document.getElementById('tab-full').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show full resume button, hide online resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.add('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.remove('hidden');
    }
}

// Run initialization when partial is loaded via HTMX
// This ensures process_candidate() runs on each HTMX swap
(function () {
    // å½“åœ¨æœç´¢é¡µé¢æŸ¥çœ‹å€™é€‰äººè¯¦æƒ…æ—¶ï¼Œä½¿ç”¨ readonly æ¨¡å¼ï¼Œä¸åº”è¯¥æ‰§è¡Œ
    const viewMode = window.__candidate_detail_view_mode || 'interactive';
    if (viewMode === 'readonly') return;
    
    // Function to run process_candidate with proper error handling
    async function runProcessCandidate() {
        // Set initial tab state - show online tab if resume_text exists, otherwise show full tab
        const fullTextarea = document.getElementById('resume-textarea-full');
        switchResumeTab( fullTextarea?.value?.trim().length > 100 ? 'full' : 'online');
        await process_candidate();
    }
    
    // Use setTimeout instead of requestAnimationFrame to ensure it runs even in background tabs
    // requestAnimationFrame is paused when the tab is not visible, but setTimeout is only throttled
    setTimeout(() => {
        runProcessCandidate();
    }, 100);
})();

</script>
