<!-- Candidate detail view with automatic workflow 
    the passed data:
    - "analysis": data.pop("analysis"),
    - "generated_message": data.pop("last_message"),
    - "resume_text": data.pop("resume_text"),
    - "full_resume": data.pop("full_resume"),
    - "candidate": data,
-->
<div class="space-y-6">
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div>
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <p class="text-gray-600">{{ candidate.job_applied or 'æœªæŒ‡å®šå²—ä½' }}</p>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>

    <!-- Hidden context for HTMX requests -->
    <form id="candidate-context" class="hidden">
        <input type="hidden" name="chat_id" value="{{ candidate.chat_id }}">
        <input type="hidden" name="mode" value="{{ candidate.mode}}">
        <input type="hidden" name="name" value="{{ candidate.name}}">
        <input type="hidden" name="job_id" value="{{ candidate.job_id }}">
        <input type="hidden" name="job_applied" value="{{ candidate.job_applied }}">
        <input type="hidden" name="conversation_id" value="{{ candidate.conversation_id }}">
        <input type="hidden" name="index" value="{{ candidate.index }}">
        <input type="hidden" name="candidate_id" value="{{ candidate.candidate_id }}">
        <input type="hidden" name="stage" value="{{ candidate.stage }}">
        <input type="hidden" name="greeted" value="{{ candidate.greeted }}">
        <input type="hidden" name="last_message" value="{{ candidate.last_message }}">
    </form>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <!-- <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div> -->
        <!-- Tab Navigation -->
        <div class="flex border-b bg-gray-100">
            <button id="tab-online" onclick="switchResumeTab('online')" 
                    class="px-4 py-2 font-medium text-sm transition-colors bg-white border-b-2 border-blue-500 text-blue-600">
                åœ¨çº¿ç®€å†
            </button>
            <button id="tab-full" onclick="switchResumeTab('full')" 
                    class="px-4 py-2 font-medium text-sm transition-colors text-gray-600 hover:text-gray-800">
                å®Œæ•´ç®€å†
            </button>
        </div>
        <!-- Tab Content -->
        <div id="resume-content" class="p-2"> 
            <!-- Online Resume Tab -->
            <div id="tab-content-online" class="tab-content">
                <div class="mb-2 flex justify-end">
                    <button 
                        onclick="fetchOnlineResume()"
                        class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1">
                        <span>ğŸ”„</span>
                        <span>é‡æ–°è·å–åœ¨çº¿ç®€å†</span>
                    </button>
                </div>
                <div id="resume-online-container">
                    <textarea id="resume-textarea-online" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {% if resume_text %} {{ resume_text }} {% else %} â³ æ­£åœ¨åŠ è½½åœ¨çº¿ç®€å†... {% endif %}
                    </textarea>
                </div>
            </div>
            <!-- Full Resume Tab -->
            <div id="tab-content-full" class="tab-content hidden">
                <div class="mb-2 flex justify-end">
                    <button 
                        onclick="fetchFullResume().catch(err => console.warn('Re-fetch failed:', err))"
                        class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1">
                        <span>ğŸ”„</span>
                        <span>é‡æ–°è·å–å®Œæ•´ç®€å†</span>
                    </button>
                </div>
                <div id="resume-full-container">
                    <textarea id="resume-textarea-full" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {% if full_resume %} {{ full_resume }} {% else %} â³ æ­£åœ¨åŠ è½½å®Œæ•´ç®€å†... {% endif %}
                    </textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
        </div>
        <div id="analysis-content" class="p-2">
            {% if analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center py-8 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only if score >= borderline) -->
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
        </div>
        <div id="message-content" class="p-2">
            {% if generated_message not in ['', 'None', 'null', None] %}
            <textarea id="message-text" name="generated_message" class="w-full h-32 p-2 border rounded-lg">{{ generated_message }}</textarea>
            {% else %}
            <div class="text-center py-8 text-gray-500">â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...</div>
            {% endif %}
        </div>
        <div class="flex p-2 gap-2">
            <button onclick="greetAndSendMessage()"
                    class="px-4 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-800">
                ğŸ“¤ æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
            </button>
            <button hx-post="/candidates/pass"
                    hx-include="#candidate-context"
                    hx-target="body"
                    hx-swap="none"
                    class="px-4 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-800">
                âŒ PASS
            </button>
            <button onclick="generateMessage()"
                    class="px-3 py-1 bg-indigo-600 text-white text-sm rounded hover:bg-indigo-800">
                ğŸ”„ é‡æ–°ç”Ÿæˆæ¶ˆæ¯
            </button>
        </div>
    </div>

</div>

<!-- Mode-specific record check logic -->
<script>
// ============================================================================
// Centralized Candidate Analysis & Workflow Logic
// ============================================================================

async function process_candidate() {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    const mode = formData.get('mode');
    const chat_id = formData.get('chat_id');
    const candidate_id = formData.get('candidate_id');
    const name = formData.get('name') || 'æœªçŸ¥å€™é€‰äºº';
    // Use single mutable variable for conversation_id
    let conversationId = formData.get('conversation_id');
    
    // Emit identifier for event listeners (use current conversationId value)
    const getIdentifier = () => chat_id || conversationId || candidate_id || 'unknown';
    
    try {
        // Step 1: Ensure resume is loaded
        const online_resume_div = document.getElementById('resume-textarea-online');
        if (!online_resume_div?.value || online_resume_div?.value.includes('â³') || online_resume_div?.value.length < 100) {
            await fetchOnlineResume();
        }
        
        // Step 2: Initialize chat if no conversation_id
        if (!conversationId) {
            conversationId = await initializeNewChat();
        }
        
        // Step 3: Start analysis if pending
        const analysisDiv = document.getElementById('analysis-content');
        if (analysisDiv.textContent.includes('â³')) {
            await startAnalysis();
        }
        
        // Step 4: Check threshold and determine stage (sequential: chat â†’ borderline â†’ seek)
        const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
        let analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
        let current_score = analysis?.overall || 0;
        const { chat_threshold, borderline_threshold, seek_threshold } = getThresholdValues();
        
        let newStage = 'PASS'; // Default to PASS
        // Step 4a: Check chat_threshold - generate message if above
        if (current_score >= chat_threshold) {
            debugger;
            newStage = 'CHAT';
            const messageDiv = document.getElementById('message-content');
            if (messageDiv?.textContent?.includes('â³')) {
                await generateMessage();
            }
            
            // Step 4b: Check borderline_threshold - try to get full resume and re-analyze
            if (current_score >= borderline_threshold) {
                newStage = 'SEEK';
                // For chat mode, try to get full resume and re-analyze
                if (mode !== 'recommend') {
                    const full_resume_div = document.getElementById('resume-textarea-full');
                    if (full_resume_div?.value?.includes('â³') || !full_resume_div?.value || full_resume_div?.value.includes('None')) {
                        await fetchFullResume();
                        const full_resume_textarea = document.getElementById('resume-textarea-full');
                        const resumeText = full_resume_textarea?.value || '';
                        if (resumeText.length > 100 && !resumeText.includes('â³')) {
                            await startAnalysis();
                            // Re-read analysis after full resume analysis
                            const updated_analysis_container = document.querySelector('#analysis-content #analysis-result-container');
                            analysis = updated_analysis_container ? JSON.parse(updated_analysis_container.getAttribute('data-analysis')) : analysis;
                            current_score = analysis?.overall || current_score;
                        }
                    }
                }else{
                    // For recommend mode, greet and send message
                    await greetAndSendMessage();
                }
                
                // Step 4c: Check seek_threshold - request contact if above
                if (current_score >= seek_threshold) {
                    newStage = 'CONTACT';
                    await requestContact();
                }
            }
        } else {
            showToast(`åŒ¹é…åº¦: ${current_score}, æœªè¾¾æœ€ä½å€¼: ${chat_threshold}`, 'info');
            newStage = 'PASS';
        }
        
        // Update stage and card
        updateCandidateData({
            stage: newStage,
            viewed: true,
            score: current_score
        });
        
        // Emit success event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-complete', {
            detail: {
                identifier: getIdentifier(),
                chat_id: chat_id,
                conversation_id: conversationId,
                candidate_id: candidate_id,
                name: name
            }
        });
        setTimeout(() => {
            document.dispatchEvent(event);
        }, 100);
        
    } catch (error) {
        console.error('Error processing candidate:', error);
        // Emit error event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-error', {
            detail: {
                identifier: getIdentifier(),
                chat_id: chat_id,
                conversation_id: conversationId,
                candidate_id: candidate_id,
                name: name,
                error: error.message || String(error)
            }
        });
        document.dispatchEvent(event);
        throw error;
    }
}

async function fetchOnlineResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    await htmxAjaxPromise('POST', '/candidates/fetch-online-resume', {
        target: '#resume-online-container',
        swap: 'innerHTML',
        source: '#candidate-context'
    });
    // Switch to online tab after fetch
    switchResumeTab('online');
}

async function fetchFullResume() {
    showToast('æŠ“å–å®Œæ•´ç®€å†...', 'info');
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    formData.delete('resume_text');
    const mode = formData.get('mode');
    if (mode === 'recommend') {
        const errorMsg = 'å®Œæ•´ç®€å†ä¸æ”¯æŒæ¨èæ¨¡å¼';
        showToast(errorMsg, 'warning');
        throw new Error(errorMsg);
    }

    await htmxAjaxPromise('POST', '/candidates/fetch-full-resume', {
        target: '#resume-full-container',
        swap: 'innerHTML',
        source: '#candidate-context'
    });
    // Switch to full tab after fetch
    switchResumeTab('full');
}

function switchResumeTab(tab) {
    // Hide all tab contents
    document.getElementById('tab-content-online').classList.add('hidden');
    document.getElementById('tab-content-full').classList.add('hidden');
    
    // Remove active styles from all tabs
    document.getElementById('tab-online').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-online').classList.add('text-gray-600');
    document.getElementById('tab-full').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-full').classList.add('text-gray-600');
    
    // Show selected tab content and activate tab button
    if (tab === 'online') {
        document.getElementById('tab-content-online').classList.remove('hidden');
        document.getElementById('tab-online').classList.remove('text-gray-600');
        document.getElementById('tab-online').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    } else if (tab === 'full') {
        document.getElementById('tab-content-full').classList.remove('hidden');
        document.getElementById('tab-full').classList.remove('text-gray-600');
        document.getElementById('tab-full').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    }
}

async function generateMessage() {
    showToast('ç”Ÿæˆæ¶ˆæ¯...', 'info');
    const chat_id = getCandidateData('chat_id');

    const result = await htmxAjaxPromise('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        source: '#candidate-context',
        values: {'purpose': 'CHAT_ACTION'}
    });
    console.log('Generated message:', result);
    updateCandidateData({generated_message: result});
}

async function greetAndSendMessage() {
    showToast('æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯...', 'info');
    const message_textarea = document.getElementById('message-text');
    const message = message_textarea.value.trim();
    const stage = getCandidateData('stage');
    const greeted = getCandidateData('greeted');
    
    // Check if already greeted (stage is CHAT, SEEK, or CONTACT, or greeted flag is true)
    if (['CHAT', 'SEEK', 'CONTACT'].includes(stage) || greeted) {
        showToast('å·²ç»æ‰“æ‹›å‘¼è¿‡äº†ï¼Œä¸èƒ½é‡å¤æ‰“æ‹›å‘¼', 'info');
        return 'å·²ç»æ‰“æ‹›å‘¼è¿‡äº†';
    }
    
    debugger;
    try {
        await htmxAjaxPromise('POST', '/candidates/send', {
            target: '#message-content',
            swap: 'none',
            source: '#candidate-context',
            values: {'message': message}
        });
        showToast('æ¶ˆæ¯å‘é€æˆåŠŸï¼', 'success');
        // Update to CHAT stage (not GREET, as GREET is not in STAGES)
        const currentStage = getCandidateData('stage');
        updateCandidateData({
            stage: currentStage || 'CHAT',
            greeted: true
        });
    } catch (err) {
        showToast('æ¶ˆæ¯å‘é€å¤±è´¥ï¼', 'error');
        throw err;
    }
}


/**
 * Start analysis (current flow)
 */
async function startAnalysis() {
    const resume_text = document.getElementById('resume-textarea-online')?.value?.trim() || '';
    const full_resume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
    const has_full_resume = !full_resume.includes('â³') && full_resume.length > 0;
    const has_online_resume = !resume_text.includes('â³') && resume_text.length > 0;
    
    if (has_full_resume) {
        showToast('æ­£åœ¨åˆ†æå®Œæ•´ç®€å†...', 'info');
    } else if(has_online_resume) {
        showToast('æ­£åœ¨åˆ†æåœ¨çº¿ç®€å†...', 'info');
    } else {
        showToast('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†', 'error');
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
    }
    
    const result = await htmxAjaxPromise('POST', '/candidates/analyze', {
        source: '#candidate-context',
        target: '#analysis-content',
        swap: 'innerHTML',
        values: {
            'resume_text': resume_text.includes('â³') ? '' : resume_text,
            'full_resume': full_resume.includes('â³') ? '' : full_resume
        }
    });
    console.log('Analysis completed:', result);
    // Extract analysis from data attribute
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    updateCandidateData({score: analysis?.overall});
}

async function requestContact() {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    const chat_id = formData.get('chat_id');
    const mode = formData.get('mode');
    
    // Skip contact request for recommend mode (no chat_id available)
    if (mode === 'recommend' || !chat_id) {
        showToast('æ¨èæ¨¡å¼ä¸æ”¯æŒè¯·æ±‚è”ç³»æ–¹å¼', 'info');
        return;
    }
    
    showToast('è¯·æ±‚è”ç³»æ–¹å¼...', 'info');
    
    // Endpoint expects JSON body with embed=True format
    const response = await fetch('/chat/contact/request', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ chat_id: chat_id })
    });
    const data = await window.handleApiResponse(response);
    console.log('Contact requested:', data);
    
    // Update to CONTACT stage if contact was successfully obtained
    if (data && data.success !== false) {
        updateCandidateData({stage: 'CONTACT'});
    }
}

/**
 * Initialize new chat - reads all data from DOM
 */
async function initializeNewChat() {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    //always use online resume at first time (full resume is not available at first time)
    const resume_text = document.getElementById('resume-textarea-online').value;
    formData.append('resume_text', resume_text);

    const response = await fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    });
    const data = await window.handleApiResponse(response);
    console.log('Chat initialized:', data);
    if (data.conversation_id) {
        updateCandidateData({
            conversation_id: data.conversation_id,
            saved: true
        });
    }
    return data.conversation_id;
}


// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================

/**
 * Update candidate data in the form and broadcast update to card
 * This function combines both updateCandidateData and updateCandidateCard
 */
function updateCandidateData(record) {
    const dataElement = document.getElementById('candidate-context');

    // Update form inputs
    for (const [key, value] of Object.entries(record)) {
        let input = dataElement.querySelector(`input[name="${key}"]`);
        if (input) {
            input.value = value;
        } else {
            // create a input element
            input = document.createElement('input');
            input.type = 'hidden';
            input.name = key;
            input.value = value;
            dataElement.appendChild(input);
        }
    }
    
    // Broadcast update to card (filter out null/undefined, keep false values)
    const updates = Object.fromEntries(
        Object.entries(record).filter(([_, v]) => v !== null && v !== undefined && v !== '')
    );
    
    if (Object.keys(updates).length > 0) {
        // Get identifiers from the form for matching
        const chat_id = getCandidateData('chat_id');
        const conversation_id = getCandidateData('conversation_id');
        const candidate_id = getCandidateData('candidate_id');
        const name = getCandidateData('name');
        const job_applied = getCandidateData('job_applied');
        
        // Broadcast the update event
        const event = new CustomEvent('candidate:update', {
            detail: {
                identifiers: {
                    chat_id,
                    conversation_id,
                    candidate_id,
                    name,
                    job_applied
                },
                updates
            }
        });
        document.dispatchEvent(event);
    }

    // update to cloud
    htmx.ajax('POST', '/candidates/save', {
        source: '#candidate-context',
        swap: 'none',
    });
}

function getCandidateData(key) {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    return formData.get(key);
}


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 5.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0,
        seek_threshold: parseFloat(document.getElementById('threshold-seek')?.value) || 9.0
    };
}

// ============================================================================
// HTMX Promise Wrapper
// ============================================================================

/**
 * Wrap htmx.ajax to return a Promise that resolves when swap completes
 */
 function htmxAjaxPromise(method, url, options) {
    return new Promise((resolve, reject) => {
        const target = document.querySelector(options.target);
        if (!target) {
            reject(new Error(`Target element not found: ${options.target}`));
            return;
        }
        
        // Listen for swap completion
        const afterSwap = (evt) => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            resolve(target.textContent.trim());
        };
        
        const onError = (evt) => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            const errorMsg = evt.detail?.error || evt.detail?.message || 'HTMX request failed';
            reject(new Error(errorMsg));
        };
        
        target.addEventListener('htmx:afterSwap', afterSwap, { once: true });
        target.addEventListener('htmx:responseError', onError, { once: true });
        
        // Trigger the ajax call
        htmx.ajax(method, url, options);
    });
}

// ============================================================================
// Batch Processing Function
// ============================================================================

/**
 * Process all candidate cards sequentially
 */
// Global flag for batch processing control
window.batchProcessingActive = false;
window.stopBatchProcessing = false;

async function processAllCandidates() {
    const cards = document.querySelectorAll('.candidate-card');
    if (cards.length === 0) {
        showToast('æ²¡æœ‰æ‰¾åˆ°å€™é€‰äºº', 'warning');
        return;
    }
    
    const total = cards.length;
    let processed = 0;
    let failed = 0;
    
    // Set batch processing flag
    window.batchProcessingActive = true;
    window.stopBatchProcessing = false;
    
    // Disable all candidate cards
    cards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.6';
    });
    
    // Update button to stop button
    const batchBtn = document.getElementById('batch-analyze-btn');
    if (batchBtn) {
        batchBtn.disabled = false;
        batchBtn.textContent = 'â¸ åœæ­¢å¤„ç†';
        batchBtn.onclick = stopBatchProcessingHandler;
        batchBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
        batchBtn.classList.add('bg-red-600', 'hover:bg-red-700');
    }
    
    showToast(`å¼€å§‹æ‰¹é‡å¤„ç† ${total} ä¸ªå€™é€‰äºº`, 'info');
    
    for (let i = 0; i < cards.length; i++) {
        // Check if user requested stop
        if (window.stopBatchProcessing) {
            showToast(`æ‰¹é‡å¤„ç†å·²åœæ­¢ (${processed}/${total} å®Œæˆ)`, 'warning');
            break;
        }
        
        const card = cards[i];
        const cardData = JSON.parse(card.getAttribute('hx-vals'));
        const name = cardData.name || `å€™é€‰äºº ${i + 1}`;
        
        showToast(`æ­£åœ¨å¤„ç†å€™é€‰äºº ${i + 1}/${total}: ${name}`, 'info');
        
        try {
            const detailPane = document.getElementById('detail-pane');
            if (!detailPane) {
                throw new Error('Detail pane not found');
            }
            
            // Set up event listeners BEFORE triggering HTMX click
            // This ensures we catch the event even if process_candidate() completes quickly
            const processingPromise = new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    reject(new Error('Processing timeout (60s)'));
                }, 60000); // 60 second timeout
                
                const onComplete = (event) => {
                    clearTimeout(timeout);
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    resolve(event.detail);
                };
                
                const onError = (event) => {
                    clearTimeout(timeout);
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    reject(new Error(event.detail.error || 'Processing failed'));
                };
                
                document.addEventListener('candidate:processing-complete', onComplete, { once: true });
                document.addEventListener('candidate:processing-error', onError, { once: true });
            });
            
            // Wait for HTMX swap to complete
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    detailPane.removeEventListener('htmx:afterSwap', onSwap);
                    detailPane.removeEventListener('htmx:responseError', onError);
                    reject(new Error('HTMX swap timeout'));
                }, 10000); // 10 second timeout for swap
                
                const onSwap = () => {
                    clearTimeout(timeout);
                    detailPane.removeEventListener('htmx:afterSwap', onSwap);
                    detailPane.removeEventListener('htmx:responseError', onError);
                    // Wait a bit for DOM to be ready
                    setTimeout(resolve, 200);
                };
                
                const onError = (evt) => {
                    clearTimeout(timeout);
                    detailPane.removeEventListener('htmx:afterSwap', onSwap);
                    detailPane.removeEventListener('htmx:responseError', onError);
                    reject(new Error(evt.detail.error || 'HTMX request failed'));
                };
                
                detailPane.addEventListener('htmx:afterSwap', onSwap, { once: true });
                detailPane.addEventListener('htmx:responseError', onError, { once: true });
                
                // Trigger HTMX click
                htmx.trigger(card, 'click');
            });
            
            // Wait for process_candidate() to complete
            await processingPromise;
            
            processed++;
            showToast(`âœ… ${name} å¤„ç†å®Œæˆ (${processed}/${total})`, 'success');
        } catch (error) {
            failed++;
            console.error(`Failed to process candidate ${i + 1}:`, error);
            showToast(`âŒ ${name} å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            // Continue to next candidate
        }
    }
    
    // Re-enable candidate cards
    cards.forEach(card => {
        card.style.pointerEvents = '';
        card.style.opacity = '';
    });
    
    // Reset batch processing flag
    window.batchProcessingActive = false;
    window.stopBatchProcessing = false;
    
    // Reset button
    if (batchBtn) {
        batchBtn.disabled = false;
        batchBtn.textContent = 'å…¨éƒ¨åˆ†æ';
        batchBtn.onclick = processAllCandidates;
        batchBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        batchBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
    }
    
    // Final summary
    const summary = `æ‰¹é‡å¤„ç†å®Œæˆ: æˆåŠŸ ${processed}/${total}, å¤±è´¥ ${failed}`;
    showToast(summary, processed === total ? 'success' : 'warning');
}

function stopBatchProcessingHandler() {
    window.stopBatchProcessing = true;
    const batchBtn = document.getElementById('batch-analyze-btn');
    if (batchBtn) {
        batchBtn.disabled = true;
        batchBtn.textContent = 'æ­£åœ¨åœæ­¢...';
    }
    showToast('æ­£åœ¨åœæ­¢æ‰¹é‡å¤„ç†...', 'info');
}

// Make function globally available
window.processAllCandidates = processAllCandidates;

// Trigger workflow when this partial is loaded via HTMX
// Since this script runs when HTMX swaps content, we can call it directly
// Use requestAnimationFrame to ensure DOM is ready
requestAnimationFrame(() => {
    // Set initial tab state - show online tab if resume_text exists, otherwise show full tab
    const onlineTextarea = document.getElementById('resume-textarea-online');
    const fullTextarea = document.getElementById('resume-textarea-full');
    const hasOnline = onlineTextarea?.value?.trim();
    const hasFull = fullTextarea?.value?.trim();
    
    if (hasOnline) {
        switchResumeTab('online');
    } else if (hasFull) {
        switchResumeTab('full');
    } else {
        // Default to online tab
        switchResumeTab('online');
    }
    
    process_candidate();
});

</script>

</script>
