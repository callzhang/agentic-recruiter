<!-- Candidate detail view with automatic workflow -->
<div class="space-y-6">
    
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div>
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <p class="text-gray-600">{{ candidate.job_applied or candidate.job_title or 'æœªæŒ‡å®šå²—ä½' }}</p>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>

    <!-- Hidden context for HTMX requests -->
    <form id="candidate-context" class="hidden">
        <input type="hidden" name="chat_id" value="{{ candidate.chat_id or '' }}">
        <input type="hidden" name="mode" value="{{ candidate.mode or 'chat' }}">
        <input type="hidden" name="name" value="{{ candidate.name or '' }}">
        <input type="hidden" name="assistant_id" value="{{ assistant_id }}">
        <input type="hidden" name="job_id" value="{{ job_id }}">
        <input type="hidden" name="conversation_id" value="{{ candidate.conversation_id or candidate.thread_id or '' }}">
        <input type="hidden" name="index" value="{{ candidate.index}}">
    </form>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div>
        {% if candidate.resume_text or candidate.full_resume %}
        <textarea readonly class="w-full h-64 p-4 bg-gray-50 border rounded-lg font-mono text-sm">{{ candidate.full_resume or candidate.resume_text }}</textarea>
        {% else %}
        <div id="resume-content" class="text-center py-8 text-gray-500" 
            hx-post="{% if candidate.mode == 'recommend' %}/candidates/fetch-recommend-resume{% else %}/candidates/fetch-online-resume{% endif %}" 
            hx-trigger="load"
            hx-include="#candidate-context"
            hx-target="#resume-content"
            hx-swap="innerHTML"
            hx-on::after-swap="handleResumeLoaded()"
            hx-on::htmx:after-swap="handleResumeLoaded()"> 
            â³ æ­£åœ¨åŠ è½½ç®€å†...
        </div>
        {% endif %}
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
        </div>
        <div id="analysis-content" 
             class="p-4"
             hx-on::after-swap="handleAnalysisComplete()">
            {% if candidate.analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center py-8 text-gray-500" id="analysis-trigger">
                â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...
            </div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only if score >= borderline) -->
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
        </div>
        <div id="message-content" class="p-4">
            {% if generated_message %}
            <div class="space-y-4">
                <textarea id="message-text" name="message" class="w-full h-32 p-4 border rounded-lg">{{ generated_message }}</textarea>
                <div class="flex space-x-2">
                    <button hx-post="/candidates/send"
                            hx-include="#candidate-context,#message-text"
                            class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">
                        ğŸ“¤ å‘é€æ¶ˆæ¯
                    </button>
                    <button hx-post="/candidates/pass"
                            hx-include="#candidate-context"
                            class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">
                        â­ï¸ PASS
                    </button>
                </div>
            </div>
            {% else %}
            <div class="text-center py-8 text-gray-500">åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡å°†è‡ªåŠ¨ç”Ÿæˆ...</div>
            {% endif %}
        </div>
    </div>

    <!-- 4. Chat History (for chat mode only) -->
    {% if candidate.mode != 'recommend' %}
    <!-- <div class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ’¬ èŠå¤©è®°å½•</h3>
        </div>
        <div id="chat-history" 
             hx-get="/candidates/history/{{ candidate.chat_id or candidate.id }}"
             hx-trigger="load"
             hx-swap="innerHTML"
             class="p-4">
            <div class="text-center text-gray-500">åŠ è½½ä¸­...</div>
        </div>
    </div> -->
    {% endif %}

    <!-- Manual Actions (always available) -->
    <div class="bg-gray-50 rounded-lg p-4 space-y-2">
        <h3 class="font-bold text-gray-800 mb-2">ğŸ”§ æ‰‹åŠ¨æ“ä½œ</h3>
        <div class="flex flex-wrap gap-2">
            <button hx-post="{% if candidate.mode == 'recommend' %}/candidates/fetch-recommend-resume{% else %}/candidates/fetch-online-resume{% endif %}"
                    hx-include="#candidate-context"
                    hx-target="#resume-content"
                    hx-swap="innerHTML"
                    class="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">
                ğŸ”„ é‡æ–°è·å–ç®€å†
            </button>
            <button hx-post="/candidates/analyze"
                    hx-include="#candidate-context"
                    hx-target="#analysis-content"
                    hx-swap="innerHTML"
                    onclick="this.setAttribute('hx-vals', JSON.stringify({resume_text: document.querySelector('#resume-content textarea')?.value || ''}))"
                    class="px-3 py-1 bg-purple-600 text-white text-sm rounded hover:bg-purple-700">
                ğŸ”„ é‡æ–°åˆ†æ
            </button>
            <button hx-post="/candidates/generate-message"
                    hx-include="#candidate-context"
                    hx-target="#message-content"
                    hx-swap="innerHTML"
                    hx-vals='{"purpose": "CHAT_ACTION"}'
                    class="px-3 py-1 bg-indigo-600 text-white text-sm rounded hover:bg-indigo-700">
                ğŸ”„ é‡æ–°ç”Ÿæˆæ¶ˆæ¯
            </button>
        </div>
    </div>

</div>

<!-- Mode-specific record check logic -->
<script>
// ============================================================================
// Centralized Candidate Analysis & Workflow Logic
// ============================================================================

// Get threshold values from UI inputs in candidates.html (same document, loaded via HTMX)
function getThresholdValues() {
    const chatInput = document.getElementById('threshold-chat');
    const borderlineInput = document.getElementById('threshold-borderline');
    const seekInput = document.getElementById('threshold-seek');

    return {
        chat: chatInput ? (parseFloat(chatInput.value) || 5.0) : 5.0,
        borderline: borderlineInput ? (parseFloat(borderlineInput.value) || 7.0) : 7.0,
        seek: seekInput ? (parseFloat(seekInput.value) || 9.0) : 9.0
    };
}
// Handle resume loaded event using HTMX's hx-on::after-swap
// when resume is loaded, we need to initialize a new chat thread
// Then start analysis
function handleResumeLoaded() {

    const textarea = document.querySelector('#resume-content textarea');

    if (!textarea || !textarea.value) {
        return;
    }
    resumeText = textarea.value;
    const mode = document.querySelector('input[name="mode"]')?.value;
    const chatId = document.querySelector('input[name="chat_id"]')?.value;
    const name = document.querySelector('input[name="name"]')?.value;
    const jobId = document.querySelector('input[name="job_id"]')?.value;

    initializeNewChat(mode, chatId, jobId, name, resumeText).then((conversation_id) => {
        updateFormData({'conversation_id': conversation_id});
        showToast('ç®€å†åŠ è½½å®Œæˆï¼Œæ­£åœ¨åˆ†æç®€å†...', 'success');
        startAnalysis();
    }).catch(err => {
        console.error('Failed to analyze resume:', err);
        showToast('åˆå§‹åŒ–å¯¹è¯å¤±è´¥', 'error');
        throw new Error('Failed to analyze resume');
    });
}


// Handle analysis completion after HTMX swap
// This function is called via hx-on::after-swap on #analysis-content element
function handleAnalysisComplete() {
    const analysisDiv = document.querySelector('#analysis-content #analysis-result-container');
    if (!analysisDiv) return;
    
    try {
        const analysis = JSON.parse(analysisDiv.getAttribute('data-analysis') || '{}');
        const mode = analysisDiv.getAttribute('data-mode');
        const conversationId = analysisDiv.getAttribute('data-conversation-id');
        const chatId = analysisDiv.getAttribute('data-chat-id');
        const name = analysisDiv.getAttribute('data-name');
        const jobId = analysisDiv.getAttribute('data-job-id');
        const assistantId = analysisDiv.getAttribute('data-assistant-id');
        
        // Get resume text from textarea if available, otherwise from data attribute
        let resumeText = '';
        const resumeTextarea = document.querySelector('#resume-section textarea');
        if (resumeTextarea) {
            resumeText = resumeTextarea.value || '';
        }
        if (!resumeText) {
            resumeText = analysisDiv.getAttribute('data-resume-text') || '';
        }
        
        // Get thresholds from UI inputs
        const { chat, borderline, seek } = getThresholdValues();
        
        // Compute flags based on overall score and thresholds
        const overallScore = analysis.overall || 0;
        const shouldGenerateGreet = overallScore >= borderline;
        const shouldRequestResume = overallScore >= seek;
        const shouldGenerateChat = overallScore >= chat;
        
        // For recommend/greet mode, handle sequential actions
        if (shouldGenerateChat) {
            showToast(`è¯„åˆ† ${overallScore} >= ${chat}ï¼Œç”Ÿæˆæ‹›å‘¼æ¶ˆæ¯...`, 'success');
            generateMessage(mode, conversationId, assistantId, jobId, chatId, name, resumeText, analysis);
            requestFullResume(mode, chatId, jobId);
        } else {
            showToast(`è¯„åˆ† ${overallScore} < ${chat}ï¼Œä¸æ¨è`, 'warning');
            return;
        }
        
        saveCandidateToCloud(mode, conversationId, chatId, name, jobId, resumeText, analysis);
        
    } catch (e) {
        console.error('Error handling analysis complete:', e);
    }
}

function generateMessage(mode, conversationId, assistantId, jobId, chatId, name, resumeText, analysis) {
    const formData = new FormData();
    formData.append('mode', mode);
    formData.append('conversation_id', conversationId);
    formData.append('job_id', jobId);
    formData.append('purpose', 'CHAT_ACTION');
    if (chatId) formData.append('chat_id', chatId);
    
    // Set up one-time event listener for message generation completion
    const messageTarget = document.getElementById('message-content');
    const handler = function() {
        // After message is generated, save to cloud
        setTimeout(() => {
            saveCandidateToCloud(mode, conversationId, chatId, name, jobId, resumeText, analysis);
        }, 500);
        messageTarget.removeEventListener('htmx:afterSwap', handler);
    };
    
    if (messageTarget) {
        messageTarget.addEventListener('htmx:afterSwap', handler, { once: true });
    }
    
    htmx.ajax('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        values: Object.fromEntries(formData)
    });
}

function requestFullResume(mode, chatId, jobId) {
    if (!chatId) {
        console.error('Cannot request full resume: chat_id is missing');
        showToast('æ— æ³•è¯·æ±‚å®Œæ•´ç®€å†ï¼šç¼ºå°‘ chat_id', 'error');
        return;
    }

    if (mode !== 'chat' && mode !== 'greet' && mode !== 'followup') {
        console.error('Mode must be chat, greet, or followup');
        return;
    }
    
    // Call the browser action endpoint to request full resume from candidate
    fetch('/chat/resume/request_full', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ chat_id: chatId })
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => {
                throw new Error(err.detail || `HTTP ${response.status}: ${response.statusText}`);
            });
        }
        return response.json();
    })
    .then(data => {
        if (data === true || data === 'true') {
            showToast('âœ… å·²æˆåŠŸè¯·æ±‚å®Œæ•´ç®€å†', 'success');
        } else {
            showToast('è¯·æ±‚å®Œæ•´ç®€å†å¤±è´¥', 'error');
        }
    })
    .catch(error => {
        console.error('Error requesting full resume:', error);
        showToast('è¯·æ±‚å®Œæ•´ç®€å†æ—¶å‡ºé”™: ' + error.message, 'error');
    });
}

function saveCandidateToCloud(mode, conversationId, chatId, name, jobId, resumeText, analysis) {
    const formData = new FormData();
    formData.append('mode', mode);
    formData.append('conversation_id', conversationId);
    formData.append('name', name);
    formData.append('job_id', jobId);
    formData.append('resume_text', resumeText);
    formData.append('analysis', JSON.stringify(analysis));
    // Use the latest message content as last_message for saving
    const messageElement = document.getElementById('message-content');
    if (messageElement) {
        formData.append('last_message', messageElement.innerText || messageElement.textContent || '');
    }
    if (chatId) formData.append('chat_id', chatId);
    
    fetch('/candidates/save-to-cloud', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showToast('âœ… å€™é€‰äººå·²ä¿å­˜åˆ°äº‘ç«¯', 'success');
        } else {
            showToast('ä¿å­˜å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'), 'error');
        }
    })
    .catch(err => {
        console.error('Failed to save candidate:', err);
        showToast('ä¿å­˜å¤±è´¥', 'error');
    });
}

// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================

function updateFormData(record) {
    dataElement = document.getElementById('candidate-context');
    const formData = new FormData(dataElement);
    for (const [key, value] of Object.entries(record)) {
        let input = dataElement.querySelector(`input[name="${key}"]`);
        if (input) {
            input.value = value;
        }else{
            // create a input element
            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = key;
            input.value = value;
            dataElement.appendChild(input);
        }
    }
}






/**
 * Start analysis (current flow)
 */
function startAnalysis() {
    const messageFormData = new FormData(document.getElementById('candidate-context'));
    htmx.ajax('POST', '/candidates/analyze', {
        target: '#analysis-content',
        swap: 'innerHTML',
        values: Object.fromEntries(messageFormData)
    })
}


/**
 * Initialize new chat (current flow)
 */
function initializeNewChat(mode, chatId, jobId, name, resumeText) {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    const formData = new FormData();
    formData.append('mode', mode);
    if (chatId) formData.append('chat_id', chatId);
    formData.append('job_id', jobId);
    formData.append('name', name);
    formData.append('resume_text', resumeText);

    return fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    }).then(response => {
        if (!response.ok) throw new Error('Init chat failed');
        return response.json();
    }).then(data => {
        console.log('Chat initialized:', data);
        const conversationId = data.conversation_id;
        if (conversationId) {
            // Add conversation_id to context
            updateFormData({'conversation_id': conversationId})
        }
        return conversationId;
    }).catch(err => {
        console.error('Failed to init chat:', err);
        showToast('åˆå§‹åŒ–å¯¹è¯å¤±è´¥', 'error');
        throw new Error('Failed to init chat');
    });
}


</script>
