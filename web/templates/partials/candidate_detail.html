<!-- Candidate detail view with automatic workflow -->
<div class="space-y-6">
    
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div>
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <p class="text-gray-600">{{ candidate.job_applied or 'æœªæŒ‡å®šå²—ä½' }}</p>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>

    <!-- Hidden context for HTMX requests -->
    <form id="candidate-context" class="hidden">
        <input type="hidden" name="chat_id" value="{{ candidate.chat_id or '' }}">
        <input type="hidden" name="mode" value="{{ candidate.mode}}">
        <input type="hidden" name="name" value="{{ candidate.name}}">
        <!-- <input type="hidden" name="assistant_id" value="{{ assistant_id }}"> -->
        <input type="hidden" name="job_id" value="{{ candidate.job_id }}">
        <input type="hidden" name="job_applied" value="{{ candidate.job_applied }}">
        <input type="hidden" name="conversation_id" value="{{ candidate.conversation_id or '' }}">
        <input type="hidden" name="index" value="{{ candidate.index or '' }}">
        <input type="hidden" name="candidate_id" value="{{ candidate.candidate_id or '' }}">
    </form>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div>
        <div id="resume-content" class="p-2" hx-on::after-swap="saveCandidateToCloud();"> 
            {% if candidate.resume_text or candidate.full_resume %}
            <textarea readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">{{ candidate.full_resume or candidate.resume_text }}</textarea>
            {% else %}
            <div class="text-center py-8 text-gray-500">â³ æ­£åœ¨åŠ è½½ç®€å†...</div>
            {% endif %}
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
        </div>
        <div id="analysis-content" class="p-2"
             hx-on::after-swap="saveCandidateToCloud(); ">
            {% if candidate.analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center py-8 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only if score >= borderline) -->
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
        </div>
        <div id="message-content" class="p-2" hx-on::after-swap="saveCandidateToCloud();">
            {% if candidate.last_message %}
            <textarea id="message-text" name="message" class="w-full h-32 p-2 border rounded-lg">{{ candidate.last_message }}</textarea>
            {% else %}
            <div class="text-center py-8 text-gray-500">â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...</div>
            {% endif %}
        </div>
        <div class="flex p-2 gap-2">
            <button onclick="sendGreetAndMessage()"
                    class="px-4 py-1 bg-green-400 text-white text-sm rounded hover:bg-green-700">
                ğŸ“¤ æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
            </button>
            <button hx-post="/candidates/pass"
                    hx-include="#candidate-context"
                    hx-target="body"
                    hx-swap="none"
                    class="px-4 py-1 bg-gray-400 text-white text-sm rounded hover:bg-gray-700">
                âŒ PASS
            </button>
            <button onclick="generateMessage()"
                    class="px-3 py-1 bg-indigo-400 text-white text-sm rounded hover:bg-indigo-700">
                ğŸ”„ é‡æ–°ç”Ÿæˆæ¶ˆæ¯
            </button>
        </div>
    </div>


    <!-- Manual Actions (always available)
    <div class="bg-gray-50 rounded-lg p-4 space-y-2">
        <h3 class="font-bold text-gray-800 mb-2">ğŸ”§ æ‰‹åŠ¨æ“ä½œ</h3>
        <div class="flex flex-wrap gap-2">
            <button onclick="fetchResume()"
                    class="px-3 py-1 bg-yellow-400 text-white text-sm rounded hover:bg-yellow-700">
                ğŸ”„ é‡æ–°è·å–ç®€å†
            </button>
            <button onclick="startAnalysis()"
                    class="px-3 py-1 bg-purple-400 text-white text-sm rounded hover:bg-purple-700">
                ğŸ”„ é‡æ–°åˆ†æ
            </button>
            
        </div>
    </div> -->

</div>

<!-- Mode-specific record check logic -->
<script>
// ============================================================================
// Centralized Candidate Analysis & Workflow Logic
// ============================================================================

async function process_candidate() {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    const mode = formData.get('mode');
    
    // Step 1: Ensure resume is loaded
    const resume_div = document.getElementById('resume-content');
    if (resume_div && resume_div.textContent.includes('â³')) {
        await fetchResume().then(() => {
            const candidate_id = formData.get('candidate_id');
            if (!candidate_id) {
                // candidate_id = await getCandidateIdByResumeText();
                // updateCandidateData({'candidate_id': candidate_id});
                showToast('TODO: Candidate ID not found, will be fetched later', 'warning');
            }
        }).then(() => {
            //TODO: fetch full resume
        });
    }
    
    // Step 2: Initialize chat if no conversation_id
    let conversation_id = formData.get('conversation_id');
    if (!conversation_id) {
        conversation_id = await initializeNewChat();
        updateCandidateData({'conversation_id': conversation_id});
    }
    
    // Step 3: Start analysis if pending
    const analysisDiv = document.getElementById('analysis-content');
    if (analysisDiv.textContent.includes('â³') && !resume_div.textContent.includes('â³')) {
        await startAnalysis();
    }
    
    // Step 4: Check threshold and generate message if needed
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    const overall_score = analysis?.overall || 0;
    const { chat_threshold, borderline_threshold } = getThresholdValues();
    
    if (overall_score >= chat_threshold) {
        const messageDiv = document.getElementById('message-content');
        if (messageDiv && messageDiv.textContent.includes('â³')) {
            await generateMessage();
        }
        if (overall_score >= borderline_threshold) {
            requestFullResume();
        }
    }
}

function fetchResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    const mode = formData.get('mode');
    return htmxAjaxPromise('POST', mode == 'recommend'?"/candidates/fetch-recommend-resume":"/candidates/fetch-online-resume", {
        target: '#resume-content',
        swap: 'innerHTML',
        source: '#candidate-context'
    });
}

function generateMessage() {
    showToast('ç”Ÿæˆæ¶ˆæ¯...', 'info');
    const chat_id = getCandidateData('chat_id');
    fetch(`/chat/${chat_id}/messages`, {
        method: 'GET',
        headers: {'Content-Type': 'application/json'}
    }).then(window.handleApiResponse)
    .then(data => {
        showToast(data ? 'âœ… å·²è·å¾—å¯¹è¯è®°å½•' : 'è¯·æ±‚å¤±è´¥', data ? 'success' : 'error');
        return htmxAjaxPromise('POST', '/candidates/generate-message', {
            target: '#message-content',
            swap: 'innerHTML',
            source: '#candidate-context',
            values: {'purpose': 'CHAT_ACTION'}
        });
    });
}

function sendGreetAndMessage() {
    showToast('æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯...', 'info');
    const message_textarea = document.getElementById('message-text');
    const message = message_textarea.value.trim();
    const chat_id = getCandidateData('chat_id');
    return htmxAjaxPromise('POST', '/candidates/send', {
            target: '#message-content',
            swap: 'none',
            source: '#candidate-context',
            values: {'message': message}
    }).then(() => {
        showToast('æ¶ˆæ¯å‘é€æˆåŠŸï¼', 'success');
        updateCandidateData({'stage': 'GREET', 'greeted': true});
        updateCandidateCard({stage: 'GREET', greeted: true});
    }).catch(err => {
        showToast('æ¶ˆæ¯å‘é€å¤±è´¥ï¼', 'error');
    });
}

function requestFullResume() {
    debugger;
    const chat_id = getCandidateData('chat_id');
    const mode = getCandidateData('mode');
    
    if (!chat_id || !['chat', 'greet', 'followup'].includes(mode)) {
        console.log('Skip requestFullResume: not a chat mode or no chat_id');
        return;
    }
    showToast('è¯·æ±‚å®Œæ•´ç®€å†...', 'info');
    fetch('/chat/resume/request_full', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({chat_id: chat_id})
    })
    .then(window.handleApiResponse)
    .then(data => showToast(data ? 'âœ… å·²è¯·æ±‚å®Œæ•´ç®€å†' : 'è¯·æ±‚å¤±è´¥', data ? 'success' : 'error'));
}



/**
 * Start analysis (current flow)
 */
 function startAnalysis() {
    showToast('å¼€å§‹åˆ†æ...', 'info');
    // const resumeTextarea = document.querySelector('#resume-content textarea');
    return htmxAjaxPromise('POST', '/candidates/analyze', {
        source: '#candidate-context',
        target: '#analysis-content',
        swap: 'innerHTML',
        // values: {'resume_text': resumeTextarea.value }
    });
}

/**
 * Initialize new chat - reads all data from DOM
 */
function initializeNewChat() {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    const resumeTextarea = document.querySelector('#resume-content textarea');
    formData.append('resume_text', resumeTextarea.value);

    return fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    })
    .then(window.handleApiResponse)
    .then(data => {
        console.log('Chat initialized:', data);
        if (data.conversation_id) {
            updateCandidateData({'conversation_id': data.conversation_id});
        }
        return data.conversation_id;
    });
}

function saveCandidateToCloud() {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    
    // Add resume_text from #resume-content
    const resume_textarea = document.querySelector('#resume-section textarea');
    if (resume_textarea?.value) {
        formData.set('resume_text', resume_textarea.value);
    }
    
    // Add analysis from #analysis-content
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? analysis_container.getAttribute('data-analysis') : null;
    if (analysis) {
        formData.set('analysis', analysis);
    }
    
    // Add last_message from #message-content
    const message_textarea = document.getElementById('message-text');
    const message = message_textarea?.value.trim();
    if (message) {
        formData.set('last_message', message);
    }
    
    const chat_id = formData.get('chat_id');
    const conversation_id = formData.get('conversation_id');
    const candidate_id = formData.get('candidate_id');
    
    fetch('/candidates/save-to-cloud', {method: 'POST', body: formData})
        .then(window.handleApiResponse)
        .then(data => {
            showToast('âœ… å·²ä¿å­˜', 'success');
            if (data.candidate_id && data.candidate_id !== candidate_id) {
                console.log('Candidate saved to cloud:', data.candidate_id);
                updateCandidateData({'candidate_id': data.candidate_id});
            }
            // Update card in list
            const score = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')).overall : null;
            updateCandidateCard({
                saved: true, 
                score: score, 
                viewed: true,
                last_message: message_textarea?.value.trim()
            });
        });
}


function updateCandidateCard(updates) {
    // Remove keys from updates where value is null or undefined (like {k:v for k,v in updates.items() if v} in Python)
    updates = Object.fromEntries(
        Object.entries(updates).filter(([_, v]) => v !== null && v !== undefined && v !== false && v !== '')
    );
    // Find the candidate card by chat_id, candidate_id, conversation_id, or name+job
    const candidateCards = document.querySelectorAll('.candidate-card');
    let found = false;
    
    // Get name and job_applied from the form for fallback matching
    const chat_id = getCandidateData('chat_id');
    const conversation_id = getCandidateData('conversation_id');
    const candidate_id = getCandidateData('candidate_id');
    const name = getCandidateData('name');
    const job_applied = getCandidateData('job_applied');
    
    candidateCards.forEach(card => {
        const cardData = JSON.parse(card.getAttribute('hx-vals'));
        
        // Match by multiple identifiers:
        // 1. chat_id match (in data or cardId)
        // 2. conversation_id match (direct or in cardId)
        // 3. Fallback: name + job_applied match (for cases where conversation_id isn't in card yet)
        const matches = (chat_id && cardData.chat_id === chat_id) ||
                       (conversation_id && cardData.conversation_id === conversation_id) ||
                       (candidate_id && cardData.candidate_id === candidate_id) ||
                       // Fallback: match by name and job_applied if we have them
                       (name && job_applied &&  cardData.name === name && cardData.job_applied === job_applied);
        
        if (matches) {
            console.log('Found matching candidate card:', { chat_id, conversation_id, cardData, candidate_id });
            // Update the card's data attributes
            Object.assign(cardData, updates);
            // Store conversation_id in card data for future lookups
            if (conversation_id && !cardData.conversation_id) {
                cardData.conversation_id = conversation_id;
            }
            // apply updates to candidateData
            card.setAttribute('hx-vals', JSON.stringify(cardData));
            
            // Update saved tag
            const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1');
            if (updates.saved !== undefined) {
                let savedTag = tagsContainer.querySelector('[data-tag="saved"]');
                if (updates.saved && !savedTag) {
                    savedTag = document.createElement('span');
                    savedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-700';
                    savedTag.setAttribute('data-tag', 'saved');
                    savedTag.textContent = 'ğŸ’¾ å·²ä¿å­˜';
                    tagsContainer.appendChild(savedTag);
                } else if (!updates.saved && savedTag) {
                    savedTag.remove();
                }
            }
            // Update viewed tag
            if (updates.viewed !== undefined) {
                let viewedTag = tagsContainer.querySelector('[data-tag="viewed"]');
                if (updates.viewed && !viewedTag) {
                    viewedTag = document.createElement('span');
                    viewedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-purple-100 text-purple-700';
                    viewedTag.setAttribute('data-tag', 'viewed');
                    viewedTag.textContent = 'ğŸ‘ï¸ å·²æŸ¥çœ‹';
                    tagsContainer.appendChild(viewedTag);
                } else if (!updates.viewed && viewedTag) {
                    viewedTag.remove();
                }
            }
            // Update greeted tag
            if (updates.greeted !== undefined) {
                let greetedTag = tagsContainer.querySelector('[data-tag="greeted"]');
                if (updates.greeted && !greetedTag) {
                    greetedTag = document.createElement('span');
                    greetedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-green-100 text-green-700';
                    greetedTag.setAttribute('data-tag', 'greeted');
                    greetedTag.textContent = 'ğŸ‘‹ å·²æ‰“æ‹›å‘¼';
                    tagsContainer.appendChild(greetedTag);
                } else if (!updates.greeted && greetedTag) {
                    greetedTag.remove();
                }
            }
            // Update score badge
            if (updates.score !== undefined) {
                const cardContainer = card.querySelector('.flex.items-start.space-x-3');
                if (cardContainer) {
                    let scoreBadge = cardContainer.querySelector('[data-badge="score"]');
                    if (updates.score !== null && updates.score !== undefined && !scoreBadge) {
                        scoreBadge = document.createElement('div');
                        scoreBadge.className = 'absolute top-0 right-0 bg-gradient-to-r from-blue-500 to-indigo-600 text-white text-xs font-bold px-2 py-1 rounded-bl-lg rounded-tr-lg shadow-md';
                        scoreBadge.setAttribute('data-badge', 'score');
                        scoreBadge.textContent = updates.score.toString();
                        cardContainer.appendChild(scoreBadge);
                    } else if (scoreBadge) {
                        if (updates.score !== null && updates.score !== undefined) {
                            scoreBadge.textContent = updates.score.toString();
                        } else {
                            scoreBadge.remove();
                        }
                    }
                }
            }
            found = true;
            console.log('Updated candidate card:', cardData);
        }
    });
    if (!found) {
        const identifier = chat_id || conversation_id || candidate_id;
        console.warn('updateCandidateCard: could not find card with identifier', identifier, 'total cards:', candidateCards.length);
    }
}

// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================

function updateCandidateData(record) {
    dataElement = document.getElementById('candidate-context');
    const formData = new FormData(dataElement);
    for (const [key, value] of Object.entries(record)) {
        let input = dataElement.querySelector(`input[name="${key}"]`);
        if (input) {
            input.value = value;
        }else{
            // create a input element
            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = key;
            input.value = value;
            dataElement.appendChild(input);
        }
    }
}

function getCandidateData(key) {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    return formData.get(key);
}


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 5.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0,
        seek_threshold: parseFloat(document.getElementById('threshold-seek')?.value) || 9.0
    };
}

// ============================================================================
// HTMX Promise Wrapper
// ============================================================================

/**
 * Wrap htmx.ajax to return a Promise that resolves when swap completes
 */
 function htmxAjaxPromise(method, url, options) {
    return new Promise((resolve, reject) => {
        const target = document.querySelector(options.target);
        if (!target) {
            reject(new Error(`Target element not found: ${options.target}`));
            return;
        }
        
        // Listen for swap completion
        const afterSwap = () => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            resolve();
        };
        
        const onError = (evt) => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            reject(new Error(evt.detail.error || 'HTMX request failed'));
        };
        
        target.addEventListener('htmx:afterSwap', afterSwap, { once: true });
        target.addEventListener('htmx:responseError', onError, { once: true });
        
        // Trigger the ajax call
        htmx.ajax(method, url, options);
    });
}

// Trigger workflow when this partial is loaded via HTMX
// Since this script runs when HTMX swaps content, we can call it directly
// Use requestAnimationFrame to ensure DOM is ready
requestAnimationFrame(() => {
    setTimeout(() => {
        process_candidate();
    }, 100);
});

</script>
