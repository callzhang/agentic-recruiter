<!-- Candidate detail view with automatic workflow 
    the passed data:
    - "analysis": data.pop("analysis"),
    - "generated_message": data.pop("last_message"),
    - "resume_text": data.pop("resume_text"),
    - "full_resume": data.pop("full_resume"),
    - "candidate": data,
-->
<div class="space-y-6">
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div>
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <p class="text-gray-600">{{ candidate.job_applied or 'æœªæŒ‡å®šå²—ä½' }}</p>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>

    <!-- Hidden context for HTMX requests -->
    <form id="candidate-context" class="hidden">
        <input type="hidden" name="chat_id" value="{{ candidate.chat_id or '' }}">
        <input type="hidden" name="mode" value="{{ candidate.mode}}">
        <input type="hidden" name="name" value="{{ candidate.name}}">
        <input type="hidden" name="job_id" value="{{ candidate.job_id }}">
        <input type="hidden" name="job_applied" value="{{ candidate.job_applied }}">
        <input type="hidden" name="conversation_id" value="{{ candidate.conversation_id or '' }}">
        <input type="hidden" name="index" value="{{ candidate.index or '' }}">
        <input type="hidden" name="candidate_id" value="{{ candidate.candidate_id or '' }}">
        <input type="hidden" name="stage" value="{{ candidate.stage or '' }}">
    </form>
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <!-- <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div> -->
        <!-- Tab Navigation -->
        <div class="flex border-b bg-gray-100">
            <button id="tab-online" onclick="switchResumeTab('online')" 
                    class="px-4 py-2 font-medium text-sm transition-colors bg-white border-b-2 border-blue-500 text-blue-600">
                åœ¨çº¿ç®€å†
            </button>
            <button id="tab-full" onclick="switchResumeTab('full')" 
                    class="px-4 py-2 font-medium text-sm transition-colors text-gray-600 hover:text-gray-800">
                å®Œæ•´ç®€å†
            </button>
        </div>
        <!-- Tab Content -->
        <div id="resume-content" class="p-2"> 
            <div id="tab-content-online" class="tab-content" hx-on::after-swap="switchResumeTab('online');">
                <textarea id="resume-textarea-online" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                    {% if resume_text %} {{ resume_text }} {% else %} â³ æ­£åœ¨åŠ è½½åœ¨çº¿ç®€å†... {% endif %}
                </textarea>
            </div>
            <div id="tab-content-full" class="tab-content hidden" hx-on::after-swap="switchResumeTab('full');">
                <textarea id="resume-textarea-full" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                    {% if full_resume %} {{ full_resume }} {% else %} â³ æ­£åœ¨åŠ è½½å®Œæ•´ç®€å†... {% endif %}
                </textarea>
            </div>
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
        </div>
        <div id="analysis-content" class="p-2">
            {% if analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center py-8 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only if score >= borderline) -->
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="p-4 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
        </div>
        <div id="message-content" class="p-2">
            {% if generated_message not in ['', 'None', 'null', None] %}
            <textarea id="message-text" name="generated_message" class="w-full h-32 p-2 border rounded-lg">{{ generated_message }}</textarea>
            {% else %}
            <div class="text-center py-8 text-gray-500">â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...</div>
            {% endif %}
        </div>
        <div class="flex p-2 gap-2">
            <button onclick="greetAndSendMessage()"
                    class="px-4 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-800">
                ğŸ“¤ æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
            </button>
            <button hx-post="/candidates/pass"
                    hx-include="#candidate-context"
                    hx-target="body"
                    hx-swap="none"
                    class="px-4 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-800">
                âŒ PASS
            </button>
            <button onclick="generateMessage()"
                    class="px-3 py-1 bg-indigo-600 text-white text-sm rounded hover:bg-indigo-800">
                ğŸ”„ é‡æ–°ç”Ÿæˆæ¶ˆæ¯
            </button>
        </div>
    </div>

</div>

<!-- Mode-specific record check logic -->
<script>
// ============================================================================
// Centralized Candidate Analysis & Workflow Logic
// ============================================================================

async function process_candidate() {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    const mode = formData.get('mode');
    const chat_id = formData.get('chat_id');
    const candidate_id = formData.get('candidate_id');
    const name = formData.get('name') || 'æœªçŸ¥å€™é€‰äºº';
    // Use single mutable variable for conversation_id
    let conversationId = formData.get('conversation_id');
    
    // Emit identifier for event listeners (use current conversationId value)
    const getIdentifier = () => chat_id || conversationId || candidate_id || 'unknown';
    
    try {
        // Step 1: Ensure resume is loaded
        const online_resume_div = document.getElementById('resume-textarea-online');
        if (!online_resume_div?.value || online_resume_div?.value.includes('â³')) {
            await fetchOnlineResume();
        }
        
        // Step 2: Initialize chat if no conversation_id
        if (!conversationId) {
            conversationId = await initializeNewChat();
            updateCandidateData({'conversation_id': conversationId});
            updateCandidateCard({'saved': true});
        }
        
        // Step 3: Start analysis if pending
        const analysisDiv = document.getElementById('analysis-content');
        if (analysisDiv.textContent.includes('â³')) {
            await startAnalysis();
        }
        
        // Step 4: Check threshold and generate message if needed
        const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
        const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
        const overall_score = analysis?.overall || 0;
        const { chat_threshold, borderline_threshold } = getThresholdValues();
        if (overall_score >= chat_threshold) {
            const messageDiv = document.getElementById('message-content');
            if (messageDiv?.textContent?.includes('â³')) {
                await generateMessage();
            }
            // analyze the full resume if it is available
            const full_resume_div = document.getElementById('resume-textarea-full');
            if (full_resume_div?.value?.includes('â³') || full_resume_div?.value?.includes('None')) {
                if(overall_score >= borderline_threshold){
                    if(mode === 'recommend'){
                        await greetAndSendMessage();
                    }else{
                        await fetchFullResume().then(data => {
                            // Check the swapped textarea content
                            const full_resume_textarea = document.getElementById('resume-textarea-full');
                            const resumeText = full_resume_textarea?.value || '';
                            if (resumeText.length > 100 && !resumeText.includes('â³')) {
                                // analyze the full resume
                                startAnalysis();
                            }
                            else {
                                showToast('æš‚æ— å®Œæ•´ç®€å†æ•°æ®', 'info');
                            }
                        })
                        .catch(err => {
                            // Handle error (e.g., recommend mode not supported)
                            console.warn('fetchFullResume failed:', err.message);
                        });
                    }
                }else{
                    showToast('åŒ¹é…åº¦æœªè¾¾æ ‡ï¼Œä¸åˆ†æå®Œæ•´ç®€å†', 'info');
                }
            }
        }else{
            showToast('åŒ¹é…åº¦æœªè¾¾æ ‡ï¼Œä¸ç”Ÿæˆæ¶ˆæ¯', 'info');
        }

        // Step 5: update candidate card
        updateCandidateCard({
            viewed: true,
            score: overall_score
        });
        
        // Emit success event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-complete', {
            detail: {
                identifier: getIdentifier(),
                chat_id: chat_id,
                conversation_id: conversationId,
                candidate_id: candidate_id,
                name: name
            }
        });
        setTimeout(() => {
            document.dispatchEvent(event);
        }, 1000);
        
    } catch (error) {
        console.error('Error processing candidate:', error);
        // Emit error event (use updated conversationId)
        const event = new CustomEvent('candidate:processing-error', {
            detail: {
                identifier: getIdentifier(),
                chat_id: chat_id,
                conversation_id: conversationId,
                candidate_id: candidate_id,
                name: name,
                error: error.message || String(error)
            }
        });
        document.dispatchEvent(event);
        throw error;
    }
}

function fetchOnlineResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    const mode = formData.get('mode');
    const url = mode == 'recommend'?"/candidates/fetch-recommend-resume":"/candidates/fetch-online-resume";
    return htmxAjaxPromise('POST', url, {
        target: '#tab-content-online',
        swap: 'innerHTML',
        source: '#candidate-context'
    });
}

function fetchFullResume() {
    showToast('æŠ“å–å®Œæ•´ç®€å†...', 'info');
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    formData.delete('resume_text');
    const mode = formData.get('mode');
    if (mode === 'recommend') {
        const errorMsg = 'å®Œæ•´ç®€å†ä¸æ”¯æŒæ¨èæ¨¡å¼';
        showToast(errorMsg, 'warning');
        return Promise.reject(new Error(errorMsg));
    }

    return htmxAjaxPromise('POST', '/candidates/fetch-full-resume', {
        target: '#tab-content-full',
        swap: 'innerHTML',
        source: '#candidate-context'
    });
}

function switchResumeTab(tab) {
    // Hide all tab contents
    document.getElementById('tab-content-online').classList.add('hidden');
    document.getElementById('tab-content-full').classList.add('hidden');
    
    // Remove active styles from all tabs
    document.getElementById('tab-online').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-online').classList.add('text-gray-600');
    document.getElementById('tab-full').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-full').classList.add('text-gray-600');
    
    // Show selected tab content and activate tab button
    if (tab === 'online') {
        document.getElementById('tab-content-online').classList.remove('hidden');
        document.getElementById('tab-online').classList.remove('text-gray-600');
        document.getElementById('tab-online').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    } else if (tab === 'full') {
        document.getElementById('tab-content-full').classList.remove('hidden');
        document.getElementById('tab-full').classList.remove('text-gray-600');
        document.getElementById('tab-full').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    }
}

function generateMessage() {
    showToast('ç”Ÿæˆæ¶ˆæ¯...', 'info');
    const chat_id = getCandidateData('chat_id');

    return htmxAjaxPromise('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        source: '#candidate-context',
        values: {'purpose': 'CHAT_ACTION'}
    }).then(result => {
        console.log('Generated message:', result);
        updateCandidateCard({'generated_message': result});
    });
}

function greetAndSendMessage() {
    showToast('æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯...', 'info');
    const message_textarea = document.getElementById('message-text');
    const message = message_textarea.value.trim();
    const chat_id = getCandidateData('chat_id');
    return htmxAjaxPromise('POST', '/candidates/send', {
            target: '#message-content',
            swap: 'none',
            source: '#candidate-context',
            values: {'message': message}
    }).then(() => {
        showToast('æ¶ˆæ¯å‘é€æˆåŠŸï¼', 'success');
        updateCandidateData({'stage': 'GREET', 'greeted': true});
        updateCandidateCard({stage: 'GREET', greeted: true});
    }).catch(err => {
        showToast('æ¶ˆæ¯å‘é€å¤±è´¥ï¼', 'error');
    });
}


/**
 * Start analysis (current flow)
 */
 function startAnalysis() {
    showToast('å¼€å§‹åˆ†æ...', 'info');
    const resume_text = document.getElementById('resume-textarea-online')?.value?.trim() || '';
    const full_resume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
    has_full_resume = full_resume.includes('â³') ? false : true;
    has_online_resume = resume_text.includes('â³') ? false : true;
    if (has_full_resume) {
        showToast('æ­£åœ¨åˆ†æå®Œæ•´ç®€å†...', 'info');
    }else if(has_online_resume) {
        showToast('æ­£åœ¨åˆ†æåœ¨çº¿ç®€å†...', 'info');
    }else{
        showToast('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†', 'error');
    }
    return htmxAjaxPromise('POST', '/candidates/analyze', {
        source: '#candidate-context',
        target: '#analysis-content',
        swap: 'innerHTML',
        values: {
            'resume_text': resume_text.includes('â³') ? '' : resume_text,
            'full_resume': full_resume.includes('â³') ? '' : full_resume
        }
    }).then(result => {
        console.log('Analysis completed:', result);
        // Extract analysis from data attribute
        const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
        const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
        updateCandidateCard({score: analysis.overall});
    });
}

/**
 * Initialize new chat - reads all data from DOM
 */
function initializeNewChat() {
    showToast('åˆå§‹åŒ–å¯¹è¯çº¿ç¨‹...', 'info');
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    //always use online resume at first time (full resume is not available at first time)
    resume_text = document.getElementById('resume-textarea-online').value
    formData.append('resume_text', resume_text);

    return fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    })
    .then(window.handleApiResponse)
    .then(data => {
        console.log('Chat initialized:', data);
        if (data.conversation_id) {
            updateCandidateData({'conversation_id': data.conversation_id});
        }
        return data.conversation_id;
    });
}


function updateCandidateCard(updates) {
    // Remove keys from updates where value is null or undefined
    // Keep false values to allow clearing tags/badges
    updates = Object.fromEntries(
        Object.entries(updates).filter(([_, v]) => v !== null && v !== undefined && v !== '')
    );
    // Find the candidate card by chat_id, candidate_id, conversation_id, or name+job
    const candidateCards = document.querySelectorAll('.candidate-card');
    let found = false;
    
    // Get name and job_applied from the form for fallback matching
    const chat_id = getCandidateData('chat_id');
    const conversation_id = getCandidateData('conversation_id');
    const candidate_id = getCandidateData('candidate_id');
    const name = getCandidateData('name');
    const job_applied = getCandidateData('job_applied');
    
    candidateCards.forEach(card => {
        const cardData = JSON.parse(card.getAttribute('hx-vals'));
        
        // Match by multiple identifiers:
        // 1. chat_id match (in data or cardId)
        // 2. conversation_id match (direct or in cardId)
        // 3. Fallback: name + job_applied match (for cases where conversation_id isn't in card yet)
        const matches = (chat_id && cardData.chat_id === chat_id) ||
                       (conversation_id && cardData.conversation_id === conversation_id) ||
                       (candidate_id && cardData.candidate_id === candidate_id) ||
                       // Fallback: match by name and job_applied if we have them
                       (name && job_applied &&  cardData.name === name && cardData.job_applied === job_applied);
        
        if (matches) {
            console.log('Found matching candidate card:', { chat_id, conversation_id, cardData, candidate_id });
            // Update the card's data attributes
            Object.assign(cardData, updates);
            // Store conversation_id in card data for future lookups
            if (conversation_id && !cardData.conversation_id) {
                cardData.conversation_id = conversation_id;
            }
            // apply updates to candidateData
            card.setAttribute('hx-vals', JSON.stringify(cardData));
            
            // Update saved tag
            const tagsContainer = card.querySelector('.flex.flex-wrap.gap-1');
            if (updates.saved !== undefined) {
                let savedTag = tagsContainer.querySelector('[data-tag="saved"]');
                if (updates.saved && !savedTag) {
                    savedTag = document.createElement('span');
                    savedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-700';
                    savedTag.setAttribute('data-tag', 'saved');
                    savedTag.textContent = 'ğŸ’¾ å·²ä¿å­˜';
                    tagsContainer.appendChild(savedTag);
                } else if (!updates.saved && savedTag) {
                    savedTag.remove();
                }
            }
            // Update viewed tag
            if (updates.viewed !== undefined) {
                let viewedTag = tagsContainer.querySelector('[data-tag="viewed"]');
                if (updates.viewed && !viewedTag) {
                    viewedTag = document.createElement('span');
                    viewedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-purple-100 text-purple-700';
                    viewedTag.setAttribute('data-tag', 'viewed');
                    viewedTag.textContent = 'ğŸ‘ï¸ å·²æŸ¥çœ‹';
                    tagsContainer.appendChild(viewedTag);
                } else if (!updates.viewed && viewedTag) {
                    viewedTag.remove();
                }
            }
            // Update greeted tag
            if (updates.greeted !== undefined) {
                let greetedTag = tagsContainer.querySelector('[data-tag="greeted"]');
                if (updates.greeted && !greetedTag) {
                    greetedTag = document.createElement('span');
                    greetedTag.className = 'inline-block px-2 py-1 text-xs rounded-full bg-green-100 text-green-700';
                    greetedTag.setAttribute('data-tag', 'greeted');
                    greetedTag.textContent = 'ğŸ‘‹ å·²æ‰“æ‹›å‘¼';
                    tagsContainer.appendChild(greetedTag);
                } else if (!updates.greeted && greetedTag) {
                    greetedTag.remove();
                }
            }
            // Update score badge
            if (updates.score !== undefined) {
                const cardContainer = card.querySelector('.flex.items-start.space-x-3');
                if (cardContainer) {
                    let scoreBadge = cardContainer.querySelector('[data-badge="score"]');
                    if (updates.score !== null && updates.score !== undefined && !scoreBadge) {
                        scoreBadge = document.createElement('div');
                        scoreBadge.className = 'absolute top-0 right-0 bg-gradient-to-r from-blue-500 to-indigo-600 text-white text-xs font-bold px-2 py-1 rounded-bl-lg rounded-tr-lg shadow-md';
                        scoreBadge.setAttribute('data-badge', 'score');
                        scoreBadge.textContent = updates.score.toString();
                        cardContainer.appendChild(scoreBadge);
                    } else if (scoreBadge) {
                        if (updates.score !== null && updates.score !== undefined) {
                            scoreBadge.textContent = updates.score.toString();
                        } else {
                            scoreBadge.remove();
                        }
                    }
                }
            }
            found = true;
            console.log('Updated candidate card:', cardData);
        }
    });
    if (!found) {
        const identifier = chat_id || conversation_id || candidate_id;
        console.warn('updateCandidateCard: could not find card with identifier', identifier, 'total cards:', candidateCards.length);
    }
}

// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================

function updateCandidateData(record) {
    dataElement = document.getElementById('candidate-context');
    const formData = new FormData(dataElement);
    for (const [key, value] of Object.entries(record)) {
        let input = dataElement.querySelector(`input[name="${key}"]`);
        if (input) {
            input.value = value;
        }else{
            // create a input element
            let input = document.createElement('input');
            input.type = 'hidden';
            input.name = key;
            input.value = value;
            dataElement.appendChild(input);
        }
    }
}

function getCandidateData(key) {
    const form = document.getElementById('candidate-context');
    const formData = new FormData(form);
    return formData.get(key);
}


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 5.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0,
        seek_threshold: parseFloat(document.getElementById('threshold-seek')?.value) || 9.0
    };
}

// ============================================================================
// HTMX Promise Wrapper
// ============================================================================

/**
 * Wrap htmx.ajax to return a Promise that resolves when swap completes
 */
 function htmxAjaxPromise(method, url, options) {
    return new Promise((resolve, reject) => {
        const target = document.querySelector(options.target);
        if (!target) {
            reject(new Error(`Target element not found: ${options.target}`));
            return;
        }
        
        // Listen for swap completion
        const afterSwap = (evt) => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            resolve(target.textContent.trim());
        };
        
        const onError = (evt) => {
            target.removeEventListener('htmx:afterSwap', afterSwap);
            target.removeEventListener('htmx:responseError', onError);
            reject(new Error(evt.detail.error || 'HTMX request failed'));
        };
        
        target.addEventListener('htmx:afterSwap', afterSwap, { once: true });
        target.addEventListener('htmx:responseError', onError, { once: true });
        
        // Trigger the ajax call
        htmx.ajax(method, url, options);
    });
}

// ============================================================================
// Batch Processing Function
// ============================================================================

/**
 * Process all candidate cards sequentially
 */
// Global flag for batch processing control
window.batchProcessingActive = false;
window.stopBatchProcessing = false;

async function processAllCandidates() {
    const cards = document.querySelectorAll('.candidate-card');
    if (cards.length === 0) {
        showToast('æ²¡æœ‰æ‰¾åˆ°å€™é€‰äºº', 'warning');
        return;
    }
    
    const total = cards.length;
    let processed = 0;
    let failed = 0;
    
    // Set batch processing flag
    window.batchProcessingActive = true;
    window.stopBatchProcessing = false;
    
    // Disable all candidate cards
    cards.forEach(card => {
        card.style.pointerEvents = 'none';
        card.style.opacity = '0.6';
    });
    
    // Update button to stop button
    const batchBtn = document.getElementById('batch-analyze-btn');
    if (batchBtn) {
        batchBtn.disabled = false;
        batchBtn.textContent = 'â¸ åœæ­¢å¤„ç†';
        batchBtn.onclick = stopBatchProcessingHandler;
        batchBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
        batchBtn.classList.add('bg-red-600', 'hover:bg-red-700');
    }
    
    showToast(`å¼€å§‹æ‰¹é‡å¤„ç† ${total} ä¸ªå€™é€‰äºº`, 'info');
    
    for (let i = 0; i < cards.length; i++) {
        // Check if user requested stop
        if (window.stopBatchProcessing) {
            showToast(`æ‰¹é‡å¤„ç†å·²åœæ­¢ (${processed}/${total} å®Œæˆ)`, 'warning');
            break;
        }
        
        const card = cards[i];
        const cardData = JSON.parse(card.getAttribute('hx-vals'));
        const name = cardData.name || `å€™é€‰äºº ${i + 1}`;
        
        showToast(`æ­£åœ¨å¤„ç†å€™é€‰äºº ${i + 1}/${total}: ${name}`, 'info');
        
        try {
            // Wait for HTMX swap to complete
            await new Promise((resolve, reject) => {
                const detailPane = document.getElementById('detail-pane');
                if (!detailPane) {
                    reject(new Error('Detail pane not found'));
                    return;
                }
                
                const timeout = setTimeout(() => {
                    detailPane.removeEventListener('htmx:afterSwap', onSwap);
                    detailPane.removeEventListener('htmx:responseError', onError);
                    reject(new Error('HTMX swap timeout'));
                }, 10000); // 10 second timeout for swap
                
                const onSwap = () => {
                    clearTimeout(timeout);
                    detailPane.removeEventListener('htmx:afterSwap', onSwap);
                    detailPane.removeEventListener('htmx:responseError', onError);
                    // Wait a bit for DOM to be ready
                    setTimeout(resolve, 200);
                };
                
                const onError = (evt) => {
                    clearTimeout(timeout);
                    detailPane.removeEventListener('htmx:afterSwap', onSwap);
                    detailPane.removeEventListener('htmx:responseError', onError);
                    reject(new Error(evt.detail.error || 'HTMX request failed'));
                };
                
                detailPane.addEventListener('htmx:afterSwap', onSwap, { once: true });
                detailPane.addEventListener('htmx:responseError', onError, { once: true });
                
                // Trigger HTMX click
                htmx.trigger(card, 'click');
            });
            
            // Wait for process_candidate() to complete
            await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    reject(new Error('Processing timeout (60s)'));
                }, 60000); // 60 second timeout
                
                const onComplete = (event) => {
                    clearTimeout(timeout);
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    resolve(event.detail);
                };
                
                const onError = (event) => {
                    clearTimeout(timeout);
                    document.removeEventListener('candidate:processing-complete', onComplete);
                    document.removeEventListener('candidate:processing-error', onError);
                    reject(new Error(event.detail.error || 'Processing failed'));
                };
                
                document.addEventListener('candidate:processing-complete', onComplete, { once: true });
                document.addEventListener('candidate:processing-error', onError, { once: true });
            });
            
            processed++;
            showToast(`âœ… ${name} å¤„ç†å®Œæˆ (${processed}/${total})`, 'success');
        } catch (error) {
            failed++;
            console.error(`Failed to process candidate ${i + 1}:`, error);
            showToast(`âŒ ${name} å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            // Continue to next candidate
        }
    }
    
    // Re-enable candidate cards
    cards.forEach(card => {
        card.style.pointerEvents = '';
        card.style.opacity = '';
    });
    
    // Reset batch processing flag
    window.batchProcessingActive = false;
    window.stopBatchProcessing = false;
    
    // Reset button
    if (batchBtn) {
        batchBtn.disabled = false;
        batchBtn.textContent = 'å…¨éƒ¨åˆ†æ';
        batchBtn.onclick = processAllCandidates;
        batchBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
        batchBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
    }
    
    // Final summary
    const summary = `æ‰¹é‡å¤„ç†å®Œæˆ: æˆåŠŸ ${processed}/${total}, å¤±è´¥ ${failed}`;
    showToast(summary, processed === total ? 'success' : 'warning');
}

function stopBatchProcessingHandler() {
    window.stopBatchProcessing = true;
    const batchBtn = document.getElementById('batch-analyze-btn');
    if (batchBtn) {
        batchBtn.disabled = true;
        batchBtn.textContent = 'æ­£åœ¨åœæ­¢...';
    }
    showToast('æ­£åœ¨åœæ­¢æ‰¹é‡å¤„ç†...', 'info');
}

// Make function globally available
window.processAllCandidates = processAllCandidates;

// Trigger workflow when this partial is loaded via HTMX
// Since this script runs when HTMX swaps content, we can call it directly
// Use requestAnimationFrame to ensure DOM is ready
requestAnimationFrame(() => {
    // Set initial tab state - show online tab if resume_text exists, otherwise show full tab
    const onlineTextarea = document.getElementById('resume-textarea-online');
    const fullTextarea = document.getElementById('resume-textarea-full');
    const hasOnline = onlineTextarea?.value?.trim();
    const hasFull = fullTextarea?.value?.trim();
    
    if (hasOnline) {
        switchResumeTab('online');
    } else if (hasFull) {
        switchResumeTab('full');
    } else {
        // Default to online tab
        switchResumeTab('online');
    }
    
    process_candidate();
});

</script>
