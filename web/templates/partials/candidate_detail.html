<!-- Candidate detail view with automatic workflow 
    the passed data:
    - "analysis": data.pop("analysis"),
    - "generated_message": data.pop("last_message"),
    - "resume_text": data.pop("resume_text"),
    - "full_resume": data.pop("full_resume"),
    - "candidate": data,
-->
<div id="candidate-detail-root" class="space-y-6" data-view-mode="{{ view_mode or 'interactive' }}">
    <!-- Header -->
    <div class="flex justify-between items-start">
        <div class="flex items-center gap-2">
            <h2 class="text-2xl font-bold text-gray-900">{{ candidate.name or 'æœªçŸ¥å€™é€‰äºº' }}</h2>
            <button 
                id="copy-link-btn"
                onclick="copyCandidateLink()"
                class="p-1.5 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded transition hidden"
                title="å¤åˆ¶å€™é€‰äººè¯¦æƒ…é“¾æ¥"
                style="display: none;">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                </svg>
            </button>
        </div>
        <div class="flex space-x-2">
            {% if candidate.stage %}
            <span class="px-4 py-2 rounded-lg font-medium
                {% if candidate.stage == 'PASS' %}bg-gray-200 text-gray-700
                {% elif candidate.stage == 'GREET' %}bg-green-200 text-green-700
                {% elif candidate.stage == 'SEEK' %}bg-yellow-200 text-yellow-700
                {% elif candidate.stage == 'CONTACT' %}bg-blue-200 text-blue-700
                {% else %}bg-gray-100 text-gray-600{% endif %}">
                {{ candidate.stage }}
            </span>
            {% endif %}
        </div>
    </div>
    
    <!-- Contact Information Section -->
    {% set metadata = candidate.metadata if candidate.metadata else {} %}
    {% set phone_number = metadata.phone_number if metadata and metadata.phone_number else None %}
    {% set wechat_number = metadata.wechat_number if metadata and metadata.wechat_number else None %}
    {% if phone_number or wechat_number %}
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
        <div class="flex flex-wrap gap-4">
            {% if phone_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="font-mono text-blue-700">{{ phone_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">ç”µè¯:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
            {% if wechat_number %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="font-mono text-blue-700">{{ wechat_number }}</span>
            </div>
            {% else %}
            <div class="flex items-center space-x-2">
                <span class="text-gray-600">å¾®ä¿¡:</span>
                <span class="text-gray-400">æœªè·å–</span>
            </div>
            {% endif %}
        </div>
    </div>
    {% endif %}
    
    {% if candidate.name and ('å…ˆç”Ÿ' in candidate.name or 'å¥³å£«' in candidate.name) and candidate.chat_id and candidate.mode == 'recommend' %}
        <div class="flex items-center space-x-2 bg-yellow-100 border-l-4 border-yellow-400 text-yellow-800 px-4 py-2 rounded shadow-sm my-2">
            <span>âš ï¸</span>
            <span>
                æ£€æµ‹åˆ°å€™é€‰äººå§“ååŒ…å«<strong>ã€Œå…ˆç”Ÿã€</strong>æˆ–<strong>ã€Œå¥³å£«ã€</strong>ï¼Œå¯¼è‡´æ•°æ®å¯èƒ½é‡å¤ï¼Œè¯·è®¤çœŸæ£€æŸ¥ä»¥ä¸‹å†…å®¹æ˜¯å¦å’Œæ‹›è˜ç½‘ç«™ä¸€è‡´ã€‚å¦‚æœä¸ä¸€è‡´ï¼Œè¯·é‡æ–°è·å–ç®€å†ã€‚
            </span>
        </div>
    {% endif %}

    <!-- Hidden context for HTMX requests - using JSON to preserve types -->
    <div id="candidate-context" class="hidden" hx-vals='{{ candidate | tojson | safe }}'></div>
    
    
    <!-- 1. Resume Section -->
    <div id="resume-section" class="bg-white rounded-lg border shadow-sm">
        <!-- <div class="p-2 border-b bg-gray-50">
            <h3 class="font-bold text-gray-800">ğŸ“„ å€™é€‰äººç®€å†</h3>
        </div> -->
        <!-- Tab Navigation -->
        <div class="flex border-b bg-gray-100 items-center">
            <button id="tab-online" onclick="switchResumeTab('online')" 
                    class="px-4 py-2 font-medium text-sm transition-colors bg-white border-b-2 border-blue-500 text-blue-600">
                åœ¨çº¿ç®€å†
            </button>
            <button id="tab-full" onclick="switchResumeTab('full')" 
                    class="px-4 py-2 font-medium text-sm transition-colors text-gray-600 hover:text-gray-800">
                å®Œæ•´ç®€å†
            </button>
            <div class="flex-1"></div>
            <button 
                id="fetch-online-resume-btn"
                onclick="fetchOnlineResume()"
                class="px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–åœ¨çº¿ç®€å†</span>
            </button>
            <button 
                id="fetch-full-resume-btn"
                onclick="fetchFullResume().catch(err => console.warn('Re-fetch failed:', err))"
                class="hidden px-3 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200 transition flex items-center gap-1 mr-2">
                <span>ğŸ”„</span>
                <span>é‡æ–°è·å–å®Œæ•´ç®€å†</span>
            </button>
        </div>
        <!-- Tab Content -->
        <div id="resume-content" class="p-2"> 
            <!-- Online Resume Tab -->
            <div id="tab-content-online" class="tab-content">
                <div id="resume-online-container">
                    <textarea id="resume-textarea-online" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if resume_text -%}{{ resume_text }}{%- else -%}â³ æ­£åœ¨åŠ è½½åœ¨çº¿ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
            <!-- Full Resume Tab -->
            <div id="tab-content-full" class="tab-content hidden">
                <div id="resume-full-container">
                    <textarea id="resume-textarea-full" readonly class="w-full h-64 p-2 bg-gray-50 border rounded-lg font-mono text-sm">
                        {%- if full_resume -%}{{ full_resume }}{%- else -%}â³ æ­£åœ¨åŠ è½½å®Œæ•´ç®€å†...{%- endif -%}
                    </textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- 2. Analysis Section -->
    <div id="analysis-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">ğŸ“Š AI åˆ†æç»“æœ</h3>
            <div id="analysis-resume-type-badge" class="ml-3">
                <!-- Will be populated by JavaScript based on analysis result -->
            </div>
            <div class="flex-1"></div>
            <button onclick="startAnalysis()"
                    class="px-3 py-1 text-xs bg-purple-100 text-purple-700 rounded hover:bg-purple-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°åˆ†æ</span>
            </button>
        </div>
        <div id="analysis-content" class="p-2">
            {% if analysis %}
                {% include 'partials/analysis_result.html' %}
            {% else %}
            <div class="text-center p-4 text-gray-500">â³ ç­‰å¾…ç®€å†åŠ è½½å®Œæˆåè‡ªåŠ¨åˆ†æ...</div>
            {% endif %}
        </div>
    </div>

    <!-- 3. Generated Message Section (shown only in interactive/write mode) -->
    {% if view_mode != 'readonly' %}
    <div id="message-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">âœ¨ è‡ªåŠ¨ç”Ÿæˆæ¶ˆæ¯</h3>
            <div class="flex-1"></div>
            <button onclick="generateMessage(force = true)"
                    class="px-3 py-1 text-xs bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200 transition flex items-center gap-1">
                <span>ğŸ”„</span>
                <span>é‡æ–°ç”Ÿæˆæ¶ˆæ¯</span>
            </button>
        </div>
        <div id="message-content" class="p-2">
            {% set chat_history_for_message = metadata.history if metadata and metadata.history else [] %}
            {% set ns = namespace(message='', action='', reason='', payload=None, placeholder='') %}
            {% for msg in chat_history_for_message | reverse %}
                {% if ns.payload is none and msg.role == 'assistant' %}
                    {% set candidate_payload = msg.payload if msg.payload is defined and msg.payload else (msg.content if msg.content is mapping else None) %}
                    {% set ns.payload = candidate_payload %}
                    {% if candidate_payload %}
                        {% set ns.action = candidate_payload.action if candidate_payload.action else (msg.action if msg.action is defined else '') %}
                        {% set ns.reason = candidate_payload.reason if candidate_payload.reason else (msg.reason if msg.reason is defined else '') %}
                        {% set ns.message = candidate_payload.message if candidate_payload.message else (msg.content or msg.message or '') %}
                    {% else %}
                        {% set ns.message = msg.content or msg.message or '' %}
                    {% endif %}
                {% endif %}
            {% endfor %}
            {% if generated_message not in ['', 'None', 'null', None] %}
                {% set ns.message = generated_message %}
            {% elif not ns.message %}
                {# Only show as textarea placeholder; never prefill as message to avoid accidental sending. #}
                {% set ns.placeholder = 'â³åˆ†æå®Œæˆåï¼Œå¦‚æœåŒ¹é…åº¦è¾¾æ ‡ï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ...' %}
            {% endif %}
            {% set message = ns.message %}
            {% set action = ns.action %}
            {% set reason = ns.reason %}
            {% set payload = ns.payload %}
            {% set placeholder_message = ns.placeholder %}
            {% include 'partials/message_result.html' with context %}
        </div>
        <div class="flex p-2 gap-2">
            <button onclick="greetAndSendMessage()"
                    class="px-4 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-800">
                ğŸ“¤ æ‰“æ‹›å‘¼+å‘é€æ¶ˆæ¯
            </button>
            <button onclick="passCandidate()"
                    class="px-4 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-800">
                âŒ PASS
            </button>
        </div>
    </div>
    {% endif %}

    <!-- 4. Chat History Section (shown only in readonly mode) -->
    {% if view_mode == 'readonly' %}
    {% set chat_history = metadata.history if metadata and metadata.history else [] %}
    {% if chat_history %}
    <div id="chat-history-section" class="bg-white rounded-lg border shadow-sm">
        <div class="flex border-b bg-gray-100 items-center p-2">
            <h3 class="font-bold text-gray-800">ğŸ’¬ èŠå¤©å†å²</h3>
        </div>
        <div class="p-2 space-y-2 max-h-48 overflow-y-auto">
            {% for msg in chat_history %}
            {% set is_candidate = msg.role == 'user' %}
            {% set is_developer = msg.role == 'developer' %}
            {% if is_developer %}
                <!-- Developer message: centered gray box -->
                <div class="flex justify-center">
                    <div class="bg-gray-200 rounded-lg p-2 max-w-[80%]">
                        <p class="text-gray-600 whitespace-pre-wrap text-xs text-center">{{ msg.content or msg.message or '' }}</p>
                    </div>
                </div>
            {% else %}
                {% set bg_color = 'bg-blue-50' if is_candidate else 'bg-gray-50' %}
                {% set icon = 'ğŸ‘¼' if is_candidate else 'ğŸ‘¨â€ğŸ’»â€' %}
                {% set align_class = 'justify-start' if is_candidate else 'justify-end' %}
                {% set text_align = 'text-left' if is_candidate else 'text-right' %}
                {% set payload = msg.payload if msg.payload is defined and msg.payload else (msg.content if msg.content is mapping else None) %}
                {% set display_text = payload.message if payload and payload.message else (msg.content or msg.message or '') %}
                <div class="flex {{ align_class }}">
                    <div class="{{ bg_color }} rounded-lg p-3 max-w-[80%]">
                        <div class="flex items-start space-x-2 {{ 'flex-row-reverse' if not is_candidate else '' }}">
                            <span class="text-lg">{{ icon }}</span>
                            <div class="flex-1 {{ text_align }}">
                                <div class="flex {{ 'justify-between' if is_candidate else 'justify-end' }} items-start mb-1">
                                    {% if is_candidate %}
                                        <span class="font-medium text-gray-900 text-xs">
                                            {{ candidate.name or 'å€™é€‰äºº' }}
                                        </span>
                                        {% if msg.timestamp %}
                                        <span class="text-xs text-gray-500 ml-2">{{ msg.timestamp }}</span>
                                        {% endif %}
                                    {% else %}
                                        {% if msg.timestamp %}
                                        <span class="text-xs text-gray-500">{{ msg.timestamp }}</span>
                                        {% endif %}
                                        <span class="font-medium text-gray-900 text-xs ml-2">
                                            æ‹›è˜é¡¾é—®
                                        </span>
                                    {% endif %}
                                </div>
                                {% if payload and payload.action %}
                                <div class="mb-1">
                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-[10px] font-medium bg-indigo-100 text-indigo-700">
                                        {{ payload.action }}
                                    </span>
                                </div>
                                {% endif %}
                                <p class="text-gray-700 whitespace-pre-wrap text-sm">{{ display_text }}</p>
                                {% if payload and payload.reason %}
                                <p class="text-gray-500 whitespace-pre-wrap text-xs mt-2">{{ payload.reason }}</p>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                </div>
            {% endif %}
            {% endfor %}
        </div>
    </div>
    {% endif %}
    {% endif %}

    {% if candidate.updated_at %}
    {% set display_time = candidate.updated_at.replace('T', ' ')[:19] %}
    <p class="text-sm text-gray-500 mt-1">æ›´æ–°æ—¶é—´: {{ display_time }}</p>
    {% endif %}
</div>

<!-- Centralized Candidate Analysis & Workflow Logic -->
<script>
// Initialize root and view mode (runs on each HTMX swap)
// Use var to allow redeclaration when HTMX swaps content multiple times
var root = document.getElementById('candidate-detail-root');
var viewMode = root?.dataset?.viewMode || 'interactive';
// Persist on window for other scripts
window.__candidate_detail_root = window.__candidate_detail_root || root;
window.__candidate_detail_view_mode = window.__candidate_detail_view_mode || viewMode;

async function process_candidate() {
    let newStage, currentScore, analysis;
    try {
        // Step 0: short-circuit if already PASS
        if (getCandidateData('stage') === 'PASS') {
            return;
        }

        // Step 1: Ensure resume is loaded
        const onlineResume = document.getElementById('resume-textarea-online');
        if (!onlineResume?.value || onlineResume.value.includes('â³') || onlineResume.value.length < 100) {
            await fetchOnlineResume();
        }

        // Step 2: Initialize chat if no conversation_id
        if (!getCandidateData('conversation_id')) {
            await initializeNewChat();
        }

        // Step 3: Start analysis if not rendered or pending
        const analysisDiv = document.getElementById('analysis-content');
        const hasAnalysis = !!document.querySelector('#analysis-content #analysis-result-container');
        if (!hasAnalysis || analysisDiv?.textContent?.includes('â³')) {
            await startAnalysis();
        }

        // Step 4: Determine stage (PASS/CHAT/SEEK by score thresholds)
        [newStage, currentScore, analysis] = determineStage();
        let isFullAnalysis = analysis?.resume_type === 'full';
        let needReply = await shouldReply();
        const mode = getCandidateData('mode');
        const handleChatAction = async (gen) => {
            const action = gen?.action || '';
            if (action === 'PASS') {
                newStage = 'PASS';
                const reason = gen?.reason || '';
                await passCandidate(reason);
                return true;
            }
            if (action === 'WAIT') {
                return true;
            }
            if (action === 'CONTACT') {
                newStage = 'CONTACT';
                if (!getCandidateData('notified')) {
                    await sendDingNotification(analysis, getCandidateData('name'), getCandidateData('job_applied'));
                }
                await greetAndSendMessage();
                if (mode !== 'recommend') {
                    await requestContact();
                }
                return true;
            }
            await greetAndSendMessage();
            return false;
        };

        // Hard stop: score-based PASS (must still emit completion event for batch runner)
        if (currentScore <= 4) {
            await passCandidate('åˆ†æ•°ä½äº 4ï¼Œä¸åŒ¹é…');
            newStage = 'PASS';
            return;
        }

        // Step 4a: CHAT stage -> generate message if needed
        if (newStage === 'CHAT' && needReply) {
            const gen = await generateMessage(false);
            console.log('Generated message:', gen);
            if (await handleChatAction(gen)) return;
            needReply = false;
        }

        // Step 4b/4c: SEEK stage -> (chat mode) fetch full resume and re-analyze; then followup generation if needed
        if (newStage === 'SEEK') {
            if (mode !== 'recommend') {
                let fullResume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                if (fullResume.includes('â³') || fullResume.length < 100) {
                    await fetchFullResume();
                    fullResume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
                }
                if (!isFullAnalysis && fullResume.length > 100) {
                    await startAnalysis();
                    [newStage, currentScore, analysis] = determineStage();
                    isFullAnalysis = analysis?.resume_type === 'full';
                    if (newStage === 'SEEK') {
                        needReply = true;
                    }
                }
            }

            if (needReply && !getCandidateData('notified')) {
                await sendDingNotification(analysis, getCandidateData('name'), getCandidateData('job_applied'));
            }

            if (needReply) {
                const gen = await generateMessage(false);
                if (await handleChatAction(gen)) return;
                needReply = false;
            }
        }
    } catch (error) {
        console.error('Error processing candidate:', error);
        error_message = error.message || String(error);
        showToast(`å¤„ç†å€™é€‰äººæ—¶å‡ºé”™: ${error_message}`, 'error');
        document.dispatchEvent(new CustomEvent('candidate:processing-error', { detail: { error: error_message } }));
    } finally {
        // update the candidate data in the cloud
        await updateCandidateData({ viewed: true, score: currentScore, stage: newStage });
        if (!window.cycleReplyState?.running) {
            // enable the candidate cards
            document.dispatchEvent(new CustomEvent('candidates:enable-cards'));
        }
        // dispatch the candidate:processing-complete event to the candidate cards
        document.dispatchEvent(new CustomEvent('candidate:processing-complete'));
    }
}

/**
 * Send DingTalk notification when candidate score exceeds borderline threshold
 */
async function sendDingNotification(analysis, candidateName, jobApplied) {
    // Get candidate data for server-side notification
    const candidate = getCandidateData();
    const notified = candidate.notified;
    
    // Skip if already notified
    if (notified) {
        showToast('å€™é€‰äººå·²é€šçŸ¥è¿‡ï¼Œè·³è¿‡é€šçŸ¥', 'info');
        return;
    }
    
    // Send analysis data to server - server will format the message
    const response = await fetch('/candidates/notify', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            ...candidate,
            analysis: analysis 
        })
    });
    const result = await window.handleApiResponse(response);
    
    // Update candidate data with notified status if notification was successful
    if (result && result.success) {
        await updateCandidateData({ notified: true });
    }
}

async function fetchOnlineResume() {
    showToast('æŠ“å–åœ¨çº¿ç®€å†...', 'info');
    const values = getCandidateData();
    await htmxAjaxPromise('POST', '/candidates/fetch-online-resume', {
        target: '#resume-online-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to online tab after fetch
    switchResumeTab('online');
}

async function fetchFullResume() {
    const values = getCandidateData();
    const mode = values.mode;
    if (mode === 'recommend') {
        return;
    }
    showToast('æŠ“å–å®Œæ•´ç®€å†...', 'info');

    await htmxAjaxPromise('POST', '/candidates/fetch-full-resume', {
        target: '#resume-full-container',
        swap: 'innerHTML',
        values: values
    });
    // Switch to full tab after fetch
    switchResumeTab('full');
}

function getMessageResultState(purpose = '') {
    const container = document.getElementById('message-result-container');
    const textarea = document.getElementById('message-text');
    const message = textarea?.value?.trim() || '';
    const action = container?.dataset?.action || '';
    const reason = container?.dataset?.reason || '';
    let payload = null;
    const payloadStr = container?.dataset?.payload;
    if (payloadStr) {
        try {
            payload = JSON.parse(payloadStr);
        } catch (e) {
            payload = null;
        }
    }
    return { action, reason, message, purpose, payload };
}

async function generateMessage(force = false) {
    showToast('ç”Ÿæˆæ¶ˆæ¯...', 'info');
    const values = getCandidateData();
    const mode = values.mode;
    // if force is true or mode is followup, use followup action
    const purpose = (force || mode == 'followup') ? 'FOLLOWUP_ACTION' : 'CHAT_ACTION';
    await htmxAjaxPromise('POST', '/candidates/generate-message', {
        target: '#message-content',
        swap: 'innerHTML',
        values: {...values, purpose: purpose}
    });
    const state = getMessageResultState(purpose);
    console.log('Generated message:', state);
    await updateCandidateData({generated_message: state.message});
    return state;
}

async function greetAndSendMessage() {
    const autoSend = document.getElementById('auto-send-checkbox')?.checked ?? true;
    const message_textarea = document.getElementById('message-text');
    const message = message_textarea.value.trim();
    const action = document.getElementById('message-result-container')?.dataset?.action || '';
    const mode = getCandidateData('mode');
    let values = getCandidateData();
    if (message === '' || !autoSend) {
        return;
    }
    values.message = message;
    // Remove keys with null or undefined values
    values = Object.fromEntries(
        Object.entries(values).filter(([key, value]) => value !== null && value !== undefined)
    );

    // check if we should send message
    if (!autoSend) {
        if (mode === 'recommend') {
            values.message = '';// if mode is thanrecommend and auto send is false, greet only
        } else {
            return; // skip sending message if auto send is false and mode is not recommend
        }
    }

    // send message
    await htmxAjaxPromise('POST', '/candidates/send', {
        target: '#message-content',
        swap: 'none',
        values: values
    });

    // Show browser notification after successful message send
    const candidateName = getCandidateData('name') || 'å€™é€‰äºº';
    const notificationTitle = `å·²å‘ ${candidateName} å‘é€æ¶ˆæ¯`;
    await showBrowserNotification(notificationTitle, message);
    
    // Update to CHAT stage
    const currentStage = getCandidateData('stage');
    const nextStage = (action === 'CONTACT') ? 'CONTACT' : (currentStage || 'CHAT');
    await updateCandidateData({
        stage: nextStage,
        greeted: true
    });
}


/**
 * Start analysis (current flow)
 */
async function startAnalysis() {
    const resume_text = document.getElementById('resume-textarea-online')?.value?.trim() || '';
    const full_resume = document.getElementById('resume-textarea-full')?.value?.trim() || '';
    const has_full_resume = !full_resume.includes('â³') && full_resume.length > 0;
    const has_online_resume = !resume_text.includes('â³') && resume_text.length > 0;
    
    if (has_full_resume) {
        showToast('æ­£åœ¨åˆ†æå®Œæ•´ç®€å†...', 'info');
    } else if(has_online_resume) {
        showToast('æ­£åœ¨åˆ†æåœ¨çº¿ç®€å†...', 'info');
    } else {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
    }
    
    const values = getCandidateData();
    values.resume_text = resume_text.includes('â³') ? '' : resume_text;
    values.full_resume = full_resume.includes('â³') ? '' : full_resume;
    
    const result = await htmxAjaxPromise('POST', '/candidates/analyze', {
        target: '#analysis-content',
        swap: 'innerHTML',
        values: values
    });
    console.log('Analysis completed:', result.overall);
    // Extract analysis from data attribute
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    await updateCandidateData({score: analysis?.overall});
    
    // Update resume type badge in tab row
    updateAnalysisResumeTypeBadge(analysis);
}

/**
 * Update the resume type badge in the analysis section tab row
 */
function updateAnalysisResumeTypeBadge(analysis) {
    const badgeContainer = document.getElementById('analysis-resume-type-badge');
    if (badgeContainer && analysis) {
        const resumeType = analysis.resume_type || 'online';
        const badgeClass = resumeType === 'full' 
            ? 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-indigo-100 text-indigo-700'
            : 'inline-block px-3 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-700';
        const badgeText = resumeType === 'full' ? 'ğŸ“„ å®Œæ•´ç®€å†' : 'ğŸŒ åœ¨çº¿ç®€å†';
        badgeContainer.innerHTML = `<span class="${badgeClass}">${badgeText}</span>`;
    }
}

/**
 * Request contact information from candidate
 */
async function requestContact() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const candidate_id = values.candidate_id;
    const mode = values.mode;
    
    // Skip contact request for recommend mode (no chat_id available)
    if (mode === 'recommend' || !chat_id) {
        showToast('æ¨èæ¨¡å¼ä¸æ”¯æŒè¯·æ±‚è”ç³»æ–¹å¼', 'info');
        return;
    }
    // å¦‚æœå·²æœ‰è”ç³»æ–¹å¼ï¼Œåˆ™ä¸é‡å¤è¯·æ±‚
    if (values.metadata?.phone_number || values.metadata?.wechat_number) {
        return;
    }
    
    showToast('è¯·æ±‚è”ç³»æ–¹å¼...', 'info');
    
    // Call new endpoint with both chat_id and candidate_id
    const response = await fetch('/candidates/request-contact', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            chat_id: chat_id,
            candidate_id: candidate_id 
        })
    });
    const data = await window.handleApiResponse(response);
    console.log('Contact requested:', data);
    
    // Update candidate data with contact info in metadata
    // metadata merging is now handled in backend upsert_candidate()
    if (data && (data.phone_number || data.wechat_number)) {
        await updateCandidateData({
            stage: 'CONTACT',
            metadata: {
                phone_number: data.phone_number,
                wechat_number: data.wechat_number,
            }
        });
        
        // Update contact info display dynamically
        updateContactInfoDisplay(data.phone_number, data.wechat_number);
        
        showToast('è”ç³»æ–¹å¼å·²è·å–å¹¶ä¿å­˜', 'success');
    } else if (data && data.success !== false) {
        // Contact request succeeded but no numbers obtained yet
        await updateCandidateData({stage: 'CONTACT'});
    }
}

/**
 * Update contact information display in the DOM
 */
function updateContactInfoDisplay(phoneNumber, wechatNumber) {
    // Check if contact info section exists
    let contactSection = document.querySelector('.bg-blue-50.border.border-blue-200');
    
    if (!contactSection && (phoneNumber || wechatNumber)) {
        // Create contact info section if it doesn't exist
        const header = document.querySelector('#candidate-detail-root > div.flex.justify-between');
        if (header && header.nextElementSibling) {
            contactSection = document.createElement('div');
            contactSection.className = 'bg-blue-50 border border-blue-200 rounded-lg p-4';
            contactSection.innerHTML = `
                <h3 class="font-semibold text-gray-800 mb-2">ğŸ“ è”ç³»æ–¹å¼</h3>
                <div class="flex flex-wrap gap-4" id="contact-info-content"></div>
            `;
            header.parentNode.insertBefore(contactSection, header.nextElementSibling);
        }
    }
    
    if (contactSection) {
        const contentDiv = contactSection.querySelector('#contact-info-content') || contactSection.querySelector('.flex.flex-wrap');
        if (contentDiv) {
            let html = '';
            if (phoneNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="font-mono text-blue-700">${phoneNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">ç”µè¯:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            if (wechatNumber) {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="font-mono text-blue-700">${wechatNumber}</span>
                </div>`;
            } else {
                html += `<div class="flex items-center space-x-2">
                    <span class="text-gray-600">å¾®ä¿¡:</span>
                    <span class="text-gray-400">æœªè·å–</span>
                </div>`;
            }
            contentDiv.innerHTML = html;
        }
    }
}

/**
 * Initialize new chat - reads all data from DOM
 */
async function initializeNewChat() {
    let candidate = getCandidateData();
    //always use online resume at first time (full resume is not available at first time)
    const resume_text = document.getElementById('resume-textarea-online')?.value;
    if (!resume_text) {
        throw new Error('æ²¡æœ‰å¯åˆ†æçš„ç®€å†,è¯·å…ˆè¯·æ±‚ç®€å†');
        return;
    }
    candidate.resume_text = resume_text;

    const formData = new FormData();
    for (const [key, value] of Object.entries(candidate)) {
        if (value !== null && value !== undefined) {
            formData.append(key, value);
        }
    }

    const response = await fetch('/candidates/init-chat', {
        method: 'POST',
        body: formData
    });
    candidate = await window.handleApiResponse(response);
    console.log('Chat initialized:', candidate);
    await updateCandidateData(candidate);
    return candidate.candidate_id;
}


// ============================================================================
// Candidate Detail Helper Functions
// ============================================================================
function determineStage() {
    let stage = 'PASS';
    const analysis_container = document.querySelector('#analysis-content #analysis-result-container');
    const { chat_threshold, borderline_threshold } = getThresholdValues();
    const analysis = analysis_container ? JSON.parse(analysis_container.getAttribute('data-analysis')) : null;
    const {overall, skill, startup_fit, background} = analysis || {};
    if (overall <= 4) {
        stage = 'PASS';
        return [stage, overall, analysis];
    }
    if (overall >= borderline_threshold){
        stage = 'SEEK';
    } else if(overall >= chat_threshold || skill >= borderline_threshold || startup_fit >= borderline_threshold || background >= borderline_threshold){
        stage = 'CHAT';
    }
    return [stage, overall, analysis];
}

async function passCandidate(reason = '') {
    debugger;
    url = '/candidates/pass';
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const candidate_id = values.candidate_id;
    const index = values.index;
    const mode = values.mode;
    const response = await fetch(url, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            mode: mode,
            index: index,
            chat_id: chat_id,
            candidate_id: candidate_id
        })
    });
    try{
        const data = await window.handleApiResponse(response);
        console.log('Candidate passed:', data);
        await updateCandidateData({stage: 'PASS'});
    } catch (error) {
        console.error('Failed to pass candidate:', error);
    }
    
    // Remove card with fade out animation
    const identifiers = {
        chat_id: chat_id,
        candidate_id: candidate_id,
        conversation_id: values.conversation_id,
        index: index
    };
    
    // Dispatch event to remove card with animation
    const event = new CustomEvent('candidate:remove', {
        detail: { identifiers: identifiers }
    });
    document.dispatchEvent(event);
    
    // Show toast with reason if available
    let toastMessage = `å€™é€‰äºº${values.name}å·²æ ‡è®°ä¸º PASSï¼š${reason}`;
    showToast(toastMessage, 'success');
}


/**
 * Check if we should reply based on chat history
 * Returns true if last message is from user, false if from assistant
 */
async function shouldReply() {
    const values = getCandidateData();
    const chat_id = values.chat_id;
    const mode = values.mode;
    const greeted = values.greeted;
    const autoSend = document.getElementById('auto-send-checkbox')?.checked ?? true;
    // If greeted and updated_at is less than 10 minutes ago, don't reply
    const updatedAt = new Date(values.updated_at);
    const now = new Date();
    const diffMs = now - updatedAt;
    const diffMinutes = diffMs / (1000 * 60);
    if (greeted && values.updated_at) {
        if (diffMinutes < 10) {
            return false;
        }
    }
    // For recommend mode, only rely on greeted flag
    if (mode === 'recommend') {
        return !greeted; // if not greeted, we need to reply
    }else if (mode === 'followup' && diffMinutes > 60*24*1) {
        return true; // if updated_at is more than 1 day ago, we need to reply
    }
    // for other modes, check if we should reply based on chat history
    const response = await fetch('/candidates/should-reply', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ 
            chat_id: chat_id,
            mode: mode
        })
    });
    const data = await window.handleApiResponse(response);
    const should_reply = data.should_reply === true;
    return should_reply;
}


/**
 * Update candidate data in the form and broadcast update to card
 * This function combines both updateCandidateData and updateCandidateCard
 */
async function updateCandidateData(data) {
    data.saved = true
    data = Object.fromEntries(
        Object.entries(data).filter(([k, v]) => v !== null && v !== undefined && v !== '')
    );
    
    // Get current data from hx-vals
    const currentData = getCandidateData();
    // get the updated fields
    const updates = Object.fromEntries(
        Object.entries(data).filter(([k, v]) => v!== currentData[k] && v !== null && v !== undefined && v !== '')
    );
    // update the resume, analysis and generated_message fields, since these fields are from server, no need to update the stored data
    if (data.resume_text) {
        document.getElementById('resume-textarea-online').value = data.resume_text;
        document.getElementById('resume-textarea-online').textContent = data.resume_text;
        delete data.resume_text;
    }
    if (data.full_resume) {
        document.getElementById('resume-textarea-full').value = data.full_resume;
        document.getElementById('resume-textarea-full').textContent = data.full_resume;
        delete data.full_resume;
    }
    if (data.analysis) {
        // use server-side rendering to render the analysis result
        await htmxAjaxPromise('POST', '/candidates/render-analysis-result', {
            swap: 'innerHTML',
            values: { analysis: JSON.stringify(data.analysis) },
            target: '#analysis-content',
        });
        delete data.analysis;
    }
    if (data.generated_message) {
        const messageTextArea = document.getElementById('message-text')
        messageTextArea.value = data.generated_message;
        messageTextArea.textContent = data.generated_message;
        // delete data.generated_message; //ä¿ç•™generated_messageï¼Œç”¨äºæ›´æ–°UIï¼ŒåŒæ—¶ä¿ç•™last_messageä¸å˜
    }

    // if no updates, return
    if (Object.keys(updates).length === 0) {
        return;
    }
    
    // Merge updates
    const mergedData = { ...currentData, ...data };
    
    // Update hx-vals attribute with merged data
    const container = document.getElementById('candidate-context');
    container.setAttribute('hx-vals', JSON.stringify(mergedData));
    
    // Get identifiers from the updated data for matching
    const identifiers = {
        chat_id: mergedData.chat_id,
        conversation_id: mergedData.conversation_id,
        candidate_id: mergedData.candidate_id,
        index: mergedData.index
    };
    
    // Broadcast the update event to candidate cards
    const event = new CustomEvent('candidate:update', {
        detail: {
            identifiers: identifiers,
            updates: updates,  // Send only the changed fields, not mergedData
        }
    });
    document.dispatchEvent(event);
    
    // Update copy link button visibility if candidate_id was added or updated
    if (updates.candidate_id || mergedData.candidate_id) {
        updateCopyLinkButton();
    }

    // update to cloud 
    if (Object.keys(updates).length > 0) {
        const response = await fetch('/candidates/save', {
            method: 'POST',
            body: JSON.stringify({...identifiers, ...updates}),
        });
        await window.handleApiResponse(response);
    }
}

function getCandidateData(key) {
    const hxVals = document.getElementById('candidate-context').getAttribute('hx-vals');
    if (hxVals) {
        const data = JSON.parse(hxVals);
        // If key is provided, return that property; otherwise return the whole object
        return key !== undefined ? data[key] : data;
    }
    return key !== undefined ? null : {};
}


function getThresholdValues() {
    return {
        chat_threshold: parseFloat(document.getElementById('threshold-chat')?.value) || 6.0,
        borderline_threshold: parseFloat(document.getElementById('threshold-borderline')?.value) || 7.0
    };
}

/**
 * Copy candidate detail link to clipboard
 */
async function copyCandidateLink() {
    const candidate_id = getCandidateData('candidate_id');
    const public_url = window.__public_url;
    
    if (!candidate_id) {
        showToast('æ— æ³•è·å–å€™é€‰äººID', 'error');
        return;
    }
    
    if (!public_url) {
        showToast('Public URLæœªé…ç½®', 'error');
        return;
    }
    
    try {
        const candidate_link = `${public_url}/candidate/${candidate_id}`;
        
        // Copy to clipboard
        await navigator.clipboard.writeText(candidate_link);
        showToast('é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
    } catch (error) {
        console.error('Failed to copy link:', error);
        showToast('å¤åˆ¶é“¾æ¥å¤±è´¥', 'error');
    }
}

/**
 * Show/hide copy link button based on candidate_id availability
 */
function updateCopyLinkButton() {
    const candidate_id = getCandidateData('candidate_id');
    const public_url = window.__public_url;
    const copyBtn = document.getElementById('copy-link-btn');
    
    if (copyBtn && candidate_id && public_url) {
        copyBtn.classList.remove('hidden');
        copyBtn.style.display = '';
    } else if (copyBtn) {
        copyBtn.classList.add('hidden');
        copyBtn.style.display = 'none';
    }
}

// ============================================================================
// UI Helper Functions
// ============================================================================

function switchResumeTab(tab) {
    // Hide all tab contents
    document.getElementById('tab-content-online').classList.add('hidden');
    document.getElementById('tab-content-full').classList.add('hidden');
    
    // Remove active styles from all tabs
    document.getElementById('tab-online').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-online').classList.add('text-gray-600');
    document.getElementById('tab-full').classList.remove('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
    document.getElementById('tab-full').classList.add('text-gray-600');
    
    // Show/hide fetch buttons based on active tab
    const fetchOnlineBtn = document.getElementById('fetch-online-resume-btn');
    const fetchFullBtn = document.getElementById('fetch-full-resume-btn');
    
    // Show selected tab content and activate tab button
    if (tab === 'online') {
        document.getElementById('tab-content-online').classList.remove('hidden');
        document.getElementById('tab-online').classList.remove('text-gray-600');
        document.getElementById('tab-online').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show online resume button, hide full resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.remove('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.add('hidden');
    } else if (tab === 'full') {
        document.getElementById('tab-content-full').classList.remove('hidden');
        document.getElementById('tab-full').classList.remove('text-gray-600');
        document.getElementById('tab-full').classList.add('bg-white', 'border-b-2', 'border-blue-500', 'text-blue-600');
        // Show full resume button, hide online resume button
        if (fetchOnlineBtn) fetchOnlineBtn.classList.add('hidden');
        if (fetchFullBtn) fetchFullBtn.classList.remove('hidden');
    }
}

// Run initialization when partial is loaded via HTMX
// This ensures process_candidate() runs on each HTMX swap
(function () {
    // Update copy link button on initial load
    updateCopyLinkButton();
    
    // å½“åœ¨æœç´¢é¡µé¢æŸ¥çœ‹å€™é€‰äººè¯¦æƒ…æ—¶ï¼Œä½¿ç”¨ readonly æ¨¡å¼ï¼Œä¸åº”è¯¥æ‰§è¡Œ
    const viewMode = window.__candidate_detail_view_mode || 'interactive';
    if (viewMode === 'readonly') return;
    
    // Function to run process_candidate with proper error handling
    async function runProcessCandidate() {
        // Set initial tab state - show online tab if resume_text exists, otherwise show full tab
        const fullTextarea = document.getElementById('resume-textarea-full');
        switchResumeTab( fullTextarea?.value?.trim().length > 100 ? 'full' : 'online');
        await process_candidate();
    }
    
    // Use setTimes paused when the tab is not visible, but setTimeout is only throttled
    setTimeout(() => {
        runProcessCandidate();
    }, 100);
})();

</script>
